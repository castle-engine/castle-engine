{
  Copyright 2025-2025 Michalis Kamburelis.

  This file is part of "Castle Game Engine".

  "Castle Game Engine" is free software; see the file COPYING.txt,
  included in this distribution, for details about the copyright.

  "Castle Game Engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

  ----------------------------------------------------------------------------
}
{ Generate Pascal code IFC API. See README.md for details. }

{$I castleconf.inc}

uses SysUtils, Classes, Dom, XmlRead, Generics.Defaults, Generics.Collections,
  {$ifdef FPC} OpenSSLSockets, {$endif} // support HTTPS
  CastleStringUtils, CastleClassUtils, CastleDownload, CastleXmlUtils,
  CastleUtils, CastleFilesUtils;

const
  SchemaUrl = 'https://standards.buildingsmart.org/IFC/RELEASE/IFC4_3/HTML/IFC4X3_ADD2.xsd';
  SchemaFile = 'IFC4X3_ADD2.xsd';
  OutputPath: String = '../../../src/scene/load/ifc/castleifc_ifc_standard_types_autogenerated.inc';
var
  ManuallyDefinedTypes: TStringList;

{ TIfcType ------------------------------------------------------------------ }

type
  TIfcType = class
    NameIfc, NamePascal: String;
    function DeclareOrder: Integer; virtual;
    class function IfcNameToPascal(const IfcClassName: String): String; static;
    procedure MakeOutput(var OutputInterface, OutputImplementation,
      OutputAddClasses: String); virtual;
  end;

function TIfcType.DeclareOrder: Integer;
begin
  Result := 0;
end;

class function TIfcType.IfcNameToPascal(const IfcClassName: String): String; static;
begin
  if SameText(IfcClassName, 'ifc:Entity') then
    Result := 'IfcPersistent' // base ancestor of all IFC classes
  else
    Result := PrefixRemove('Ifc:', IfcClassName, true);
  { Convert XSD -temp to _Temp (valid Pascal).
    XSD is using this for some intermediate classes, not in spec, but useful
    to define. We follow this in Pascal. }
  if IsSuffix('-temp', Result, true) then
    Result := SuffixRemove('-temp', Result, true) + '_Temp';
  { Follow conventions of src/scene/load/ifc/castleifc_ifc_standard_types.inc
    to name IFC classes.
    Add _Spec suffix to classes that would otherwise seems like TObjectList
    descendants. }
  if IsSuffix('List', Result, true) then
    Result := Result + '_Spec';
  Result := 'T' + Result;
end;

procedure TIfcType.MakeOutput(var OutputInterface, OutputImplementation,
  OutputAddClasses: String);
begin
  // nothing to do here
end;

{ TIfcComplexType ----------------------------------------------------------- }

type
  TIfcComplexType = class(TIfcType)
    BaseIfc, BasePascal: String;
    BaseInstance: TIfcComplexType;
    Abstract: Boolean;
    function DeclareOrder: Integer; override;
    procedure MakeOutput(var OutputInterface, OutputImplementation,
      OutputAddClasses: String); override;
  end;

function TIfcComplexType.DeclareOrder: Integer;
begin
  Result := inherited;
  Inc(Result); // place all classes after simple types like enums
  { This is a recursive call, but shouldn't hang if there are no cycles
    in ancestry tree in XSD. }
  if BaseInstance <> nil then
    Result := Result + 1 + BaseInstance.DeclareOrder;
end;

procedure TIfcComplexType.MakeOutput(var OutputInterface, OutputImplementation,
  OutputAddClasses: String);
const
  IfcSpecUrl = 'https://standards.buildingsmart.org/IFC/RELEASE/IFC4_3/HTML/lexical/%s.htm';
var
  NiceNameIfc, Comment: String;
begin
  inherited;

  NiceNameIfc := PrefixRemove('Ifc:', NameIfc, true);
  if IsSuffix('_Temp', NamePascal, true) then
  begin
    Comment := Format('{ IFC internal class %s (not in specification, only in XSD). }', [
      NiceNameIfc
    ]);
  end else
  begin
    Comment := Format('{ IFC class @url(' + IfcSpecUrl + ' %s). }', [
      NiceNameIfc,
      NiceNameIfc
    ]);
  end;

  OutputInterface := OutputInterface + Format(
    '  %s' + NL +
    '  %s = class%s(%s)' + NL +
    '  strict private' + NL, [
      Comment,
      NamePascal,
      Iff(Abstract, ' abstract', ''),
      BasePascal
    ]);
  // TODO: properties, private and public and published
  OutputInterface := OutputInterface +
    '  end;' + NL + NL;

  OutputAddClasses := OutputAddClasses + Format(
    '  FIfcClasses.Add(%s);' + NL, [
      NamePascal
    ]);
end;

{ TIfcTypeList -------------------------------------------------------------- }

type
  TIfcTypeList = class({$ifdef FPC}specialize{$endif} TObjectList<TIfcType>)
  public
    { @nil if not found. }
    function Find(const NamePascal: String): TIfcType;
    { Assign TIfcComplexType.BaseInstance where possible. }
    procedure ResolveAncestors;
    { Compare TIfcType to determine order in which they should be declared. }
    function CompareIfcTypes(
      {$ifdef GENERICS_CONSTREF}constref{$else}const{$endif}
      Left, Right: TIfcType): Integer;
    procedure MakeOutput(out OutputInterface, OutputImplementation,
      OutputAddClasses: String);
  end;

  TIfcTypeComparer = specialize TComparer<TIfcType>;

var
  IfcTypes: TIfcTypeList;

function TIfcTypeList.Find(const NamePascal: String): TIfcType;
begin
  for Result in Self do
    if Result.NamePascal = NamePascal then
      Exit;
  Result := nil;
end;

procedure TIfcTypeList.ResolveAncestors;
var
  IfcType: TIfcType;
  ComplexType: TIfcComplexType;
begin
  for IfcType in Self do
    if IfcType is TIfcComplexType then
    begin
      ComplexType := TIfcComplexType(IfcType);
      ComplexType.BaseInstance := Find(ComplexType.BasePascal) as TIfcComplexType;
    end;
end;

function TIfcTypeList.CompareIfcTypes(
  {$ifdef GENERICS_CONSTREF}constref{$else}const{$endif}
  Left, Right: TIfcType): Integer;
begin
  Result := Left.DeclareOrder - Right.DeclareOrder;
end;

procedure TIfcTypeList.MakeOutput(out OutputInterface,
  OutputImplementation, OutputAddClasses: String);
var
  IfcType: TIfcType;
begin
  OutputInterface := '';
  OutputImplementation := '';
  OutputAddClasses := '';
  for IfcType in Self do
    IfcType.MakeOutput(OutputInterface, OutputImplementation, OutputAddClasses);
end;

{ routines ------------------------------------------------------------------ }

procedure DownloadSchema;
var
  SchemaStream: TMemoryStream;
begin
  if FileExists(SchemaFile) then
    Writeln('Schema file exists: ', SchemaFile)
  else
  begin
    Writeln('Schema file does not exist, downloading: ', SchemaFile);
    EnableBlockingDownloads := true;
    SchemaStream := Download(SchemaUrl, [soForceMemoryStream]) as TMemoryStream;
    try
      SchemaStream.SaveToFile(SchemaFile);
    finally FreeAndNil(SchemaStream) end;
  end;
end;

procedure IfcTypeFromXsd(const Element: TDomElement);
var
  NameIfc, NamePascal: String;
  ComplexContent, ExtensionOrRestriction: TDomElement;
  ComplexType: TIfcComplexType;
begin
  NameIfc := Element.AttributeString('name');
  NamePascal := TIfcType.IfcNameToPascal(NameIfc);

  //Writeln('Processing ', NameIfc, ' -> ', NamePascal);

  // It seems root level for IFC file? or some internal XSD helper type?
  // we use TIfcFile for this.
  if SameText(NameIfc, 'ifcXML') then
    Exit;

  if ManuallyDefinedTypes.IndexOf(NamePascal) <> -1 then
    Exit;

  if Element.TagName8 = 'xs:complexType' then
  begin
    { Sample:
    <xs:complexType name="IfcRailingType">
      <xs:complexContent>
        <xs:extension base="ifc:IfcBuiltElementType">
          <xs:attribute name="PredefinedType" type="ifc:IfcRailingTypeEnum" use="optional"/>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
    }
    ComplexContent := Element.Child('xs:complexContent', false, true);
    if ComplexContent <> nil then
    begin
      ExtensionOrRestriction := ComplexContent.Child('xs:extension', false, true);
      if ExtensionOrRestriction = nil then
        ExtensionOrRestriction := ComplexContent.Child('xs:restriction', false, true);
      if ExtensionOrRestriction <> nil then
      begin
        // create and add TIfcComplexType instance
        ComplexType := TIfcComplexType.Create;
        ComplexType.Abstract := Element.AttributeBooleanDef('abstract', false);
        ComplexType.NameIfc := NameIfc;
        ComplexType.NamePascal := NamePascal;
        ComplexType.BaseIfc := ExtensionOrRestriction.AttributeString('base');
        ComplexType.BasePascal := TIfcType.IfcNameToPascal(ComplexType.BaseIfc);
        IfcTypes.Add(ComplexType);
      end;
    end;
  end else
  if Element.TagName8 = 'xs:simpleType' then
  begin
    // TODO, e.g. enums are here
  end else
  begin
    // TODO, anything useful here?
  end;
end;

{ Just like UrlReadXml, but forces encoding from ASCII to UTF-8.
  Reason: IFC XSD uses ASCII encoding,

    <?xml version='1.0' encoding='ASCII'?>

  which causes

    Encoding 'ASCII' is not supported (in file "IFC4X3_ADD2.xsd")

  error from FPC XMLRead (because TXMLDecodingSource.SetEncoding
  does not support ASCII). }
function UrlReadXml_ForceEncodingUtf8(const Url: String): TXmlDocument;
var
  Stream: TStream;
  Str: String;
  NewStream: TStringStream;
begin
  Stream := Download(Url);
  try
    Str := ReadGrowingStreamToDefaultString(Stream);
    Str := StringReplace(Str, 'encoding=''ASCII''', 'encoding=''UTF-8''', []);
    NewStream := TStringStream.Create(Str);
    try
      ReadXmlFile(Result, NewStream);
    finally FreeAndNil(NewStream) end;
  finally FreeAndNil(Stream) end;
end;

var
  Doc: TXmlDocument;
  I: TXMLElementIterator;
  OutputInclude, OutputInterface, OutputImplementation, OutputAddClasses: String;
begin
  DownloadSchema;

  { All global instances are nil, use this to have less nesting in try..finally. }
  try
    ManuallyDefinedTypes := TStringList.Create;
    ManuallyDefinedTypes.LoadFromUrl('castle-data:/manually_defined_types.txt');

    IfcTypes := TIfcTypeList.Create(true);

    Doc := UrlReadXml_ForceEncodingUtf8(SchemaFile);
    try
      I := Doc.DocumentElement.ChildrenIterator;
      try
        while I.GetNext do
          IfcTypeFromXsd(I.Current);
      finally FreeAndNil(I) end;
    finally FreeAndNil(Doc) end;

    IfcTypes.ResolveAncestors;
    IfcTypes.Sort(TIfcTypeComparer.Construct(
      {$ifdef FPC}@{$endif} IfcTypes.CompareIfcTypes));
    IfcTypes.MakeOutput(OutputInterface, OutputImplementation, OutputAddClasses);

    OutputInclude :=
      '{%MainUnit castleifc.pas}' + NL +
      '{ Auto-generated IFC classes definitions by generate_ifc. }' + NL +
      '{$ifdef read_interface_types}' + NL +
      '//type' + NL +
      OutputInterface +
      '{$endif read_interface_types}' + NL +
      NL +
      '{$ifdef read_implementation}' + NL +
      OutputImplementation + NL +
      '{$endif read_implementation}' + NL +
      NL +
      '{$ifdef read_add_classes}' + NL +
      OutputAddClasses + NL +
      '{$endif read_add_classes}';
    StringToFile(OutputPath, OutputInclude);
  finally
    FreeAndNil(ManuallyDefinedTypes);
    FreeAndNil(IfcTypes);
  end;
end.
