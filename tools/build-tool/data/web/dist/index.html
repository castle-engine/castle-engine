<!doctype html>

<!--
  Castle Game Engine web application default HTML.

  You can customize this HTML as you like, there are only a few critical things
  you have to keep:

  - keep <canvas id="castle-canvas">
  - keep <script src="${EXECUTABLE_NAME}.js?..."> that refers to our JS code
  - keep <script> code doing rtl.run that runs our JS code

  See https://castle-engine.io/web about using Castle Game Engine web support.

  This HTML uses basic Bootstrap skeleton from
  https://getbootstrap.com/docs/5.3/getting-started/introduction/ ,
  refering to the Bootstrap CSS and JS from CDN.
  Note that if you customize this HTML,
  you don't need to keep using Bootstrap.
  You can also make the Bootstrap available locally (not use CDN).
-->

<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>${CAPTION}</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">

  <script src="${EXECUTABLE_NAME}.js${RANDOM_URL_SUFFIX}"></script>
  <style>
    body {
      padding: 1em;
    }
    /* Style BrowserConsole output */
    #pas2js-console .pasconsole {
      /* let #pas2js-console background be visible */
      background: transparent !important;
      /* override Courier from BrowserConsole */
      font-family: monospace !important;
      /* override 14px from BrowserConsole */
      font-size: initial !important;
    }
    .credits {
      font-size: smaller;
    }
    #castle-loading-info {
      font-style: italic;
    }
    /* Add some space between the button and the console */
    button.btn-primary {
      margin-top: 0.5em;
      margin-bottom: 1em;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>${CAPTION}</h1>

    <!-- Loading status.
      Our code (in pas2js and WebAssembly) will update this,
      changing text, changing color, hiding it when loading finished.
      You can even remove this HTML element when customizing your HTML,
      CGE code will still work -- just ignoring this. -->
    <div id="castle-loading-info">Loading application...</div>

    <!-- Progress bar styled using Bootstrap, see https://getbootstrap.com/docs/5.3/components/progress/#how-it-works .
      Our code (in pas2js and WebAssembly) will update this.
      You can even remove this HTML element when customizing your HTML,
      CGE code will still work -- just ignoring this. -->
    <div id="castle-loading-progress-container" class="progress" role="progressbar" aria-label="Animated striped example" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">
      <div id="castle-loading-progress-bar" class="progress-bar progress-bar-striped progress-bar-animated" style="width: 0%"></div>
    </div>

    <!-- Canvas for rendering.

      Note: We set canvas size using "style" CSS (how much does it take on screen)
      independently from the rendering context resolution ("width" and "height"
      attributes).
      This allows to set the rendering context resolution to be perfect
      (match the device pixels).
      See resizeTheCanvasToDisplaySize below
      and https://www.khronos.org/webgl/wiki/HandlingHighDPI for more details.

      TODO: use wasm to copy size to style?
      And document it here just as:

      Note that the WebAssembly code will update the size of this canvas.
      - We will update the display size (by CSS style) to stay as specified.
      - We will update the rendering area resolution
        (by canvas.width and canvas.height)
        to match the actual pixel resolution of the canvas on the screen.
        This makes rendering "crisp" (no blurring).
        We will do this on any canvas resize event (e.g. after fullscreen toggle).
    -->
    <canvas width="${WEB_CANVAS_WIDTH}" height="${WEB_CANVAS_HEIGHT}"
      style="width: ${WEB_CANVAS_WIDTH}px; height: ${WEB_CANVAS_HEIGHT}px;"
      id="castle-canvas">
      Your browser does not support the HTML5 canvas element.
    </canvas>

    <button type="button" class="btn btn-primary d-block"
      onclick="document.getElementById('castle-canvas').requestFullscreen();"
      >Enter Fullscreen</button>

    <div id="pas2js-console" class="p-2 bg-body-secondary border rounded-3">
      <b>Logs:</b>
      <div id="pas2js-console-output"></div>
    </div>

    <p class="credits">Made with <a href="https://castle-engine.io/">Castle Game Engine</a>, <a href="https://www.freepascal.org/">FPC for WebAssembly</a> and <a href="https://getpas2js.freepascal.org/">Pas2js</a>.</p>
  </div>

  <!-- Load JS at the end -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>
  <script>
    /* Make canvas size match the display size in pixels.
      This updates the canvas e.g. after toggling fullscreen,
      also it updates the display to be "crisp" (by rendering to the actual
      pixel resolution of the screen).

      TODO: web: move this to wasm code in castlewindow_webassembly.inc . */
    const canvas = document.getElementById("castle-canvas");

    function resizeTheCanvasToDisplaySize(entries) {
      const entry = entries[0];
      let width;
      let height;
      if (entry.devicePixelContentBoxSize) {
        width = entry.devicePixelContentBoxSize[0].inlineSize;
        height = entry.devicePixelContentBoxSize[0].blockSize;
      } else if (entry.contentBoxSize) {
        // fallback for Safari that will not always be correct
        width = Math.round(entry.contentBoxSize[0].inlineSize * devicePixelRatio);
        height = Math.round(entry.contentBoxSize[0].blockSize * devicePixelRatio);
      }
      console.log(`Canvas resized (to match new display size in pixels) to ${width}x${height} (devicePixelRatio: ${devicePixelRatio})`);
      canvas.width = width;
      canvas.height = height;
    }

    function initializeResizeTheCanvasToDisplaySize() {
      const observer = new ResizeObserver(resizeTheCanvasToDisplaySize)
      observer.observe(canvas);
    }
    initializeResizeTheCanvasToDisplaySize();

    rtl.showUncaughtExceptions=true;
    window.addEventListener("load", rtl.run);
  </script>
</body>
</html>
