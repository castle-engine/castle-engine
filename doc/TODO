The central TODO file. There are also some TODOs scattered elsewhere,
do "find -iname TODO*" to find them.
In paricular, ../../www/TODO contains "next-release" stuff,
usually has a list of blockers typically worked upon right before release.

------------------------------------------------------------------------------
view3dscene 3.5 blockers:
- finish X3D nurbs component up to level 2, update vrml_impl_status about it.
  Remaining:
    CoordinateDouble
    NurbsTextureCoordinate
    NurbsSet

- castle: same plane walls on doom e1m1 level:
  - at the first door
  - right when opening the secret (lighter) door
  (exist also in srcs before TLevelObject - T3D transition, so this isn't any bug from this.)

------------------------------------------------------------------------------
Scene manager / controls / better Lazarus integration:

(blockers before 2.0 release) ------------------------------------------------

Remaining castle's unclean stuff:

- Fix controls menu from game - pass undercontrols, test, see if fade rect works ok
- There were some problems with creature behavior, 1st creature stood
  still on tower / fountain level? Maybe some Idle over creatures
  not done / done badly?

* castle: make MainScene.ProcessEvents := true,
  check receives time events (timesensor, movietexture),
  and mouse/key clicks (use some touchsensor, keysensor),
  make it correctly paused when entering game menu.

- TKamSceneManager.RenderFromView3D : RenderNoShadows should split rendering
  to all tgOpaque + then all tgTransparent.
  Do this while porting to castle?

- Use SceneManager *everywhere*:

  RenderState.Camera* is currently not initialized in various programs.
  This is supposed to be fixed by using SceneManager everywhere,
  that's why I didn't want to pollute code for now.
  When you don't use generated textures, RenderState.Camera* is only for
  Viewpoint events and WORLDSPACE* tex coord generation,
  which is simply not used by some programs. Below is extracted from
  grep_pas_src . 'glLoadMatrix(.*camera.matrix)'

  rift:
    ../../rift/riftplay.pas:141:  glLoadMatrix(SceneCamera.Matrix);
  pure OpenGL demos (no VRML code), possibly let them use Glw.Camera?
    For direct_vrmlglscene_xxx, it's even by design (this shows that without
    scenemanager you can also work):
    ../examples/vrml/direct_vrmlglscene_test_1.pasprogram:58:  glLoadMatrix(glw.Camera.Matrix);
    ../examples/vrml/direct_vrmlglscene_test_2.pasprogram:76:  glLoadMatrix(glw.Camera.Matrix);
    ../examples/vrml/terrain/terrain.pasprogram:200:  glLoadMatrix(Glw.Camera.Matrix);
    ../examples/glwindow/bezier_surfaces/animate_surface.pasprogram:95:  glLoadMatrix(Glw.Camera.Matrix);
    ../examples/glwindow/bezier_surfaces/design_surface.pasprogram:202:  glLoadMatrix(Glw.Camera.Matrix);

  for non-vrml scenes, assigning OnRender3D may be the simplest way to use
  scenemanager. Hm, or not really? We should also create our own camera,
  and override ApplyProjection, since only we know our bounding box.

  Hm, for some of the remaining examples, it could be simpler to just let
  them use default Camera, no point in forcing SceneManager?

* Camera: since no longer have to be added to Controls,
  remove TGLUIWindow.Camera now.

  Depends on: port all example programs to SceneManager first.
  In particular, port castle, and for the rest of remaining --- either
  make their own Camera variable, or also port to SceneManager.

  Resolves:
  Remove Camera property entirely from TGLUIWindow/TKamOpenGLComponent?
  Usually SceneManager.Camera is comfortable now.

  Old notes: Hm, no? Resign?
  1. Scene.Camera future is uncertain. It may be removed,
     in favor of only SceneManager.Camera. Wait for transition until this
     is decided, to avoid rewriting a lot of code (Glw.Camera -> Scene.Camera)
     just to rewrite it again (Scene.Camera -> SceneManager.Camera).

     Later resolution: SceneManager.Camera ready, no longer Scene.Camera,
     this is stable.

  2. Wait for removal until Controls list is settable from the Lazarus IDE.
     Otherwise, right now Camera is settable from IDE, Controls not,
     so 1 advantage of Camera property.

     Later resolution: SceneManager.Camera could be settable from IDE now.

  3. Seems comfortable and not confusing. Leave it be?

     Later resolution: confusing, since Camera should only be on one
     of SceneManager or Controls, not both (then Idle etc. may work too fast.

  Actually, since having Camera on controls makes problems (because
  of hacky PositionInside, as Camera is invisible), maybe even
  remove TCamera from being TUIControl? Make TCamera separate class?

  Maybe make some common class, like TInputListener, for TUIControl,
  TCamera, TBase3D. Or at least for TUIControl, TCamera.
  Maybe TInvisibleUIControl, or TCustomUIControl?

* Making Viewport*, see TODO.scene_manager_viewport, should be trivial now!
  - GLProjection should take x, y as well as width, height
  - Like on TODO.scene_manager_viewport, we'll need ViewportAutoResize default true
  - use it in tscenemanager
  - also, in tscenemanager, add property AlwaysApplyProjection, default false,
    use "AlwaysApplyProjection and ApplyProjectionNeeded" in render,
  - make laz demo, with 4 scene managers, each having other corner of window,
    maybe 2 left share the same scene and 2 right share the same scene,
    but from different views (only in one view is scene set as MainScene,
    in others it's just added to the tree, this should work without problems),
    when resing control the scene managers are resized to occupy appropriate
    screen corner. Make sure to use something mith generatedcubemap,
    to test that getting back viewport is Ok.
  - TSceneManager.PositionInside could use Viewport*, if not ViewportAutoResize.

  Make a news item about this, with demo screenshot, on changes_log.

* TSceneManager: UpdateGeneratedTextures for all, see TODO in file.

* TVRMLGLAnimation props make more persistent:

  The fact that TimeLoop, TimeBackwards, Optimization get changed by file load
  is confusing and bad, setting this from Lazarus makes currently little use.
  We also had view3dscene UI problem because of this.
  Maybe make it changing only if Load() gets argument like LoadTimeAndOptimization?

- Make UseControls not published? Or even make them private --- they are not used
  after all, and can be dangerous (ContainerResize not called before trying to
  do rendering etc.)

(not blockers before 2.0 release) --------------------------------------------

- TVRMLGLLightSet - hm, it would be useful to eliminate need to use this
  e.g. in castle. Can SceneManager help us here? Ideally, a way to allow
  all the vrml scenes to mix their OpenGL lights could be great?

  Hm, not really, not yet.
  We would like to easily allow VRML lights (with global=TRUE,
  this will be following VRML idea) to be shared, but this requires dynamic
  OpenGL light allocation (not governed by Scene.Attributes.First/Last).
  But this means not storing lights in display lists (as VRML lights may
  always change) and this means dropping optimizations (only roNone,
  roSeparateShapesNoTransform may be left), which generally waits for
  remaking rendering to full VBO.

  For now we would have to just allow MainScene to take all the lights and leave
  them set for other scenes. Hm, actually sensible...

* Cursor stuff:
  * What to do with cursors of 3D scenes hierarchy?
    See notes in scenemanager.ItemsCursorChange: currently just takes MainScene.Cursor.
    See notes in TBase3D.ListCursorChange (similar for TVRMLGLAnimation): maybe set upper-level cursor?

    Maybe always do some sort of mouse picking in scenemanager, over all scenes,
    to choose closest one (and use it for new cursor) in MouseMove?
    Also, save the closest one, for next UpdateCursor?

- castle: besides level (MainScene, and level objects as additional stuff),
  it would be most perfect if castle creatures / items would be part of
  SceneManager too.

* Should TSceneManager be free from VRML specifics?

  - Yes-> Can be moved to 3d/ or ui/.

    Advantage: TGLUIWindow/TKamOpenGLControl could then create
    and automatically add SceneManager to Controls.
    This would simplify some stuff, since in new engine (almost)
    everything will use SceneManager.
    Also, since SceneManager will set MainScene.GLProjection in
    ContainerResize, there can be only one SceneManager used at one time.

  - Counterargument for auto-initialization of SceneManager:

    - Some programs want their own TKamSceneManager descendant.
    - Some programs may have > 1 SceneManager, if they will have
      non-default viewports, and both 3d worlds will be separate.

    So it's not true that there's always 1 instance of TKamSceneManager.

    Although this doesn't rule out the possibility to create SceneManager
    by default? We could always create default scenemanager on demand
    (when first calling SceneManager?), and allow to change it anyway
    by assigning to TGLUIWindow.SceneManager property.

    But this is unclean, making unclear what happens with Controls?
    This has the same conceptual problem as with TGLUIWindow.Camera?

  - Counterargument: TSceneManager.MainScene must point to
    VRML-enabled:TVRMLScene.

    Unless we make TVRMLSceneManager? Then general TSceneManager
    will not be dependent on VRML.
    Or design TBase3D intelligently, maybe there
    will not be need for any TVRMLGLSCene-specific stuff in current
    TSceneManager.

  Overall, this is quite a large rearrangement for TSceneManager,
  just to avoid dependencies... Moreover, note that for now Base3D
  is also dependent on VRML (since it uses VRMLTriangle types, to filter
  out items for collision detection etc.). This would have to be resolved
  first.

* Let RenderState use some Camera reference, maybe make TSimpleCamera to avoid
  overloading it with full camera props for temporary camera settings?

* Lazarus: make the control painted at design-time?

* Maybe make a news item and a few screenshots how to easily use it from Lazarus?

- Make TKamOpenGLControl.Controls list settable from the IDE,
  to allow visually adding new TUIControls there.

  At designtime, warn on error: do not put > 1 camera in Controls list,
  while it works it's usually nonsense.
  Or not: shadow_volume_test shows that it's possible to have two cameras,
  and things work smoothly. You just have to assign non-conflicting keys.

- Make sure most useful props of our controls are settable:

  For TGLMenu, browse and decide which ones (Items?).

  TVRMLScene.CompiledScriptHandlers (will require some designer to settable from IDE)
  TVRMLGLAnimation.FileName, implement similar to TVRMLScene.FileName.

  For cameras generally, what Init method takes should be settable.
  For cameras generally, Input_Xxx properties.
  TWalkCamera: CameraInitialPos/Dir/Up (how are settable from IDE?)
  TExamineCamera: ModelBox (how are settable from IDE?)
  Gravity, CameraRadius, CameraPreferredHeight, OnMoveAllowed, OnGetCameraHeight?

- make icons for our components.
  Same style cameras (black with dotted lines):
    Walking man icon for TWalkCamera,
    Rotated box for TExamineCamera.
  Same style areas:
    TKamOpenGLControl
    TKamVRMLBrowser (maybe use the same image, with just a text "OpenGL" or "GL"
      on one, "VRML" on other)
  Needed ideas for TGLMenu.
  For TKamXMLConfig use some slightly modified icon of TXMLConfig, since this is almost the same?
  For TKamRecentFiles use some slightly modified icon of TMainMenu or TPopupMenu.

* TVRMLScene (no GL) on a Lazarus palette? Confusing with TVRMLGLScene, but is also useful.
------------------------------------------------------------------------------
For view3dscene 3.6:
- implement more pointing device sensors
- basic networking support
(I want to have full coverage of X3D "Interactive" with 3.6 release),
fix Victor Amat problems with touch sensor picking along the way.

------------------------------------------------------------------------------
For view3dscene 4.0:
JavaScript, or Python/Lua?

------------------------------------------------------------------------------
Various ideas:

* NavigationInfo binding and changes treat better.
  - E.g. NavigationInfoStack.OnBoundChanged should cause appropriate change
  - camera's Move*Speed user-preference (should always start at 1.0)
    should be separated from speed determines from VRML NavigationInfo.speed.
    This will clean things up.

* glwinmessages scrollbars:
  http://www.useit.com/alertbox/20050711.html

* Future: TAnyCamera in the future (when I'll figure out how to switch cam pos/dir/up to examine props), with Examine, Walk, None variants.

- Maybe more improvements along the vrml_implementation_status.php division:
  - #section_x3d_multitex_clarifications - move to "texturing" component page?
  - NIST VRML tests move to separate?
  - DDS support move to separate?

- Joerg pointed out possible problem with quads for NurbsSurface*:

  Ah, I understand now, and that's also why the problem is visible with
  symmetric surfaces... Thanks, will do some testing, maybe eventually
  I'll add a field to IndexedQuadSet like tesselateIntelligently:SFBool to
  force tesselating quads into 2 tris by intelligently choosing a dividing
  edge (to make it shortest). This would force correct look of all
  IndexedQuadSet, including NurbsPatchSurface.

- on kocury win 2000 prof with Geforce 5200, FBO config is never supported.
  While on Linux (32, 64) it's Ok.
  Why? Driver buggy? Test can we get FBO under *any* windows system?

- Only on x86_64: GLU tesselatator is ultra-slow.

  So loading anything with a 3D Font takes some time (around 4-5 seconds per font; while it's instanteneous on 32bit). 3D Font is right now used only by VRML Text node, no program initializes TGLOutlineFont directly.

  The slowness can be seen e.g. in castle when loading ("credits" model has 3D fonts). Or in view3dscene when opening any file using font, like x3d/cubemap_generated_in_dynamic_world.x3dv. Extreme case is kambi_vrml_test_suite/vrml_2/text.wrl: all 9 fonts used, loading time is 37 seconds.

  This is also a blocker for making "welcome scene" in view3dscene using Text font.

  The slowness is in Cache.Fonts_IncReference.
  Not reproducible on 32 bit (fpc 2.2.4 kocury/linux/32), so it must be some 64-bit problem.
  The slowness is inside gluTessVertex in TGLOutlineFont.Create. Which means I cannot do anything about it? It's the GLU tesselators that are much slower on x86_64, it seems.

  One solution could be to cache the tesselated result. I could even compile the cached result into the program, this way user doesn't have to do it at all.
  Trouble: is it really helpful in the long run? I would like some time to load fonts from TTF files and then runtime tesselation is a must. And then caching helps, but not for the 1st tesselation run...

  Idea: not tesselating all letters would be useful?
  This would be a valid optimization (needed in the long run anyway, for Unicode fonts I wouldn't want to tesselate all characters at loading anyway).
  For now, possibly I would just need basic ASCII support, so not all 256 characters need to be defined?
  Done: we use only a subset: SimpleAsciiCharacters. 4-5 and 37 seconds measures are with this already enabled... so it's working, but it's still slow.

  For view3dscene 3.4, this will have to be enough.

- fix vrmlengine for seamless avatars - or is it javascript lack?

------------------------------------------------------------------------------
Effects, techniques, passes:
- victor amat
  http://http.developer.nvidia.com/CgTutorial/cg_tutorial_appendix_c.html,
- dane osowskiego i OGRE,
- tak¿e http://http.developer.nvidia.com/GPUGems/gpugems_ch36.html chyba wszyscy o tym wspominaj±...

------------------------------------------------------------------------------
Occlusion culling (Ok for post 3.4):

- make RenderState.StenilTest be used also to pause (not update visibility) in hierarch oq, it would be a waste of temporal conh to not pause there.

- if tests show hierarchical is much better than UseOcclusionQuery,
  old UseOcclusionQuery may be removed (and this may be renamed
  to just UseOcclusionQuery). (Or keep old UseOcclusionQuery only
  for seminar.)

- make nicer interaction OctreeFrustumCulling (use it for frustum checks in
  UseHierarchicalOcclusionQuery).
  And with RenderFrustum_Frustum^, right now we just take it.

- UseHierarchicalOcclusionQuery ignores blending for now.

- this strange thing on bzwgen level, that always shown yellow block, although it should be normally visible afterwards. What's with it? Fixed now?
  No, it still exists.

- tree may be very very poor for shapes. E.g. atcs. This also makes hierarch culling perform badly.
  Hmm, I see why the octree has a lot of duplication on regular_labirynth, although how to improve? Possibly some bottom-to-top scan that turns off octree planes where all children are the same?
  For now, I can add dummy box to the regular_labirynth to force octree be correct.
  For atcs, how to fix?

- Various rendering targets, and "inshadow" for stencil, should just have a separate occlusion query state. This will allow to use oq for all situations, unlike current where oq is done normally only for non-shadowed with target = rtScreen.
  See TODO in vrmlglscene.pas about this too.

------------------------------------------------------------------------------
moved post 3.4:

- multitex:
  - fix for normal primitives: set all texture coords equal.

Victor Amat list (overlapping with mine, so let's go with it):
  - passing vertex attributes to shaders

  - Note that to use it, you would also need to know the current screen
    size, how about adding outputOnly events to X3DViewpointNode that return
    screenWidth, screenHeight as SFInt32?

    Hm, bs contact has "eventOut SFVec2f windowSize", although I don't know on wha node.
    http://www.bitmanagement.com/documents/BS_Contact_VRML_june2006.pdf

- Maybe you can solve this with an overloaded assignment operator between gboolean and boolean?
  Good idea, try a patch ad submit.

- Instead of ViewerChanged and IsLast..., it would be more natural and easier
  to keep Camera reference in TVRMLScene.
  This could ease some integration between TVRMLScene, TVRMLGLScene and viewer.

- There remains problem with EditableTransform behavior on shadow_map_test.x3dv:
  Activate (click over) and press "e" over any shadow receiver.
  This will cause change of transformation, but the bad one (because the light source is inside), so will cause ChangedAll.
  This means that octree will be freed and we'll reset active sensor info by PointingDeviceClear.
  This means that TouchSensor will not generate isActive := false, so script will hold isActive = true.
  Further keypress "e" (without clicking any sensor!) will activate move on this sensor (since it's still considered "active" by the script).

  This is a result of various problems:
  - we do not have a queue of events, otherwise we could call proper SetPointingDeviceActive(false) and PointingDeviceMove(nil) for later. Although this would stil be risky --- there is a reason why we call PointingDeviceClear, to have a clear way without any possible complications and callbacks.
  - calling ChangedAll when just the transform over the light changed is bad anyway. Octrees, in particular, do not have to be rebuild at all, so actually there should be no need for PointingDeviceClear at this point...

TGLTextureStorage
    (2D - just a single GLuint for GL_TEXTURE_2D,
    video - TVideo, sequence of GLuint for GL_TEXTURE_2D,
    cube - ...
    3D - ...
    depth)
  TGLTextureNode can choose any TGLTextureStorage (maybe at runtime) as storage
  Possibly helpful for DDS mipmaps/compression impl?
  This would mean TGLTextureStorage is in GLImages, not only for VRMLOpenGLRenderer.

- multitex:
  - remaining MultiTexture.mode ("MODULATE*_ADD*"),
  - MultiTexture.function field

Because of caching AlphaChannelType inside renderer, and using Renderer.PreparedTextureAlphaChannelType for calculating UseBlending, this means that if the same tex filename occurs in various ImageTexture nodes, and in one case we force it to have alpha different the auto-detection says (e.g. using alphaChannel "FULL_RANGE" to force full range on texture without alpha channel), then all texture occurences have the same alpha channel treatment. (alphaChannel field doesn't work correctly).

sk±d kreski na water w water_reflections_normalmap (both nvidia and radeon show this). Any relation to steep parallax mapping aliasing?

Unify texture coord generation for primitives and other shapes.
The idea is that I would like to
- apply texture coords per-unit on primitives too (currently their coords don't work with multitexturing)
- have texCoord that allows TextureCoordinateGeneration nodes for all primitives! (very useful when you want e.g. to make cube map mirror, or shadow maps, on primitives... currenly you're forced to make IndexedFaceSet representing box just for this.)

ImageGLInternalFormat should use symbolic names, not numbers!
(Check, since which OpenGL version?)

Shadow maps implementation rest:
- PROJECTION texture mapping disables displays lists, which seriously limits this technique... Fix. Use VBOs to make things fast even without disp lists. Move texture coord generation out of the display list.

(I think I'll make some extentions to NavigationInfo to control the amount of head-bobbing; but I'm getting off-topic..).

Dynamically changing camera radius may be implemented (along with decreasing camerapreferredheight, decrease cam radius?)

OpenEXR notes:
http://http.developer.nvidia.com/GPUGems/gpugems_ch26.html

- why on cubemap_generated_recursive.x3dv the reflections between two cubes
  have some pink color left when cube faces are exactly opposite each other?
  See TODO in cubemap_generated_recursive.x3dv

Zaimplementuj streaming dla OggVorbis.

There are still some rough situations when camera "shakes" when going around the corners with wall-sliding on castle_hall. Seems wall-sliding is done, but with somewhat bad direction?

- dyn ao:
  - use float textures
  - add to make easily usable from the engine?

- when capturing screenshots/movies in batch mode, use FBO

- add params to primitives to be able to change their texCoord, even creaseAngle
  (it's stupid that right now I have to write PROTOs with IndexedFaceSet to make them, in the worst case engine should do this automatically)

S3TC:
- (minor) image_identify cannot display info about S3TC compressed images
- (minor) glViewImage can open s3tc compressed images, but it cannot be the 1st image on command-line (since opengl context is not ready then yet, so no decompressor initialized)

- Maybe make an option to make the GeneratedCubeMapTexture (and RenderedTexture?) grayscale? Useful since default tex mapping in VRML standard says that only grayscale should modulate, RGB should decal. And sometimes grayscale only modulated by tex color may look just better?
  Hm, for RenderedTexture it's already in the spec: dimensions field has "components" number, default 4, but (I guess) may be 1,2,3 as well.
------------------------------------------------------------------------------
octree todos moved for after view3dscene 3.2:
- remaining TODOs about octrees:
  - vrmlshapeoctree.pas: we make box from sphere, and transform the box

  - vrmlscene.pas:
    There is still rebuilding with OctreeDynamicCollisions (it just happens
    on much smaller sets). Implement actual updating.

- also now the first octree update during CollisionCheck = false doesn't release the octree
  hm, that's actually somewhat good, as previous approach with "first octree update releases octree" was a little confusing for users (although it was for efficiency)

- some programs using currently okDynamicCollisions could be happy enough with okCollidableTriangles (malfunction, lets_take_a_walk, grep for rest). For now, keep using okDynamicCollisions, to compare speed eventually (okDynamicCollisions should be as well fast), maybe in the future drop to okCollidableTriangles?

  hm, not necessarily, on castle ssDynamicCollisions is slightly faster, except at the end of "cages" level. profile this particular case?

  finish castle testing and allow ssDynamicCollisions there for good?

- can we somehow fix precalculated anims now too for collisions?
  fix view3dscene docs then,

- add fields to make object->object and object->avatar collisions work somehow.
  (Right now, only avatar->object collisions are done.)

------------------------------------------------------------------------------
- Automatically detect when roSeparateShapeStates / ...NoTransform / roNone is suitable.
  Actually, optimization should be per-shape choice now?
  Except roSceneAsAWhole, that would override it?

- TVRMLScene.Shapes tree, with switches/lods approach,
  may be also used to efficiently implement layers now.

- http://www.libpng.org/pub/png/pngvrml.html finish:
  with RGB Textures Color Mode->GL_REPLACE
  Still missing:
  - on palette opaque: PNGs with grayscale palette are not detected as grayscale (so do not blend with mat color)
  - on 8bit opaque: JPG is not detected as grayscale (can jpg be grayscale?)
  - pallette translucent:
    again not palette PNG detected as grayscale, so are not mixed with color
    GIF with gray palette not detected properly, why fully transparent?
  - 8bit translucent:
    again JPG is not detected as grayscale (can jpg be grayscale?)
    grayscale + transparent shade again fully transparent, don't know why?
  - 16bit translucent:
    again grayscale + transparent shade again fully transparent, don't know why?

- Make TGLApplication TCustomApplication one day?
------------------------------------------------------------------------------
large TODOs:
- First of all, I planned to make a new game at the beginning of next year, with draft title "human programming"

- Plane mirror support in OpenGL for Material.mirror field (porting to
general renderer the code from
kambi_vrml_game_engine/examples/plane_mirror_and_shadow)

- Simple networking (support for http:// and such in view3dscene)

- Scripting in JavaScript (using spidermonkey after fixing
http://delphi.mozdev.org/ for recent fpc)

- And then physics engine and X3D rigid body component
- And then particle engine
------------------------------------------------------------------------------
- shadows for VRML browsers finish:
  - allow multiple lights. This requires
    adding light contributions, so using blending --- this was problematic
    when shadow receivers could use blending themselves. Now it'll
    not be a problem.

  - patch for laz to get StencilBits there. (notice de-panther)

  - ForceZFarInfinity - implement it also for ortho there.

  - VRML browser shadows don't actually do SV culling, since there's only one scene.
    We should make SV culling on shape level too, settable by some option?
    Hm, but not really possible with current impl --- we take all edges,
    from the whole scene, so we lost the separation into triangles.
    (OTOH, whole scene must be manifold, not necessarily one shape).
------------------------------------------------------------------------------
- prt: implement on shaders? this way roNone not needed, also special radianceTransfer field support not needed. Shaders vertex attrib nodes will have to be supported.
       make this easily usable by VRML authors, that is make it's rendering more integrated and available also from e.g. view3dscene

- x3d/light_transform_animated.x3dv fix, along with fix in vrmlscene.pas about lights there

- remake quat unit on Matrix vectors (with overloaded operators would be fun)

------------------------------------------------------------------------------
Ah yes. So the CPU is used (it's not that mem is leaking). I looked at view3dscene, and yes it will constantly use CPU since it continously increases the time (for animations). The same happens with VRML browser components (based on LCL or TGLWindow, doesn't matter). Even if there's no time-dependent sensor active.

I'll think about fixing this. It's not so easy --- without constantly working OnIdle, I'll have to update time in many places. Most importantly for scenes with existing but inactive time-dependent nodes (and this is the most common case for practical scenes), I'll have to predict when they can become active and set timer to then.

Hm, not so difficult, but this is something for later. For now we will have to live with constant CPU use. In most non-trivial scenes, there's almost always some animation going on, so CPU power will be eaten anyway --- so, while this should be fixed for VRML browsers, it's not a problem for actual games (I think).

------------------------------------------------------------------------------
after view3dscene 3.0:

For now, ProcessEvents is always @true when scenes count = 1 in view3dscene. Provide a way to turn it off? hm, implement when more sensors are avail. For now, you can pause the anim to turn off WorldTime... Maybe merge it? To also turn ProcessEvents off where applicable?

display lists optimization may be wasted even without calling GeometryChanged
often (for example, constantly changing material may force it),
this has to be detected then inside TVRMLGLScene.
When some shape is changed too often, switch to roNone for it.
(When it's changed often but only with TransformOnly, switch to roSeparateShapesNoTransform for it!)

fix extensions to all be gracefully declared by EXTERNPROTO, post to Joerg from white_dune

implement carefully rest of TimeSensor from spec. Now we have X3DTimeDependentNode subset, enabled, time, and (with probably too simple implementation) set_fraction event.

StringSensor.
Make it possible then to load new image file in kambi_script_edit_texture.x3dv

------------------------------------------------------------------------------
MatrixTransform fix:

Joerg:

To decompose to translation / rotation / scaling / shearing you can use
unmatrix.c from graphics gems.
What is impossible, is to reconstruct Transform.center and
Transform.scaleOrientation from a matrix 8-(

Michalis:

Agreed, it's possible (when matrix is reversible at all; but then even normal Transform node can be non-reversible with scaling to 0 in some dimension). I found the http://tog.acm.org/GraphicsGems/gemsii/unmatrix.c source, thanks, I'll try to understand it and plug into my engine. It'll be useful for some cases, when now I use dummy algorithms that can only extract scaling and split into rotation/translation rigid body transformation.

------------------------------------------------------------------------------
Things for much later:
- some things, like InsidePrototype, should actually be now properties
  of the whole stack (not state). This is good, even excellent --- smaller
  state means less copying, and this is what we wanted.

  Hm, but this means that copying target should be some descendant
  of state (we want to have these InsidePrototype values in each copy).
  Copy target is just a snapshot of stack state --- stack will be now
  stack of states + some integers managing stack themselves.

  Too unimportant for now... It would be a very small optimization of
  memory and time. Most time spent on state copying is on dyn lights
  and transforms copying, saving 3 * sizeof(int) wouldn't help much.
  For now resigned.

  Hmmmmm, OTOH, moving Inside* to the stack properties will avoid
  making a changing the stack top item, thus preventing whole stack
  copy-on-demand... could be a good thing, if copy-on-demand would be
  done? (but it's not, right now, as was seen rather useless...).

  Postponed / half resigned.

- fix Intel Mesa crashes on domek,
  generally run full test (including screenshots) on domek and fix everything.

  For now all fixed on chantal with upstream mesa 7.2,
  and most fixed on domek. Some remaining issues on domek remain,
  see ~/sources/mesa/bug_arith_error.txt on domek,
  postponed for later (let's see how they handle reported GL_POINT_BIT bug first).

- make doc without protected stuff?
  Decide when really nice docs are made.

------------------------------------------------------------------------------
- check does kambi_lines work on Windows in ii 107 now.
