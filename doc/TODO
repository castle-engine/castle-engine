The central TODO file. There are also some TODOs scattered elsewhere,
do "find -iname TODO*" to find them.
In paricular, ../../www/TODO contains "next-release" stuff,
usually has a list of blockers typically worked upon right before release.

------------------------------------------------------------------------------
- castle 1.0.0 blockers:
  - same plane walls on doom e1m1 level:
    - at the first door
    - right when opening the secret (lighter) door
    (exist also in srcs before TLevelObject - T3D transition, so this isn't any bug from this.)

------------------------------------------------------------------------------
Scene manager / controls / better Lazarus integration:

(not blockers before 2.0 release) --------------------------------------------

* TODO at TKamAbstractViewport.Camera: allow one camera instance be shared
  by a couple of viewports/scene manager. Also fix multiple_viewports then.

- Also use TButton in terrain to place "open image" near the slider?

- For later, something like KeyPreview for viewport would be useful
  to split-screen games, to catch keys (but not mouse clicks) regardless
  of mouse position (to handle keys from both players at once, assuming
  not conflicting). So, actually (since TKamViewport will decide about it,
  and TCamera.PositionInside is ignored), TKamViewport.KeyPreview is needed.
  Maybe just make TUIControl.KeyPreview property?

  Note: normal handling of keys in OnKeyDown would not be enough here,
  since keys could be catched earlier by any TUIControl?

  Maybe TUIControl.KeyPreview simply changes KeyDown/Up interpretation:
  when KeyPreview = true, then control gets key events regardless of mouse
  positions. This is trivial to implement and should be enough?

- Make XML .x3d format, loaded to any T3D (list, translated, anim, scene...)
  Make Load3D, loading this.
  Rename Object3dAsVRML to load3d unit.
  Hmm, not really --- Load3D will be only for OpenGL, as it will create
    already TVRMLGLScene / TVRMLGLAnimation etc.

- maybe T3DCustomTranslated derive from T3DList, and call "inherited" instead of relying on Child.

- animating Background in kanim doesn't work out of the box,
  since TKamSceneManager looks at MainScene.Background by default.
  Concerns kambi_vrml_test_suite/kanim/background_color_animation.kanim,
  probably also kambi_vrml_test_suite/kanim/slow_background_animation.kanim
  (but didn't get to finishing loading slow_background_animation.kanim),
  viewed e.g. in view3dscene (but probably everywhere with scene manager).

  Overriding Background is possible, this works:

    if (Items.List.Count <> 0) and
       (Items.List[0] is TVRMLGLAnimation) then
      Result := TVRMLGLAnimation(Items.List[0]).CurrentScene.Background else

  Make this better? Or just ignore? Animating Background by kanim
  wasn't ever really a good idea.

- some more free notifications could be useful:
  - FreeAndNil(FMouseRayHit) when it's triangle is destroyed (e.g. octree rebuild)
    or any 3d object along the path is removed from the Items hierarchy
    (not necessarily destroyed!).

    For now, this isn't a problem, because
    1. nothing uses FMouseRayHit.Triangle afterwards
       (only TVRMLScene.MouseMove uses it, but this is immediately after
       RayCollision was done).
    2. Some stuff 3D objects are removed from the scene manager at the end
       (try e.g. mouse over touch sensor in touch_sensor_test in view3dscene,
       then ctrl+w). We know we only use ItemsAndCameraCursorChange,
       we just track free notification of FMouseRayHit3D.
       (instead of all on MouseRayHit.Hierarchy.)

  - TWalkCamera.AboveGround should be freed when triangle is destroyed.

- Should we allow placing TCamera directly on TGLUIWindow / TKamOpenGLControls?
  IOW, should TCamera remain TUIControl descendant?

  Yes: because in 99% you want to use TKamSceneManager.Camera.
  - The scene manager offers instant integration of view with camera
    (with viewpoints, proximity sensors, glLoadMatrix(Camera.Matrix)
    is automatically done for you, and RenderState.Camera* are updated correctly).
  - You should not place camera on both TKamSceneManager.Camera and
    some Glw.Controls (Idle and some other events would get twice, making
    weird things --- at least 2x faster rotations for Examine).
    Being able to do it currently may be confusing.
  - Also, camera PositionInside is the poor hack with returning always @true.
    For scene manager, we will nicely improve this with TKamViewport,
    that will take defined space and pass events to it's camera.
    For pure TCamera on Glw.Controls, this will not be done.

  No: despite all above, we have remaining some camera uses in engine
  examples where scene manager really adds nothing. Yes, scene manager
  is fantastic and simplified 99% of examples...
  but there's no point forcing it for remaining 1%,
  where it really doesn't add anything?

  This concerns stuff without VRML/X3D at all (so the lack of proximity,
  render state integration etc. doesn't matter there, and
  glLoadMatrix(Camera.Matrix) may as well be done directly).

  Below is extracted from
  grep_pas_src . 'glLoadMatrix(.*camera.matrix)'

  rift:
    ../../rift/riftplay.pas:141:  glLoadMatrix(SceneCamera.Matrix);
  pure OpenGL demos (no VRML code), possibly let them use Glw.Camera?
    For direct_vrmlglscene_xxx, it's even by design (this shows that without
    scenemanager you can also work):
    ../examples/vrml/direct_vrmlglscene_test_1.pasprogram:58:  glLoadMatrix(Camera.Matrix);
    ../examples/vrml/direct_vrmlglscene_test_2.pasprogram:76:  glLoadMatrix(Camera.Matrix);
    ../examples/vrml/terrain/terrain.pasprogram:200:  glLoadMatrix(Camera.Matrix);
    ../examples/glwindow/bezier_surfaces/animate_surface.pasprogram:95:  glLoadMatrix(Camera.Matrix);
    ../examples/glwindow/bezier_surfaces/design_surface.pasprogram:202:  glLoadMatrix(Camera.Matrix);

  If TCamera removed from TUIControl, maybe make some common class,
  like TInputListener, for TUIControl, TCamera, TBase3D.
  Or at least for TUIControl, TCamera.
  Maybe TInvisibleUIControl, or TCustomUIControl?

- TVRMLGLLightSet - hm, it would be useful to eliminate need to use this
  e.g. in castle. Can SceneManager help us here? Ideally, a way to allow
  all the vrml scenes to mix their OpenGL lights could be great?

  Hm, not really, not yet.
  We would like to easily allow VRML lights (with global=TRUE,
  this will be following VRML idea) to be shared, but this requires dynamic
  OpenGL light allocation (not governed by Scene.Attributes.First/Last).
  But this means not storing lights in display lists (as VRML lights may
  always change) and this means dropping optimizations (only roNone,
  roSeparateShapesNoTransform may be left), which generally waits for
  remaking rendering to full VBO.

  For now we would have to just allow MainScene to take all the lights and leave
  them set for other scenes. Hm, actually sensible...

- castle: besides level (MainScene, and level objects as additional stuff),
  it would be most perfect if castle creatures / items would be part of
  SceneManager too.

* Should TSceneManager be free from VRML specifics?

  - Yes-> Can be moved to 3d/ or ui/.

    Advantage: TGLUIWindow/TKamOpenGLControl could then create
    and automatically add SceneManager to Controls.
    This would simplify some stuff, since in new engine (almost)
    everything will use SceneManager.
    Also, since SceneManager will set MainScene.GLProjection in
    ContainerResize, there can be only one SceneManager used at one time.

  - Counterargument for auto-initialization of SceneManager:

    - Some programs want their own TKamSceneManager descendant.
    - Some programs may have > 1 SceneManager, if they will have
      non-default viewports, and both 3d worlds will be separate.

    So it's not true that there's always 1 instance of TKamSceneManager.

    Although this doesn't rule out the possibility to create SceneManager
    by default? We could always create default scenemanager on demand
    (when first calling SceneManager?), and allow to change it anyway
    by assigning to TGLUIWindow.SceneManager property.

    But this is unclean, making unclear what happens with Controls?
    This has the same conceptual problem as with TGLUIWindow.Camera?

  - Counterargument: TSceneManager.MainScene must point to
    VRML-enabled:TVRMLScene.

    Unless we make TVRMLSceneManager? Then general TSceneManager
    will not be dependent on VRML.
    Or design TBase3D intelligently, maybe there
    will not be need for any TVRMLGLSCene-specific stuff in current
    TSceneManager.

  Overall, this is quite a large rearrangement for TSceneManager,
  just to avoid dependencies... Moreover, note that for now Base3D
  is also dependent on VRML (since it uses VRMLTriangle types, to filter
  out items for collision detection etc.). This would have to be resolved
  first.

* Let RenderState use some Camera reference, maybe make TSimpleCamera to avoid
  overloading it with full camera props for temporary camera settings?

* Lazarus: make the control painted at design-time?

* Maybe make a news item and a few screenshots how to easily use it from Lazarus?

- Make TKamOpenGLControl.Controls list settable from the IDE,
  to allow visually adding new TUIControls there.

  At designtime, warn on error: do not put > 1 camera in Controls list,
  while it works it's usually nonsense.
  Or not: shadow_volume_test shows that it's possible to have two cameras,
  and things work smoothly. You just have to assign non-conflicting keys.

  Started in kambipropsedit. Need to figure out and debug how to
  correctly deal with TListPropertyEditor, or eventually write your
  own property editor for this.

- Make sure most useful props of our controls are settable:

  For TGLMenu, browse and decide which ones (Items?).

  TVRMLScene.CompiledScriptHandlers (will require some designer to settable from IDE)
  TVRMLGLAnimation.FileName, implement similar to TVRMLScene.FileName.

  For cameras generally, what Init method takes should be settable.
  For cameras generally, Input_Xxx properties.
  TWalkCamera: CameraInitialPos/Dir/Up (how are settable from IDE?)
  TExamineCamera: ModelBox (how are settable from IDE?)
  Gravity, CameraRadius, CameraPreferredHeight, OnMoveAllowed, OnGetCameraHeight?

- make icons for our components.
  Same style cameras (black with dotted lines):
    Walking man icon for TWalkCamera,
    Rotated box for TExamineCamera.
  Same style areas:
    TKamOpenGLControl
    TKamVRMLBrowser (maybe use the same image, with just a text "OpenGL" or "GL"
      on one, "VRML" on other)
  Needed ideas for TGLMenu.
  For TKamXMLConfig use some slightly modified icon of TXMLConfig, since this is almost the same?
  For TKamRecentFiles use some slightly modified icon of TMainMenu or TPopupMenu.

* TVRMLScene (no GL) on a Lazarus palette? Confusing with TVRMLGLScene, but is also useful.
------------------------------------------------------------------------------
For view3dscene 3.6:
- implement more pointing device sensors
- basic networking support
(I want to have full coverage of X3D "Interactive" with 3.6 release),
fix Victor Amat problems with touch sensor picking along the way.

------------------------------------------------------------------------------
For view3dscene 4.0:
JavaScript, or Python/Lua?

------------------------------------------------------------------------------
Various ideas:

* something animated for shadow_volume_test caster, receiver.
  Should be easy now with scene manager, that allows models to be animated.

* make http://freewrl.sourceforge.net/images/flutter.x3d
  read: handle data:text/plain for shader source.

- view3dscene: edit->add viewport here command (asks for viewport name to put in description),
  adds viewport to menu,
  this viewport will be saved to file

- display column / line numbers in vrml lexer errors.
  (Not so difficult if we assume it works only for Windows/Unix, because scans only for #10. Make it as an optional (boolean property) for reader. Measure downtime, maybe enable by default for vrml lexer?)

* NavigationInfo binding and changes treat better.
  - E.g. NavigationInfoStack.OnBoundChanged should cause appropriate change
  - camera's Move*Speed user-preference (should always start at 1.0)
    should be separated from speed determines from VRML NavigationInfo.speed.
    This will clean things up.

* glwinmessages scrollbars:
  http://www.useit.com/alertbox/20050711.html

* Future: TAnyCamera in the future (when I'll figure out how to switch cam pos/dir/up to examine props), with Examine, Walk, None variants.

- Maybe more improvements along the vrml_implementation_status.php division:
  - #section_x3d_multitex_clarifications - move to "texturing" component page?
  - NIST VRML tests move to separate?
  - DDS support move to separate?

- Joerg pointed out possible problem with quads for NurbsSurface*:

  Ah, I understand now, and that's also why the problem is visible with
  symmetric surfaces... Thanks, will do some testing, maybe eventually
  I'll add a field to IndexedQuadSet like tesselateIntelligently:SFBool to
  force tesselating quads into 2 tris by intelligently choosing a dividing
  edge (to make it shortest). This would force correct look of all
  IndexedQuadSet, including NurbsPatchSurface.

- on kocury win 2000 prof with Geforce 5200, FBO config is never supported.
  While on Linux (32, 64) it's Ok.
  Why? Driver buggy? Test can we get FBO under *any* windows system?

- Only on x86_64: GLU tesselatator is ultra-slow.

  So loading anything with a 3D Font takes some time (around 4-5 seconds per font; while it's instanteneous on 32bit). 3D Font is right now used only by VRML Text node, no program initializes TGLOutlineFont directly.

  The slowness can be seen e.g. in castle when loading ("credits" model has 3D fonts). Or in view3dscene when opening any file using font, like x3d/cubemap_generated_in_dynamic_world.x3dv. Extreme case is kambi_vrml_test_suite/vrml_2/text.wrl: all 9 fonts used, loading time is 37 seconds.

  This is also a blocker for making "welcome scene" in view3dscene using Text font.

  The slowness is in Cache.Fonts_IncReference.
  Not reproducible on 32 bit (fpc 2.2.4 kocury/linux/32), so it must be some 64-bit problem.
  The slowness is inside gluTessVertex in TGLOutlineFont.Create. Which means I cannot do anything about it? It's the GLU tesselators that are much slower on x86_64, it seems.

  One solution could be to cache the tesselated result. I could even compile the cached result into the program, this way user doesn't have to do it at all.
  Trouble: is it really helpful in the long run? I would like some time to load fonts from TTF files and then runtime tesselation is a must. And then caching helps, but not for the 1st tesselation run...

  Idea: not tesselating all letters would be useful?
  This would be a valid optimization (needed in the long run anyway, for Unicode fonts I wouldn't want to tesselate all characters at loading anyway).
  For now, possibly I would just need basic ASCII support, so not all 256 characters need to be defined?
  Done: we use only a subset: SimpleAsciiCharacters. 4-5 and 37 seconds measures are with this already enabled... so it's working, but it's still slow.

  For view3dscene 3.4, this will have to be enough.

- fix vrmlengine for seamless avatars - or is it javascript lack?

- view3dscene: rest of nurbs:
  finish X3D nurbs component up to level 2, update vrml_impl_status about it.
  Remaining:
    CoordinateDouble
    NurbsTextureCoordinate
    NurbsSet

------------------------------------------------------------------------------
Effects, techniques, passes:
- victor amat
  http://http.developer.nvidia.com/CgTutorial/cg_tutorial_appendix_c.html,
- dane osowskiego i OGRE,
- tak¿e http://http.developer.nvidia.com/GPUGems/gpugems_ch36.html chyba wszyscy o tym wspominaj±...

------------------------------------------------------------------------------
Occlusion culling (Ok for post 3.4):

- make RenderState.StenilTest be used also to pause (not update visibility) in hierarch oq, it would be a waste of temporal conh to not pause there.

- if tests show hierarchical is much better than UseOcclusionQuery,
  old UseOcclusionQuery may be removed (and this may be renamed
  to just UseOcclusionQuery). (Or keep old UseOcclusionQuery only
  for seminar.)

- make nicer interaction OctreeFrustumCulling (use it for frustum checks in
  UseHierarchicalOcclusionQuery).
  And with RenderFrustum_Frustum^, right now we just take it.

- UseHierarchicalOcclusionQuery ignores blending for now.

- this strange thing on bzwgen level, that always shown yellow block, although it should be normally visible afterwards. What's with it? Fixed now?
  No, it still exists.

- tree may be very very poor for shapes. E.g. atcs. This also makes hierarch culling perform badly.
  Hmm, I see why the octree has a lot of duplication on regular_labirynth, although how to improve? Possibly some bottom-to-top scan that turns off octree planes where all children are the same?
  For now, I can add dummy box to the regular_labirynth to force octree be correct.
  For atcs, how to fix?

- Various rendering targets, and "inshadow" for stencil, should just have a separate occlusion query state. This will allow to use oq for all situations, unlike current where oq is done normally only for non-shadowed with target = rtScreen.
  See TODO in vrmlglscene.pas about this too.

------------------------------------------------------------------------------
moved post 3.4:

- multitex:
  - fix for normal primitives: set all texture coords equal.

Victor Amat list (overlapping with mine, so let's go with it):
  - passing vertex attributes to shaders

  - Note that to use it, you would also need to know the current screen
    size, how about adding outputOnly events to X3DViewpointNode that return
    screenWidth, screenHeight as SFInt32?

    Hm, bs contact has "eventOut SFVec2f windowSize", although I don't know on wha node.
    http://www.bitmanagement.com/documents/BS_Contact_VRML_june2006.pdf

- Maybe you can solve this with an overloaded assignment operator between gboolean and boolean?
  Good idea, try a patch ad submit.

- Instead of ViewerChanged and IsLast..., it would be more natural and easier
  to keep Camera reference in TVRMLScene.
  This could ease some integration between TVRMLScene, TVRMLGLScene and viewer.

- There remains problem with EditableTransform behavior on shadow_map_test.x3dv:
  Activate (click over) and press "e" over any shadow receiver.
  This will cause change of transformation, but the bad one (because the light source is inside), so will cause ChangedAll.
  This means that octree will be freed and we'll reset active sensor info by PointingDeviceClear.
  This means that TouchSensor will not generate isActive := false, so script will hold isActive = true.
  Further keypress "e" (without clicking any sensor!) will activate move on this sensor (since it's still considered "active" by the script).

  This is a result of various problems:
  - we do not have a queue of events, otherwise we could call proper SetPointingDeviceActive(false) and PointingDeviceMove(nil) for later. Although this would stil be risky --- there is a reason why we call PointingDeviceClear, to have a clear way without any possible complications and callbacks.
  - calling ChangedAll when just the transform over the light changed is bad anyway. Octrees, in particular, do not have to be rebuild at all, so actually there should be no need for PointingDeviceClear at this point...

TGLTextureStorage
    (2D - just a single GLuint for GL_TEXTURE_2D,
    video - TVideo, sequence of GLuint for GL_TEXTURE_2D,
    cube - ...
    3D - ...
    depth)
  TGLTextureNode can choose any TGLTextureStorage (maybe at runtime) as storage
  Possibly helpful for DDS mipmaps/compression impl?
  This would mean TGLTextureStorage is in GLImages, not only for VRMLOpenGLRenderer.

- multitex:
  - remaining MultiTexture.mode ("MODULATE*_ADD*"),
  - MultiTexture.function field

Because of caching AlphaChannelType inside renderer, and using Renderer.PreparedTextureAlphaChannelType for calculating UseBlending, this means that if the same tex filename occurs in various ImageTexture nodes, and in one case we force it to have alpha different the auto-detection says (e.g. using alphaChannel "FULL_RANGE" to force full range on texture without alpha channel), then all texture occurences have the same alpha channel treatment. (alphaChannel field doesn't work correctly).

sk±d kreski na water w water_reflections_normalmap (both nvidia and radeon show this). Any relation to steep parallax mapping aliasing?

Unify texture coord generation for primitives and other shapes.
The idea is that I would like to
- apply texture coords per-unit on primitives too (currently their coords don't work with multitexturing)
- have texCoord that allows TextureCoordinateGeneration nodes for all primitives! (very useful when you want e.g. to make cube map mirror, or shadow maps, on primitives... currenly you're forced to make IndexedFaceSet representing box just for this.)

ImageGLInternalFormat should use symbolic names, not numbers!
(Check, since which OpenGL version?)

Shadow maps implementation rest:
- PROJECTION texture mapping disables displays lists, which seriously limits this technique... Fix. Use VBOs to make things fast even without disp lists. Move texture coord generation out of the display list.

(I think I'll make some extentions to NavigationInfo to control the amount of head-bobbing; but I'm getting off-topic..).

Dynamically changing camera radius may be implemented (along with decreasing camerapreferredheight, decrease cam radius?)

OpenEXR notes:
http://http.developer.nvidia.com/GPUGems/gpugems_ch26.html

- why on cubemap_generated_recursive.x3dv the reflections between two cubes
  have some pink color left when cube faces are exactly opposite each other?
  See TODO in cubemap_generated_recursive.x3dv

Zaimplementuj streaming dla OggVorbis.

There are still some rough situations when camera "shakes" when going around the corners with wall-sliding on castle_hall. Seems wall-sliding is done, but with somewhat bad direction?

- dyn ao:
  - use float textures
  - add to make easily usable from the engine?

- when capturing screenshots/movies in batch mode, use FBO

- add params to primitives to be able to change their texCoord, even creaseAngle
  (it's stupid that right now I have to write PROTOs with IndexedFaceSet to make them, in the worst case engine should do this automatically)

S3TC:
- (minor) image_identify cannot display info about S3TC compressed images
- (minor) glViewImage can open s3tc compressed images, but it cannot be the 1st image on command-line (since opengl context is not ready then yet, so no decompressor initialized)

- Maybe make an option to make the GeneratedCubeMapTexture (and RenderedTexture?) grayscale? Useful since default tex mapping in VRML standard says that only grayscale should modulate, RGB should decal. And sometimes grayscale only modulated by tex color may look just better?
  Hm, for RenderedTexture it's already in the spec: dimensions field has "components" number, default 4, but (I guess) may be 1,2,3 as well.
------------------------------------------------------------------------------
octree todos moved for after view3dscene 3.2:
- remaining TODOs about octrees:
  - vrmlshapeoctree.pas: we make box from sphere, and transform the box

  - vrmlscene.pas:
    There is still rebuilding with OctreeDynamicCollisions (it just happens
    on much smaller sets). Implement actual updating.

- also now the first octree update during CollisionCheck = false doesn't release the octree
  hm, that's actually somewhat good, as previous approach with "first octree update releases octree" was a little confusing for users (although it was for efficiency)

- some programs using currently okDynamicCollisions could be happy enough with okCollidableTriangles (malfunction, lets_take_a_walk, grep for rest). For now, keep using okDynamicCollisions, to compare speed eventually (okDynamicCollisions should be as well fast), maybe in the future drop to okCollidableTriangles?

  hm, not necessarily, on castle ssDynamicCollisions is slightly faster, except at the end of "cages" level. profile this particular case?

  finish castle testing and allow ssDynamicCollisions there for good?

- can we somehow fix precalculated anims now too for collisions?
  fix view3dscene docs then,

- add fields to make object->object and object->avatar collisions work somehow.
  (Right now, only avatar->object collisions are done.)

------------------------------------------------------------------------------
- Automatically detect when roSeparateShapeStates / ...NoTransform / roNone is suitable.
  Actually, optimization should be per-shape choice now?
  Except roSceneAsAWhole, that would override it?

- TVRMLScene.Shapes tree, with switches/lods approach,
  may be also used to efficiently implement layers now.

- http://www.libpng.org/pub/png/pngvrml.html finish:
  with RGB Textures Color Mode->GL_REPLACE
  Still missing:
  - on palette opaque: PNGs with grayscale palette are not detected as grayscale (so do not blend with mat color)
  - on 8bit opaque: JPG is not detected as grayscale (can jpg be grayscale?)
  - pallette translucent:
    again not palette PNG detected as grayscale, so are not mixed with color
    GIF with gray palette not detected properly, why fully transparent?
  - 8bit translucent:
    again JPG is not detected as grayscale (can jpg be grayscale?)
    grayscale + transparent shade again fully transparent, don't know why?
  - 16bit translucent:
    again grayscale + transparent shade again fully transparent, don't know why?

- Make TGLApplication TCustomApplication one day?
------------------------------------------------------------------------------
large TODOs:
- First of all, I planned to make a new game at the beginning of next year, with draft title "human programming"

- Plane mirror support in OpenGL for Material.mirror field (porting to
general renderer the code from
kambi_vrml_game_engine/examples/plane_mirror_and_shadow)

- Simple networking (support for http:// and such in view3dscene)

- Scripting in JavaScript (using spidermonkey after fixing
http://delphi.mozdev.org/ for recent fpc)

- And then physics engine and X3D rigid body component
- And then particle engine
------------------------------------------------------------------------------
- shadows for VRML browsers finish:
  - allow multiple lights. This requires
    adding light contributions, so using blending --- this was problematic
    when shadow receivers could use blending themselves. Now it'll
    not be a problem.

  - patch for laz to get StencilBits there. (notice de-panther)

  - ForceZFarInfinity - implement it also for ortho there.

  - VRML browser shadows don't actually do SV culling, since there's only one scene.
    We should make SV culling on shape level too, settable by some option?
    Hm, but not really possible with current impl --- we take all edges,
    from the whole scene, so we lost the separation into triangles.
    (OTOH, whole scene must be manifold, not necessarily one shape).
------------------------------------------------------------------------------
- prt: implement on shaders? this way roNone not needed, also special radianceTransfer field support not needed. Shaders vertex attrib nodes will have to be supported.
       make this easily usable by VRML authors, that is make it's rendering more integrated and available also from e.g. view3dscene

- x3d/light_transform_animated.x3dv fix, along with fix in vrmlscene.pas about lights there

- remake quat unit on Matrix vectors (with overloaded operators would be fun)

------------------------------------------------------------------------------
Ah yes. So the CPU is used (it's not that mem is leaking). I looked at view3dscene, and yes it will constantly use CPU since it continously increases the time (for animations). The same happens with VRML browser components (based on LCL or TGLWindow, doesn't matter). Even if there's no time-dependent sensor active.

I'll think about fixing this. It's not so easy --- without constantly working OnIdle, I'll have to update time in many places. Most importantly for scenes with existing but inactive time-dependent nodes (and this is the most common case for practical scenes), I'll have to predict when they can become active and set timer to then.

Hm, not so difficult, but this is something for later. For now we will have to live with constant CPU use. In most non-trivial scenes, there's almost always some animation going on, so CPU power will be eaten anyway --- so, while this should be fixed for VRML browsers, it's not a problem for actual games (I think).

------------------------------------------------------------------------------
after view3dscene 3.0:

For now, ProcessEvents is always @true when scenes count = 1 in view3dscene. Provide a way to turn it off? hm, implement when more sensors are avail. For now, you can pause the anim to turn off WorldTime... Maybe merge it? To also turn ProcessEvents off where applicable?

display lists optimization may be wasted even without calling GeometryChanged
often (for example, constantly changing material may force it),
this has to be detected then inside TVRMLGLScene.
When some shape is changed too often, switch to roNone for it.
(When it's changed often but only with TransformOnly, switch to roSeparateShapesNoTransform for it!)

fix extensions to all be gracefully declared by EXTERNPROTO, post to Joerg from white_dune

implement carefully rest of TimeSensor from spec. Now we have X3DTimeDependentNode subset, enabled, time, and (with probably too simple implementation) set_fraction event.

StringSensor.
Make it possible then to load new image file in kambi_script_edit_texture.x3dv

------------------------------------------------------------------------------
MatrixTransform fix:

Joerg:

To decompose to translation / rotation / scaling / shearing you can use
unmatrix.c from graphics gems.
What is impossible, is to reconstruct Transform.center and
Transform.scaleOrientation from a matrix 8-(

Michalis:

Agreed, it's possible (when matrix is reversible at all; but then even normal Transform node can be non-reversible with scaling to 0 in some dimension). I found the http://tog.acm.org/GraphicsGems/gemsii/unmatrix.c source, thanks, I'll try to understand it and plug into my engine. It'll be useful for some cases, when now I use dummy algorithms that can only extract scaling and split into rotation/translation rigid body transformation.

------------------------------------------------------------------------------
Things for much later:
- some things, like InsidePrototype, should actually be now properties
  of the whole stack (not state). This is good, even excellent --- smaller
  state means less copying, and this is what we wanted.

  Hm, but this means that copying target should be some descendant
  of state (we want to have these InsidePrototype values in each copy).
  Copy target is just a snapshot of stack state --- stack will be now
  stack of states + some integers managing stack themselves.

  Too unimportant for now... It would be a very small optimization of
  memory and time. Most time spent on state copying is on dyn lights
  and transforms copying, saving 3 * sizeof(int) wouldn't help much.
  For now resigned.

  Hmmmmm, OTOH, moving Inside* to the stack properties will avoid
  making a changing the stack top item, thus preventing whole stack
  copy-on-demand... could be a good thing, if copy-on-demand would be
  done? (but it's not, right now, as was seen rather useless...).

  Postponed / half resigned.

- fix Intel Mesa crashes on domek,
  generally run full test (including screenshots) on domek and fix everything.

  For now all fixed on chantal with upstream mesa 7.2,
  and most fixed on domek. Some remaining issues on domek remain,
  see ~/sources/mesa/bug_arith_error.txt on domek,
  postponed for later (let's see how they handle reported GL_POINT_BIT bug first).

- make doc without protected stuff?
  Decide when really nice docs are made.

------------------------------------------------------------------------------
- check does kambi_lines work on Windows in ii 107 now.
