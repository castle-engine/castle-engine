{ -*- buffer-read-only: t -*-

  Copyright 2015-2025 Michalis Kamburelis.

  This file is part of "Castle Game Engine".

  "Castle Game Engine" is free software; see the file COPYING.txt,
  included in this distribution, for details about the copyright.

  "Castle Game Engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

  ----------------------------------------------------------------------------
}

{ Automatically generated node properties.

  Do not edit this file manually!
  To add new properties:
  - add them to the text files in tools/internal/x3d-nodes-to-pascal/nodes-specification/ ,
  - and regenerate include files by running x3d-nodes-to-pascal }

{$ifdef read_interface}

  strict private
    function GetDopplerEnabled: Boolean;
    procedure SetDopplerEnabled(const Value: Boolean);
    function GetInterauralDistance: Single;
    procedure SetInterauralDistance(const Value: Single);
    function GetOrientation: TVector4;
    procedure SetOrientation(const Value: TVector4);
    function GetPosition: TVector3;
    procedure SetPosition(const Value: TVector3);
    function GetTrackCurrentView: Boolean;
    procedure SetTrackCurrentView(const Value: Boolean);
  public
    { Create node fields and events. }
    procedure CreateNode; override;
    class function ClassX3DType: String; override;

    strict private FFdDopplerEnabled: TSFBool;
    { Internal wrapper for property @code(DopplerEnabled). This wrapper API may change, we advise to access simpler @code(DopplerEnabled) instead, if it is defined (TODO: for now, some field types do not have a simpler counterpart). }
    public property FdDopplerEnabled: TSFBool read FFdDopplerEnabled;
    {  }
    property DopplerEnabled: Boolean read GetDopplerEnabled write SetDopplerEnabled;

    strict private FFdInterauralDistance: TSFFloat;
    { Internal wrapper for property @code(InterauralDistance). This wrapper API may change, we advise to access simpler @code(InterauralDistance) instead, if it is defined (TODO: for now, some field types do not have a simpler counterpart). }
    public property FdInterauralDistance: TSFFloat read FFdInterauralDistance;
    {  }
    property InterauralDistance: Single read GetInterauralDistance write SetInterauralDistance;

    strict private FFdOrientation: TSFRotation;
    { Internal wrapper for property @code(Orientation). This wrapper API may change, we advise to access simpler @code(Orientation) instead, if it is defined (TODO: for now, some field types do not have a simpler counterpart). }
    public property FdOrientation: TSFRotation read FFdOrientation;
    {  }
    property Orientation: TVector4 read GetOrientation write SetOrientation;

    strict private FFdPosition: TSFVec3f;
    { Internal wrapper for property @code(Position). This wrapper API may change, we advise to access simpler @code(Position) instead, if it is defined (TODO: for now, some field types do not have a simpler counterpart). }
    public property FdPosition: TSFVec3f read FFdPosition;
    {  }
    property Position: TVector3 read GetPosition write SetPosition;

    strict private FFdTrackCurrentView: TSFBool;
    { Internal wrapper for property @code(TrackCurrentView). This wrapper API may change, we advise to access simpler @code(TrackCurrentView) instead, if it is defined (TODO: for now, some field types do not have a simpler counterpart). }
    public property FdTrackCurrentView: TSFBool read FFdTrackCurrentView;
    {  }
    property TrackCurrentView: Boolean read GetTrackCurrentView write SetTrackCurrentView;

{$endif read_interface}

{$ifdef read_implementation}

{ TListenerPointSourceNode ----------------------------------------------- }

function TListenerPointSourceNode.GetDopplerEnabled: Boolean;
begin
  Result := FdDopplerEnabled.Value;
end;

procedure TListenerPointSourceNode.SetDopplerEnabled(const Value: Boolean);
begin
  FdDopplerEnabled.Send(Value);
end;

function TListenerPointSourceNode.GetInterauralDistance: Single;
begin
  Result := FdInterauralDistance.Value;
end;

procedure TListenerPointSourceNode.SetInterauralDistance(const Value: Single);
begin
  FdInterauralDistance.Send(Value);
end;

function TListenerPointSourceNode.GetOrientation: TVector4;
begin
  Result := FdOrientation.Value;
end;

procedure TListenerPointSourceNode.SetOrientation(const Value: TVector4);
begin
  FdOrientation.Send(Value);
end;

function TListenerPointSourceNode.GetPosition: TVector3;
begin
  Result := FdPosition.Value;
end;

procedure TListenerPointSourceNode.SetPosition(const Value: TVector3);
begin
  FdPosition.Send(Value);
end;

function TListenerPointSourceNode.GetTrackCurrentView: Boolean;
begin
  Result := FdTrackCurrentView.Value;
end;

procedure TListenerPointSourceNode.SetTrackCurrentView(const Value: Boolean);
begin
  FdTrackCurrentView.Send(Value);
end;

class function TListenerPointSourceNode.ClassX3DType: String;
begin
  Result := 'ListenerPointSource';
end;

procedure TListenerPointSourceNode.CreateNode;
begin
  inherited;

  FFdDopplerEnabled := TSFBool.Create(Self, True, 'dopplerEnabled', false);
   FdDopplerEnabled.ChangeAlways := chVisibleNonGeometry;
  AddField(FFdDopplerEnabled);

  FFdInterauralDistance := TSFFloat.Create(Self, True, 'interauralDistance', 0);
   FdInterauralDistance.ChangeAlways := chVisibleNonGeometry;
  AddField(FFdInterauralDistance);

  FFdOrientation := TSFRotation.Create(Self, True, 'orientation', Vector3(0, 0, 1), 0);
   FdOrientation.ChangeAlways := chVisibleNonGeometry;
  AddField(FFdOrientation);

  FFdPosition := TSFVec3f.Create(Self, True, 'position', Vector3(0, 0, 0));
   FdPosition.ChangeAlways := chVisibleNonGeometry;
  AddField(FFdPosition);

  FFdTrackCurrentView := TSFBool.Create(Self, True, 'trackCurrentView', false);
   FdTrackCurrentView.ChangeAlways := chVisibleNonGeometry;
  AddField(FFdTrackCurrentView);
end;

{$endif read_implementation}
