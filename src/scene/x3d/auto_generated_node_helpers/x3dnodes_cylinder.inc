{ -*- buffer-read-only: t -*-

  Copyright 2015-2025 Michalis Kamburelis.

  This file is part of "Castle Game Engine".

  "Castle Game Engine" is free software; see the file COPYING.txt,
  included in this distribution, for details about the copyright.

  "Castle Game Engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

  ----------------------------------------------------------------------------
}

{ Automatically generated node properties.

  Do not edit this file manually!
  To add new properties:
  - add them to the text files in tools/internal/x3d-nodes-to-pascal/nodes-specification/ ,
  - and regenerate include files by running x3d-nodes-to-pascal }

{$ifdef read_interface}

  strict private
    function GetBottom: Boolean;
    procedure SetBottom(const Value: Boolean);
    function GetHeight: Single;
    procedure SetHeight(const Value: Single);
    function GetRadius: Single;
    procedure SetRadius(const Value: Single);
    function GetSide: Boolean;
    procedure SetSide(const Value: Boolean);
    function GetTop: Boolean;
    procedure SetTop(const Value: Boolean);
    function GetTexCoord: TX3DNode;
    procedure SetTexCoord(const Value: TX3DNode);
    function GetSlices: Integer;
    procedure SetSlices(const Value: Integer);
  public
    { Create node fields and events. }
    procedure CreateNode; override;
    class function ClassX3DType: String; override;

    strict private FFdBottom: TSFBool;
    { Internal wrapper for property @code(Bottom). This wrapper API may change, we advise to access simpler @code(Bottom) instead, if it is defined (TODO: for now, some field types do not have a simpler counterpart). }
    public property FdBottom: TSFBool read FFdBottom;
    {  }
    property Bottom: Boolean read GetBottom write SetBottom;

    strict private FFdHeight: TSFFloat;
    { Internal wrapper for property @code(Height). This wrapper API may change, we advise to access simpler @code(Height) instead, if it is defined (TODO: for now, some field types do not have a simpler counterpart). }
    public property FdHeight: TSFFloat read FFdHeight;
    {  }
    property Height: Single read GetHeight write SetHeight;

    strict private FFdRadius: TSFFloat;
    { Internal wrapper for property @code(Radius). This wrapper API may change, we advise to access simpler @code(Radius) instead, if it is defined (TODO: for now, some field types do not have a simpler counterpart). }
    public property FdRadius: TSFFloat read FFdRadius;
    {  }
    property Radius: Single read GetRadius write SetRadius;

    strict private FFdSide: TSFBool;
    { Internal wrapper for property @code(Side). This wrapper API may change, we advise to access simpler @code(Side) instead, if it is defined (TODO: for now, some field types do not have a simpler counterpart). }
    public property FdSide: TSFBool read FFdSide;
    {  }
    property Side: Boolean read GetSide write SetSide;

    strict private FFdSolid: TSFBool;
    { Internal wrapper for property @code(Solid). This wrapper API may change, we advise to access simpler @code(Solid) instead, if it is defined (TODO: for now, some field types do not have a simpler counterpart). }
    public property FdSolid: TSFBool read FFdSolid;

    strict private FFdTop: TSFBool;
    { Internal wrapper for property @code(Top). This wrapper API may change, we advise to access simpler @code(Top) instead, if it is defined (TODO: for now, some field types do not have a simpler counterpart). }
    public property FdTop: TSFBool read FFdTop;
    {  }
    property Top: Boolean read GetTop write SetTop;

    strict private FFdTexCoord: TSFNode;
    { Internal wrapper for property @code(TexCoord). This wrapper API may change, we advise to access simpler @code(TexCoord) instead, if it is defined (TODO: for now, some field types do not have a simpler counterpart). }
    public property FdTexCoord: TSFNode read FFdTexCoord;
    {  }
    property TexCoord: TX3DNode read GetTexCoord write SetTexCoord;

    strict private FFdSlices: TSFInt32;
    { Internal wrapper for property @code(Slices). This wrapper API may change, we advise to access simpler @code(Slices) instead, if it is defined (TODO: for now, some field types do not have a simpler counterpart). }
    public property FdSlices: TSFInt32 read FFdSlices;
    { How many "slices" to use to approximate the cylinder. The cylinder is rendered using polygons (triangles and quads) that approximate the cylinder shape. The more slices, the more the cylinder will look like a cylinder. Slices divide the objects like slices of a pizza. The default value of 0 means to follow global variable @link(DefaultTriangulationSlices). }
    property Slices: Integer read GetSlices write SetSlices;

{$endif read_interface}

{$ifdef read_implementation}

{ TCylinderNode ----------------------------------------------- }

function TCylinderNode.GetBottom: Boolean;
begin
  Result := FdBottom.Value;
end;

procedure TCylinderNode.SetBottom(const Value: Boolean);
begin
  FdBottom.Send(Value);
end;

function TCylinderNode.GetHeight: Single;
begin
  Result := FdHeight.Value;
end;

procedure TCylinderNode.SetHeight(const Value: Single);
begin
  FdHeight.Send(Value);
end;

function TCylinderNode.GetRadius: Single;
begin
  Result := FdRadius.Value;
end;

procedure TCylinderNode.SetRadius(const Value: Single);
begin
  FdRadius.Send(Value);
end;

function TCylinderNode.GetSide: Boolean;
begin
  Result := FdSide.Value;
end;

procedure TCylinderNode.SetSide(const Value: Boolean);
begin
  FdSide.Send(Value);
end;

function TCylinderNode.GetTop: Boolean;
begin
  Result := FdTop.Value;
end;

procedure TCylinderNode.SetTop(const Value: Boolean);
begin
  FdTop.Send(Value);
end;

function TCylinderNode.GetTexCoord: TX3DNode;
begin
  if FdTexCoord.Value is TX3DNode then
    Result := TX3DNode(FdTexCoord.Value)
  else
    Result := nil;
end;

procedure TCylinderNode.SetTexCoord(const Value: TX3DNode);
begin
  FdTexCoord.Send(Value);
end;

function TCylinderNode.GetSlices: Integer;
begin
  Result := FdSlices.Value;
end;

procedure TCylinderNode.SetSlices(const Value: Integer);
begin
  FdSlices.Send(Value);
end;

class function TCylinderNode.ClassX3DType: String;
begin
  Result := 'Cylinder';
end;

procedure TCylinderNode.CreateNode;
begin
  inherited;

  FFdBottom := TSFBool.Create(Self, False, 'bottom', true);
   FdBottom.ChangeAlways := chGeometry;
  AddField(FFdBottom);

  FFdHeight := TSFFloat.Create(Self, False, 'height', 2);
   FdHeight.ChangeAlways := chGeometry;
   FdHeight.MustBeNonnegative := true;
  AddField(FFdHeight);

  FFdRadius := TSFFloat.Create(Self, False, 'radius', 1);
   FdRadius.ChangeAlways := chGeometry;
   FdRadius.MustBeNonnegative := true;
  AddField(FFdRadius);

  FFdSide := TSFBool.Create(Self, False, 'side', true);
   FdSide.ChangeAlways := chGeometry;
  AddField(FFdSide);

  FFdSolid := TSFBool.Create(Self, False, 'solid', true);
   FdSolid.ChangeAlways := chGeometry;
  AddField(FFdSolid);

  FFdTop := TSFBool.Create(Self, False, 'top', true);
   FdTop.ChangeAlways := chGeometry;
  AddField(FFdTop);

  FFdTexCoord := TSFNode.Create(Self, True, 'texCoord', [TTextureCoordinateGeneratorNode, TProjectedTextureCoordinateNode, TMultiGeneratedTextureCoordinateNode]);
   FdTexCoord.ChangeAlways := chGeometry;
   FdTexCoord.OnBeforeValueChange := {$ifdef FPC}@{$endif}MoveShapeAssociations;
  AddField(FFdTexCoord);

  FFdSlices := TSFInt32.Create(Self, True, 'slices', 0);
   FdSlices.ChangeAlways := chGeometry;
  AddField(FFdSlices);
end;

{$endif read_implementation}
