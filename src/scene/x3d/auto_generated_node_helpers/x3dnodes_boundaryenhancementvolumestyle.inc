{ -*- buffer-read-only: t -*-

  Copyright 2015-2025 Michalis Kamburelis.

  This file is part of "Castle Game Engine".

  "Castle Game Engine" is free software; see the file COPYING.txt,
  included in this distribution, for details about the copyright.

  "Castle Game Engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

  ----------------------------------------------------------------------------
}

{ Automatically generated node properties.

  Do not edit this file manually!
  To add new properties:
  - add them to the text files in tools/internal/x3d-nodes-to-pascal/nodes-specification/ ,
  - and regenerate include files by running x3d-nodes-to-pascal }

{$ifdef read_interface}

  strict private
    function GetBoundaryOpacity: Single;
    procedure SetBoundaryOpacity(const Value: Single);
    function GetOpacityFactor: Single;
    procedure SetOpacityFactor(const Value: Single);
    function GetRetainedOpacity: Single;
    procedure SetRetainedOpacity(const Value: Single);
    function GetSurfaceNormals: TAbstractTexture3DNode;
    procedure SetSurfaceNormals(const Value: TAbstractTexture3DNode);
  public
    { Create node fields and events. }
    procedure CreateNode; override;
    class function ClassX3DType: String; override;

    strict private FFdBoundaryOpacity: TSFFloat;
    { Internal wrapper for property @code(BoundaryOpacity). This wrapper API may change, we advise to access simpler @code(BoundaryOpacity) instead, if it is defined (TODO: for now, some field types do not have a simpler counterpart). }
    public property FdBoundaryOpacity: TSFFloat read FFdBoundaryOpacity;
    {  }
    property BoundaryOpacity: Single read GetBoundaryOpacity write SetBoundaryOpacity;

    strict private FFdOpacityFactor: TSFFloat;
    { Internal wrapper for property @code(OpacityFactor). This wrapper API may change, we advise to access simpler @code(OpacityFactor) instead, if it is defined (TODO: for now, some field types do not have a simpler counterpart). }
    public property FdOpacityFactor: TSFFloat read FFdOpacityFactor;
    {  }
    property OpacityFactor: Single read GetOpacityFactor write SetOpacityFactor;

    strict private FFdRetainedOpacity: TSFFloat;
    { Internal wrapper for property @code(RetainedOpacity). This wrapper API may change, we advise to access simpler @code(RetainedOpacity) instead, if it is defined (TODO: for now, some field types do not have a simpler counterpart). }
    public property FdRetainedOpacity: TSFFloat read FFdRetainedOpacity;
    {  }
    property RetainedOpacity: Single read GetRetainedOpacity write SetRetainedOpacity;

    strict private FFdSurfaceNormals: TSFNode;
    { Internal wrapper for property @code(SurfaceNormals). This wrapper API may change, we advise to access simpler @code(SurfaceNormals) instead, if it is defined (TODO: for now, some field types do not have a simpler counterpart). }
    public property FdSurfaceNormals: TSFNode read FFdSurfaceNormals;
    {  }
    property SurfaceNormals: TAbstractTexture3DNode read GetSurfaceNormals write SetSurfaceNormals;

{$endif read_interface}

{$ifdef read_implementation}

{ TBoundaryEnhancementVolumeStyleNode ----------------------------------------------- }

function TBoundaryEnhancementVolumeStyleNode.GetBoundaryOpacity: Single;
begin
  Result := FdBoundaryOpacity.Value;
end;

procedure TBoundaryEnhancementVolumeStyleNode.SetBoundaryOpacity(const Value: Single);
begin
  FdBoundaryOpacity.Send(Value);
end;

function TBoundaryEnhancementVolumeStyleNode.GetOpacityFactor: Single;
begin
  Result := FdOpacityFactor.Value;
end;

procedure TBoundaryEnhancementVolumeStyleNode.SetOpacityFactor(const Value: Single);
begin
  FdOpacityFactor.Send(Value);
end;

function TBoundaryEnhancementVolumeStyleNode.GetRetainedOpacity: Single;
begin
  Result := FdRetainedOpacity.Value;
end;

procedure TBoundaryEnhancementVolumeStyleNode.SetRetainedOpacity(const Value: Single);
begin
  FdRetainedOpacity.Send(Value);
end;

function TBoundaryEnhancementVolumeStyleNode.GetSurfaceNormals: TAbstractTexture3DNode;
begin
  if FdSurfaceNormals.Value is TAbstractTexture3DNode then
    Result := TAbstractTexture3DNode(FdSurfaceNormals.Value)
  else
    Result := nil;
end;

procedure TBoundaryEnhancementVolumeStyleNode.SetSurfaceNormals(const Value: TAbstractTexture3DNode);
begin
  FdSurfaceNormals.Send(Value);
end;

class function TBoundaryEnhancementVolumeStyleNode.ClassX3DType: String;
begin
  Result := 'BoundaryEnhancementVolumeStyle';
end;

procedure TBoundaryEnhancementVolumeStyleNode.CreateNode;
begin
  inherited;

  FFdBoundaryOpacity := TSFFloat.Create(Self, True, 'boundaryOpacity', 0.9);
   FdBoundaryOpacity.ChangeAlways := chVisibleNonGeometry;
   FdBoundaryOpacity.MustBeNonnegative := true;
  AddField(FFdBoundaryOpacity);

  FFdOpacityFactor := TSFFloat.Create(Self, True, 'opacityFactor', 2);
   FdOpacityFactor.ChangeAlways := chVisibleNonGeometry;
   FdOpacityFactor.MustBeNonnegative := true;
  AddField(FFdOpacityFactor);

  FFdRetainedOpacity := TSFFloat.Create(Self, True, 'retainedOpacity', 0.2);
   FdRetainedOpacity.ChangeAlways := chVisibleNonGeometry;
   FdRetainedOpacity.MustBeNonnegative := true;
  AddField(FFdRetainedOpacity);

  FFdSurfaceNormals := TSFNode.Create(Self, True, 'surfaceNormals', [TAbstractTexture3DNode]);
   FdSurfaceNormals.ChangeAlways := chVisibleNonGeometry;
  AddField(FFdSurfaceNormals);
end;

{$endif read_implementation}
