{ -*- buffer-read-only: t -*-

  Copyright 2015-2025 Michalis Kamburelis.

  This file is part of "Castle Game Engine".

  "Castle Game Engine" is free software; see the file COPYING.txt,
  included in this distribution, for details about the copyright.

  "Castle Game Engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

  ----------------------------------------------------------------------------
}

{ Automatically generated node properties.

  Do not edit this file manually!
  To add new properties:
  - add them to the text files in tools/internal/x3d-nodes-to-pascal/nodes-specification/ ,
  - and regenerate include files by running x3d-nodes-to-pascal }

{$ifdef read_interface}

  strict private
    function GetSkeleton: TAbstractGroupingNode;
    procedure SetSkeleton(const Value: TAbstractGroupingNode);
  public
    { Create node fields and events. }
    procedure CreateNode; override;
    class function ClassX3DType: String; override;

    strict private FFdJoints: TMFNode;
    { Internal wrapper for property @code(Joints). This wrapper API may change, we advise to access simpler @code(Joints) instead, if it is defined (TODO: for now, some field types do not have a simpler counterpart). }
    public property FdJoints: TMFNode read FFdJoints;
    { Joints are transformation nodes that, when transformed, modify the skin (meshes affected by this skinned animation, listed in @link(Shapes)).

    Various node classes that can define a transformation (translation, rotation, scale) are allowed as joints here. If you don't have any other requirement, then just use @link(TTransformNode). Implementations can assume that nodes here have non-nil @link(TX3DNode.TransformFunctionality). }
    procedure SetJoints(const Value: array of TX3DNode);

    strict private FFdInverseBindMatrices: TMFMatrix4f;
    { Internal wrapper for property @code(InverseBindMatrices). This wrapper API may change, we advise to access simpler @code(InverseBindMatrices) instead, if it is defined (TODO: for now, some field types do not have a simpler counterpart). }
    public property FdInverseBindMatrices: TMFMatrix4f read FFdInverseBindMatrices;
    { For each joint, an "inverse bind matrix" is specified, which transforms the mesh into the local space of the joint.

    The precise mathematical meaning of this follows the @url(https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html glTF 2.0 specification). The @url(https://www.khronos.org/files/gltf20-reference-guide.pdf glTF 2.0 API Reference Guide) also contains a great explanation of how this is used.

    The count of this array must be equal to the count of @link(Joints). }
    procedure SetInverseBindMatrices(const Value: array of TMatrix4); overload;
    { For each joint, an "inverse bind matrix" is specified, which transforms the mesh into the local space of the joint.

    The precise mathematical meaning of this follows the @url(https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html glTF 2.0 specification). The @url(https://www.khronos.org/files/gltf20-reference-guide.pdf glTF 2.0 API Reference Guide) also contains a great explanation of how this is used.

    The count of this array must be equal to the count of @link(Joints). }
    procedure SetInverseBindMatrices(const Value: TMatrix4List); overload;

    strict private FFdShapes: TMFNode;
    { Internal wrapper for property @code(Shapes). This wrapper API may change, we advise to access simpler @code(Shapes) instead, if it is defined (TODO: for now, some field types do not have a simpler counterpart). }
    public property FdShapes: TMFNode read FFdShapes;
    { Shapes whose geometries are affected by the skinned animation, that is: their vertexes move to follow the joints that are associated with them.

    Only shapes with geometries that have @code(SkinWeights0) and @code(SkinJoints0) fields are allowed here. This means these geometry nodes: @link(TAbstractComposedGeometryNode) (with its numerous descendants, all "meshes" that are composed of triangles, quads, faces...), @link(TIndexedLineSetNode), @link(TLineSetNode) and @link(TPointSetNode).

    The geometries within these shapes are affected by this skinned animation.
    Their @code(SkinJoints0) indexes refer to our @link(Joints).

    Note that you can place here only shape nodes, not groups or hierarchies of them (e.g. @link(TGroupNode) or @link(TTransformNode)). This is a deliberate constraint to make working of this node obvious.

    This also matches the glTF usage, where the meshes affected by one skin are always within one and the same transformation. glTF specification says @italic("Only the joint transforms are applied to the skinned mesh; the transform of the skinned mesh node MUST be ignored.") which in practice forces treating all skinned shapes as if they were direct children alongside the skeleton root.

    We make it more explicit in our design: the @link(Shapes) are explicitly direct children of the @link(TSkinNode). So the shapes are affected by the transformations of the @link(TSkinNode). Any further transformation of shapes has to happen through the skinned animation (joints affecting shapes vertexes according to weights), not through the direct transformations of the shapes themselves.

    Note that you can also place @link(TShapeNode) instances within the @link(Skeleton) hierarchy. Such shapes are not affected by the skinned animation, they are just rigid 3D shapes attached to the joints (like a sword may be attached to the avatar's hand). }
    procedure SetShapes(const Value: array of TAbstractShapeNode);

    strict private FFdSkeleton: TSFNode;
    { Internal wrapper for property @code(Skeleton). This wrapper API may change, we advise to access simpler @code(Skeleton) instead, if it is defined (TODO: for now, some field types do not have a simpler counterpart). }
    public property FdSkeleton: TSFNode read FFdSkeleton;
    { Common root of the joints hierarchy. }
    property Skeleton: TAbstractGroupingNode read GetSkeleton write SetSkeleton;

{$endif read_interface}

{$ifdef read_implementation}

{ TSkinNode ----------------------------------------------- }

procedure TSkinNode.SetJoints(const Value: array of TX3DNode);
var
  L: Integer;
  A: array of TX3DNode;
begin
  L := High(Value) + 1;
  SetLength(A, L);
  if L > 0 then
    Move(Value[0], A[0], L * SizeOf(TX3DNode));
  FdJoints.Send(A);
end;

procedure TSkinNode.SetInverseBindMatrices(const Value: array of TMatrix4);
begin
  FdInverseBindMatrices.Send(Value);
end;

procedure TSkinNode.SetInverseBindMatrices(const Value: TMatrix4List);
begin
  FdInverseBindMatrices.Send(Value);
end;

procedure TSkinNode.SetShapes(const Value: array of TAbstractShapeNode);
var
  L: Integer;
  A: array of TX3DNode;
begin
  L := High(Value) + 1;
  SetLength(A, L);
  if L > 0 then
    Move(Value[0], A[0], L * SizeOf(TAbstractShapeNode));
  FdShapes.Send(A);
end;

function TSkinNode.GetSkeleton: TAbstractGroupingNode;
begin
  if FdSkeleton.Value is TAbstractGroupingNode then
    Result := TAbstractGroupingNode(FdSkeleton.Value)
  else
    Result := nil;
end;

procedure TSkinNode.SetSkeleton(const Value: TAbstractGroupingNode);
begin
  FdSkeleton.Send(Value);
end;

class function TSkinNode.ClassX3DType: String;
begin
  Result := 'Skin';
end;

procedure TSkinNode.CreateNode;
begin
  inherited;

  FFdJoints := TMFNode.Create(Self, True, 'joints', [TTransformNode, THAnimJointNode]);
   FdJoints.ChangeAlways := chEverything;
  AddField(FFdJoints);

  FFdInverseBindMatrices := TMFMatrix4f.Create(Self, True, 'inverseBindMatrices', []);
   FdInverseBindMatrices.ChangeAlways := chEverything;
  AddField(FFdInverseBindMatrices);

  FFdShapes := TMFNode.Create(Self, True, 'shapes', [TAbstractShapeNode]);
   FdShapes.ChangeAlways := chEverything;
  AddField(FFdShapes);

  FFdSkeleton := TSFNode.Create(Self, True, 'skeleton', [TAbstractGroupingNode]);
   FdSkeleton.ChangeAlways := chEverything;
  AddField(FFdSkeleton);
end;

{$endif read_implementation}
