{ -*- buffer-read-only: t -*-

  Copyright 2015-2025 Michalis Kamburelis.

  This file is part of "Castle Game Engine".

  "Castle Game Engine" is free software; see the file COPYING.txt,
  included in this distribution, for details about the copyright.

  "Castle Game Engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

  ----------------------------------------------------------------------------
}

{ Automatically generated node properties.

  Do not edit this file manually!
  To add new properties:
  - add them to the text files in tools/internal/x3d-nodes-to-pascal/nodes-specification/ ,
  - and regenerate include files by running x3d-nodes-to-pascal }

{$ifdef read_interface}

  strict private
    function GetSkeleton: TX3DNode;
    procedure SetSkeleton(const Value: TX3DNode);
  public
    { Create node fields and events. }
    procedure CreateNode; override;
    class function ClassX3DType: String; override;

    strict private FFdJoints: TMFNode;
    { Internal wrapper for property @code(Joints). This wrapper API may change, we advise to access simpler @code(Joints) instead, if it is defined (TODO: for now, some field types do not have a simpler counterpart). }
    public property FdJoints: TMFNode read FFdJoints;
    { Joints are transformation nodes that, when transformed, modify the skin (meshes affected by this skinned animation, listed in @link(Shapes)).

    Various node classes that can define a transformation (translation, rotation, scale) are allowed as joints here. If you don't have any other requirement, then just use @link(TTransformNode). Implementations can assume that nodes here have non-nil @link(TX3DNode.TransformFunctionality). }
    procedure SetJoints(const Value: array of TX3DNode);

    strict private FFdInverseBindMatrices: TMFMatrix4f;
    { Internal wrapper for property @code(InverseBindMatrices). This wrapper API may change, we advise to access simpler @code(InverseBindMatrices) instead, if it is defined (TODO: for now, some field types do not have a simpler counterpart). }
    public property FdInverseBindMatrices: TMFMatrix4f read FFdInverseBindMatrices;
    { For each joint, an "inverse bind matrix" is specified, which transforms the mesh into the local space of the joint.

    The precise mathematical meaning of this follows the @url(https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html glTF 2.0 specification). The @url(https://www.khronos.org/files/gltf20-reference-guide.pdf glTF 2.0 API Reference Guide) also contains a great explanation of how this is used.

    The count of this array must be equal to the count of @link(Joints). }
    procedure SetInverseBindMatrices(const Value: array of TMatrix4); overload;
    { For each joint, an "inverse bind matrix" is specified, which transforms the mesh into the local space of the joint.

    The precise mathematical meaning of this follows the @url(https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html glTF 2.0 specification). The @url(https://www.khronos.org/files/gltf20-reference-guide.pdf glTF 2.0 API Reference Guide) also contains a great explanation of how this is used.

    The count of this array must be equal to the count of @link(Joints). }
    procedure SetInverseBindMatrices(const Value: TMatrix4List); overload;

    strict private FFdShapes: TMFNode;
    { Internal wrapper for property @code(Shapes). This wrapper API may change, we advise to access simpler @code(Shapes) instead, if it is defined (TODO: for now, some field types do not have a simpler counterpart). }
    public property FdShapes: TMFNode read FFdShapes;
    { Shapes whose geometries are affected by this skinned animation.

    Only shapes with geometries that have @code(SkinWeights0) and @code(SkinJoints0) fields are allowed here. This means these geometry nodes: @link(TAbstractComposedGeometryNode) (with its numerous descendants, all "meshes" that are composed of triangles, quads, faces...), @link(TIndexedLineSetNode), @link(TLineSetNode) and @link(TPointSetNode).

    The geometries within these shapes are affected by this skinned animation.
    Their @code(SkinJoints0) indexes refer to our @link(Joints).

    @bold(All shapes listed here must be direct children of the @link(Skeleton) node.)
    This is an additional requirement (not present in glTF specification), but it reflects the de-facto way how the transformation of these shapes matters. glTF specification says @italic("Only the joint transforms are applied to the skinned mesh; the transform of the skinned mesh node MUST be ignored.") which in practice forces treating all shapes as if they were direct children of the skeleton. }
    procedure SetShapes(const Value: array of TAbstractShapeNode);

    strict private FFdSkeleton: TSFNode;
    { Internal wrapper for property @code(Skeleton). This wrapper API may change, we advise to access simpler @code(Skeleton) instead, if it is defined (TODO: for now, some field types do not have a simpler counterpart). }
    public property FdSkeleton: TSFNode read FFdSkeleton;
    { Common root of a joints hierarchy or a direct or indirect parent node of the common root.

    In the most common situation, this is just the "root joint", and is also present in the @link(Joints) array. However, it's not required that @link(Skeleton) is present in @link(Joints). }
    property Skeleton: TX3DNode read GetSkeleton write SetSkeleton;

{$endif read_interface}

{$ifdef read_implementation}

{ TSkinNode ----------------------------------------------- }

procedure TSkinNode.SetJoints(const Value: array of TX3DNode);
var
  L: Integer;
  A: array of TX3DNode;
begin
  L := High(Value) + 1;
  SetLength(A, L);
  if L > 0 then
    Move(Value[0], A[0], L * SizeOf(TX3DNode));
  FdJoints.Send(A);
end;

procedure TSkinNode.SetInverseBindMatrices(const Value: array of TMatrix4);
begin
  FdInverseBindMatrices.Send(Value);
end;

procedure TSkinNode.SetInverseBindMatrices(const Value: TMatrix4List);
begin
  FdInverseBindMatrices.Send(Value);
end;

procedure TSkinNode.SetShapes(const Value: array of TAbstractShapeNode);
var
  L: Integer;
  A: array of TX3DNode;
begin
  L := High(Value) + 1;
  SetLength(A, L);
  if L > 0 then
    Move(Value[0], A[0], L * SizeOf(TAbstractShapeNode));
  FdShapes.Send(A);
end;

function TSkinNode.GetSkeleton: TX3DNode;
begin
  if FdSkeleton.Value is TX3DNode then
    Result := TX3DNode(FdSkeleton.Value)
  else
    Result := nil;
end;

procedure TSkinNode.SetSkeleton(const Value: TX3DNode);
begin
  FdSkeleton.Send(Value);
end;

class function TSkinNode.ClassX3DType: String;
begin
  Result := 'Skin';
end;

procedure TSkinNode.CreateNode;
begin
  inherited;

  FFdJoints := TMFNode.Create(Self, True, 'joints', [TTransformNode, THAnimJointNode]);
   FdJoints.ChangeAlways := chEverything;
  AddField(FFdJoints);

  FFdInverseBindMatrices := TMFMatrix4f.Create(Self, True, 'inverseBindMatrices', []);
   FdInverseBindMatrices.ChangeAlways := chEverything;
  AddField(FFdInverseBindMatrices);

  FFdShapes := TMFNode.Create(Self, True, 'shapes', [TAbstractShapeNode]);
   FdShapes.ChangeAlways := chEverything;
  AddField(FFdShapes);

  FFdSkeleton := TSFNode.Create(Self, True, 'skeleton', [TTransformNode, THAnimJointNode]);
   FdSkeleton.ChangeAlways := chEverything;
  AddField(FFdSkeleton);
end;

{$endif read_implementation}
