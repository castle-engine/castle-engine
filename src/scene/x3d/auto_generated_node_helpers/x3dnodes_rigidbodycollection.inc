{ -*- buffer-read-only: t -*-

  Copyright 2015-2023 Michalis Kamburelis.

  This file is part of "Castle Game Engine".

  "Castle Game Engine" is free software; see the file COPYING.txt,
  included in this distribution, for details about the copyright.

  "Castle Game Engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

  ----------------------------------------------------------------------------
}

{ Automatically generated node properties.

  Do not edit this file manually!
  To add new properties:
  - add them to the text files in tools/internal/x3d-nodes-to-pascal/nodes-specification/ ,
  - and regenerate include files by running x3d-nodes-to-pascal }

{$ifdef read_interface}

  strict private
    function GetAutoDisable: Boolean;
    procedure SetAutoDisable(const Value: Boolean);
    function GetConstantForceMix: Single;
    procedure SetConstantForceMix(const Value: Single);
    function GetContactSurfaceThickness: Single;
    procedure SetContactSurfaceThickness(const Value: Single);
    function GetDisableAngularSpeed: Single;
    procedure SetDisableAngularSpeed(const Value: Single);
    function GetDisableLinearSpeed: Single;
    procedure SetDisableLinearSpeed(const Value: Single);
    function GetDisableTime: Single;
    procedure SetDisableTime(const Value: Single);
    function GetEnabled: Boolean;
    procedure SetEnabled(const Value: Boolean);
    function GetErrorCorrection: Single;
    procedure SetErrorCorrection(const Value: Single);
    function GetGravity: TVector3;
    procedure SetGravity(const Value: TVector3);
    function GetIterations: Integer;
    procedure SetIterations(const Value: Integer);
    function GetMaxCorrectionSpeed: Single;
    procedure SetMaxCorrectionSpeed(const Value: Single);
    function GetPreferAccuracy: Boolean;
    procedure SetPreferAccuracy(const Value: Boolean);
    function GetCollider: TCollisionCollectionNode;
    procedure SetCollider(const Value: TCollisionCollectionNode);
  public
    { Create node fields and events. }
    procedure CreateNode; override;
    class function ClassX3DType: string; override;

    strict private FEventSet_contacts: TMFNodeEvent;
    {  }
    public property EventSet_contacts: TMFNodeEvent read FEventSet_contacts;

    strict private FFdAutoDisable: TSFBool;
    { Internal wrapper for property @code(AutoDisable). This wrapper API may change, we advise to access simpler @code(AutoDisable) instead, if it is defined (TODO: for now, some field types do not have a simpler counterpart). }
    public property FdAutoDisable: TSFBool read FFdAutoDisable;
    {  }
    property AutoDisable: Boolean read GetAutoDisable write SetAutoDisable;

    strict private FFdBodies: TMFNode;
    { Internal wrapper for property @code(Bodies). This wrapper API may change, we advise to access simpler @code(Bodies) instead, if it is defined (TODO: for now, some field types do not have a simpler counterpart). }
    public property FdBodies: TMFNode read FFdBodies;
    {  }
    procedure SetBodies(const Value: array of TRigidBodyNode);

    strict private FFdConstantForceMix: TSFFloat;
    { Internal wrapper for property @code(ConstantForceMix). This wrapper API may change, we advise to access simpler @code(ConstantForceMix) instead, if it is defined (TODO: for now, some field types do not have a simpler counterpart). }
    public property FdConstantForceMix: TSFFloat read FFdConstantForceMix;
    {  }
    property ConstantForceMix: Single read GetConstantForceMix write SetConstantForceMix;

    strict private FFdContactSurfaceThickness: TSFFloat;
    { Internal wrapper for property @code(ContactSurfaceThickness). This wrapper API may change, we advise to access simpler @code(ContactSurfaceThickness) instead, if it is defined (TODO: for now, some field types do not have a simpler counterpart). }
    public property FdContactSurfaceThickness: TSFFloat read FFdContactSurfaceThickness;
    {  }
    property ContactSurfaceThickness: Single read GetContactSurfaceThickness write SetContactSurfaceThickness;

    strict private FFdDisableAngularSpeed: TSFFloat;
    { Internal wrapper for property @code(DisableAngularSpeed). This wrapper API may change, we advise to access simpler @code(DisableAngularSpeed) instead, if it is defined (TODO: for now, some field types do not have a simpler counterpart). }
    public property FdDisableAngularSpeed: TSFFloat read FFdDisableAngularSpeed;
    {  }
    property DisableAngularSpeed: Single read GetDisableAngularSpeed write SetDisableAngularSpeed;

    strict private FFdDisableLinearSpeed: TSFFloat;
    { Internal wrapper for property @code(DisableLinearSpeed). This wrapper API may change, we advise to access simpler @code(DisableLinearSpeed) instead, if it is defined (TODO: for now, some field types do not have a simpler counterpart). }
    public property FdDisableLinearSpeed: TSFFloat read FFdDisableLinearSpeed;
    {  }
    property DisableLinearSpeed: Single read GetDisableLinearSpeed write SetDisableLinearSpeed;

    strict private FFdDisableTime: TSFFloat;
    { Internal wrapper for property @code(DisableTime). This wrapper API may change, we advise to access simpler @code(DisableTime) instead, if it is defined (TODO: for now, some field types do not have a simpler counterpart). }
    public property FdDisableTime: TSFFloat read FFdDisableTime;
    {  }
    property DisableTime: Single read GetDisableTime write SetDisableTime;

    strict private FFdEnabled: TSFBool;
    { Internal wrapper for property @code(Enabled). This wrapper API may change, we advise to access simpler @code(Enabled) instead, if it is defined (TODO: for now, some field types do not have a simpler counterpart). }
    public property FdEnabled: TSFBool read FFdEnabled;
    {  }
    property Enabled: Boolean read GetEnabled write SetEnabled;

    strict private FFdErrorCorrection: TSFFloat;
    { Internal wrapper for property @code(ErrorCorrection). This wrapper API may change, we advise to access simpler @code(ErrorCorrection) instead, if it is defined (TODO: for now, some field types do not have a simpler counterpart). }
    public property FdErrorCorrection: TSFFloat read FFdErrorCorrection;
    {  }
    property ErrorCorrection: Single read GetErrorCorrection write SetErrorCorrection;

    strict private FFdGravity: TSFVec3f;
    { Internal wrapper for property @code(Gravity). This wrapper API may change, we advise to access simpler @code(Gravity) instead, if it is defined (TODO: for now, some field types do not have a simpler counterpart). }
    public property FdGravity: TSFVec3f read FFdGravity;
    {  }
    property Gravity: TVector3 read GetGravity write SetGravity;

    strict private FFdIterations: TSFInt32;
    { Internal wrapper for property @code(Iterations). This wrapper API may change, we advise to access simpler @code(Iterations) instead, if it is defined (TODO: for now, some field types do not have a simpler counterpart). }
    public property FdIterations: TSFInt32 read FFdIterations;
    {  }
    property Iterations: Integer read GetIterations write SetIterations;

    strict private FFdJoints: TMFNode;
    { Internal wrapper for property @code(Joints). This wrapper API may change, we advise to access simpler @code(Joints) instead, if it is defined (TODO: for now, some field types do not have a simpler counterpart). }
    public property FdJoints: TMFNode read FFdJoints;
    {  }
    procedure SetJoints(const Value: array of TAbstractRigidJointNode);

    strict private FFdMaxCorrectionSpeed: TSFFloat;
    { Internal wrapper for property @code(MaxCorrectionSpeed). This wrapper API may change, we advise to access simpler @code(MaxCorrectionSpeed) instead, if it is defined (TODO: for now, some field types do not have a simpler counterpart). }
    public property FdMaxCorrectionSpeed: TSFFloat read FFdMaxCorrectionSpeed;
    {  }
    property MaxCorrectionSpeed: Single read GetMaxCorrectionSpeed write SetMaxCorrectionSpeed;

    strict private FFdPreferAccuracy: TSFBool;
    { Internal wrapper for property @code(PreferAccuracy). This wrapper API may change, we advise to access simpler @code(PreferAccuracy) instead, if it is defined (TODO: for now, some field types do not have a simpler counterpart). }
    public property FdPreferAccuracy: TSFBool read FFdPreferAccuracy;
    {  }
    property PreferAccuracy: Boolean read GetPreferAccuracy write SetPreferAccuracy;

    strict private FFdCollider: TSFNode;
    { Internal wrapper for property @code(Collider). This wrapper API may change, we advise to access simpler @code(Collider) instead, if it is defined (TODO: for now, some field types do not have a simpler counterpart). }
    public property FdCollider: TSFNode read FFdCollider;
    {  }
    property Collider: TCollisionCollectionNode read GetCollider write SetCollider;

{$endif read_interface}

{$ifdef read_implementation}

{ TRigidBodyCollectionNode ----------------------------------------------- }

function TRigidBodyCollectionNode.GetAutoDisable: Boolean;
begin
  Result := FdAutoDisable.Value;
end;

procedure TRigidBodyCollectionNode.SetAutoDisable(const Value: Boolean);
begin
  FdAutoDisable.Send(Value);
end;

procedure TRigidBodyCollectionNode.SetBodies(const Value: array of TRigidBodyNode);
var
  L: Integer;
  A: array of TX3DNode;
begin
  L := High(Value) + 1;
  SetLength(A, L);
  if L > 0 then
    Move(Value[0], A[0], L * SizeOf(TRigidBodyNode));
  FdBodies.Send(A);
end;

function TRigidBodyCollectionNode.GetConstantForceMix: Single;
begin
  Result := FdConstantForceMix.Value;
end;

procedure TRigidBodyCollectionNode.SetConstantForceMix(const Value: Single);
begin
  FdConstantForceMix.Send(Value);
end;

function TRigidBodyCollectionNode.GetContactSurfaceThickness: Single;
begin
  Result := FdContactSurfaceThickness.Value;
end;

procedure TRigidBodyCollectionNode.SetContactSurfaceThickness(const Value: Single);
begin
  FdContactSurfaceThickness.Send(Value);
end;

function TRigidBodyCollectionNode.GetDisableAngularSpeed: Single;
begin
  Result := FdDisableAngularSpeed.Value;
end;

procedure TRigidBodyCollectionNode.SetDisableAngularSpeed(const Value: Single);
begin
  FdDisableAngularSpeed.Send(Value);
end;

function TRigidBodyCollectionNode.GetDisableLinearSpeed: Single;
begin
  Result := FdDisableLinearSpeed.Value;
end;

procedure TRigidBodyCollectionNode.SetDisableLinearSpeed(const Value: Single);
begin
  FdDisableLinearSpeed.Send(Value);
end;

function TRigidBodyCollectionNode.GetDisableTime: Single;
begin
  Result := FdDisableTime.Value;
end;

procedure TRigidBodyCollectionNode.SetDisableTime(const Value: Single);
begin
  FdDisableTime.Send(Value);
end;

function TRigidBodyCollectionNode.GetEnabled: Boolean;
begin
  Result := FdEnabled.Value;
end;

procedure TRigidBodyCollectionNode.SetEnabled(const Value: Boolean);
begin
  FdEnabled.Send(Value);
end;

function TRigidBodyCollectionNode.GetErrorCorrection: Single;
begin
  Result := FdErrorCorrection.Value;
end;

procedure TRigidBodyCollectionNode.SetErrorCorrection(const Value: Single);
begin
  FdErrorCorrection.Send(Value);
end;

function TRigidBodyCollectionNode.GetGravity: TVector3;
begin
  Result := FdGravity.Value;
end;

procedure TRigidBodyCollectionNode.SetGravity(const Value: TVector3);
begin
  FdGravity.Send(Value);
end;

function TRigidBodyCollectionNode.GetIterations: Integer;
begin
  Result := FdIterations.Value;
end;

procedure TRigidBodyCollectionNode.SetIterations(const Value: Integer);
begin
  FdIterations.Send(Value);
end;

procedure TRigidBodyCollectionNode.SetJoints(const Value: array of TAbstractRigidJointNode);
var
  L: Integer;
  A: array of TX3DNode;
begin
  L := High(Value) + 1;
  SetLength(A, L);
  if L > 0 then
    Move(Value[0], A[0], L * SizeOf(TAbstractRigidJointNode));
  FdJoints.Send(A);
end;

function TRigidBodyCollectionNode.GetMaxCorrectionSpeed: Single;
begin
  Result := FdMaxCorrectionSpeed.Value;
end;

procedure TRigidBodyCollectionNode.SetMaxCorrectionSpeed(const Value: Single);
begin
  FdMaxCorrectionSpeed.Send(Value);
end;

function TRigidBodyCollectionNode.GetPreferAccuracy: Boolean;
begin
  Result := FdPreferAccuracy.Value;
end;

procedure TRigidBodyCollectionNode.SetPreferAccuracy(const Value: Boolean);
begin
  FdPreferAccuracy.Send(Value);
end;

function TRigidBodyCollectionNode.GetCollider: TCollisionCollectionNode;
begin
  if FdCollider.Value is TCollisionCollectionNode then
    Result := TCollisionCollectionNode(FdCollider.Value)
  else
    Result := nil;
end;

procedure TRigidBodyCollectionNode.SetCollider(const Value: TCollisionCollectionNode);
begin
  FdCollider.Send(Value);
end;

class function TRigidBodyCollectionNode.ClassX3DType: String;
begin
  Result := 'RigidBodyCollection';
end;

procedure TRigidBodyCollectionNode.CreateNode;
begin
  inherited;

  FEventSet_contacts := TMFNodeEvent.Create(Self, 'set_contacts', true);
  AddEvent(FEventSet_contacts);

  FFdAutoDisable := TSFBool.Create(Self, True, 'autoDisable', false);
   FdAutoDisable.ChangeAlways := chVisibleNonGeometry;
  AddField(FFdAutoDisable);

  FFdBodies := TMFNode.Create(Self, True, 'bodies', [TRigidBodyNode]);
   FdBodies.ChangeAlways := chVisibleNonGeometry;
  AddField(FFdBodies);

  FFdConstantForceMix := TSFFloat.Create(Self, True, 'constantForceMix', 0.0001);
   FdConstantForceMix.ChangeAlways := chVisibleNonGeometry;
   FdConstantForceMix.MustBeNonnegative := true;
  AddField(FFdConstantForceMix);

  FFdContactSurfaceThickness := TSFFloat.Create(Self, True, 'contactSurfaceThickness', 0);
   FdContactSurfaceThickness.ChangeAlways := chVisibleNonGeometry;
   FdContactSurfaceThickness.MustBeNonnegative := true;
  AddField(FFdContactSurfaceThickness);

  FFdDisableAngularSpeed := TSFFloat.Create(Self, True, 'disableAngularSpeed', 0);
   FdDisableAngularSpeed.ChangeAlways := chVisibleNonGeometry;
   FdDisableAngularSpeed.MustBeNonnegative := true;
  AddField(FFdDisableAngularSpeed);

  FFdDisableLinearSpeed := TSFFloat.Create(Self, True, 'disableLinearSpeed', 0);
   FdDisableLinearSpeed.ChangeAlways := chVisibleNonGeometry;
   FdDisableLinearSpeed.MustBeNonnegative := true;
  AddField(FFdDisableLinearSpeed);

  FFdDisableTime := TSFFloat.Create(Self, True, 'disableTime', 0);
   FdDisableTime.ChangeAlways := chVisibleNonGeometry;
   FdDisableTime.MustBeNonnegative := true;
  AddField(FFdDisableTime);

  FFdEnabled := TSFBool.Create(Self, True, 'enabled', true);
   FdEnabled.ChangeAlways := chVisibleNonGeometry;
  AddField(FFdEnabled);

  FFdErrorCorrection := TSFFloat.Create(Self, True, 'errorCorrection', 0.8);
   FdErrorCorrection.ChangeAlways := chVisibleNonGeometry;
   FdErrorCorrection.MustBeNonnegative := true;
  AddField(FFdErrorCorrection);

  FFdGravity := TSFVec3f.Create(Self, True, 'gravity', Vector3(0, -9.8, 0));
   FdGravity.ChangeAlways := chVisibleNonGeometry;
  AddField(FFdGravity);

  FFdIterations := TSFInt32.Create(Self, True, 'iterations', 10);
   FdIterations.ChangeAlways := chVisibleNonGeometry;
   FdIterations.MustBeNonnegative := true;
  AddField(FFdIterations);

  FFdJoints := TMFNode.Create(Self, True, 'joints', [TAbstractRigidJointNode]);
   FdJoints.ChangeAlways := chVisibleNonGeometry;
  AddField(FFdJoints);

  FFdMaxCorrectionSpeed := TSFFloat.Create(Self, True, 'maxCorrectionSpeed', -1);
   FdMaxCorrectionSpeed.ChangeAlways := chVisibleNonGeometry;
  AddField(FFdMaxCorrectionSpeed);

  FFdPreferAccuracy := TSFBool.Create(Self, True, 'preferAccuracy', false);
   FdPreferAccuracy.ChangeAlways := chVisibleNonGeometry;
  AddField(FFdPreferAccuracy);

  FFdCollider := TSFNode.Create(Self, False, 'collider', [TCollisionCollectionNode]);
   FdCollider.ChangeAlways := chVisibleNonGeometry;
  AddField(FFdCollider);
end;

{$endif read_implementation}
