{ -*- buffer-read-only: t -*-

  Copyright 2018-2022 Michalis Kamburelis.

  This file is part of "Castle Game Engine".

  "Castle Game Engine" is free software; see the file COPYING.txt,
  included in this distribution, for details about the copyright.

  "Castle Game Engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

  ----------------------------------------------------------------------------
}

{ Automatically generated wrapper to make vectors/colors persistent.

  Do not edit this file manually!
  Instead
  - edit tools/internal/generate-persistent-vectors/persistent_vectors_input.txt
  - and run generate-persistent-vectors in that directory.
}

{$ifdef read_interface_class}
strict private
  FCurrentItemBorderColor1Persistent: TCastleColorPersistent;
  function GetCurrentItemBorderColor1ForPersistent: TCastleColor;
  procedure SetCurrentItemBorderColor1ForPersistent(const AValue: TCastleColor);
published
  { @link(CurrentItemBorderColor1) that can be visually edited in
    Castle Game Engine Editor, Lazarus and Delphi.
    Normal user code does not need to deal with this,
    instead read or write @link(CurrentItemBorderColor1) directly.

    @seealso CurrentItemBorderColor1 }
  property CurrentItemBorderColor1Persistent: TCastleColorPersistent read FCurrentItemBorderColor1Persistent ;
{$endif read_interface_class}

{$ifdef read_implementation_methods}
function TCastleOnScreenMenu.GetCurrentItemBorderColor1ForPersistent: TCastleColor;
begin
  Result := CurrentItemBorderColor1;
end;

procedure TCastleOnScreenMenu.SetCurrentItemBorderColor1ForPersistent(const AValue: TCastleColor);
begin
  CurrentItemBorderColor1 := AValue;
end;
{$endif read_implementation_methods}

{$ifdef read_implementation_constructor}
  FCurrentItemBorderColor1Persistent := TCastleColorPersistent.Create(nil);
  { Note that some classes (like TCastleVector3Persistent) call SetSubComponent(true)
    on themselves, for backward compatibility. But we should not depend on it,
    some classes (like TFloatRectanglePersisten) may not call it.
    The responsibility of calling "SetSubComponent(true)" should be on the owner
    in general (this is more functional, and more standard too). }
  FCurrentItemBorderColor1Persistent.SetSubComponent(true);
  FCurrentItemBorderColor1Persistent.InternalGetValue := {$ifdef FPC}@{$endif}GetCurrentItemBorderColor1ForPersistent;
  FCurrentItemBorderColor1Persistent.InternalSetValue := {$ifdef FPC}@{$endif}SetCurrentItemBorderColor1ForPersistent;
  FCurrentItemBorderColor1Persistent.InternalDefaultValue := CurrentItemBorderColor1; // current value is default
{$endif read_implementation_constructor}

{$ifdef read_implementation_destructor}
  FreeAndNil(FCurrentItemBorderColor1Persistent);
{$endif read_implementation_destructor}

{ -*- buffer-read-only: t -*-

  Copyright 2018-2022 Michalis Kamburelis.

  This file is part of "Castle Game Engine".

  "Castle Game Engine" is free software; see the file COPYING.txt,
  included in this distribution, for details about the copyright.

  "Castle Game Engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

  ----------------------------------------------------------------------------
}

{ Automatically generated wrapper to make vectors/colors persistent.

  Do not edit this file manually!
  Instead
  - edit tools/internal/generate-persistent-vectors/persistent_vectors_input.txt
  - and run generate-persistent-vectors in that directory.
}

{$ifdef read_interface_class}
strict private
  FCurrentItemBorderColor2Persistent: TCastleColorPersistent;
  function GetCurrentItemBorderColor2ForPersistent: TCastleColor;
  procedure SetCurrentItemBorderColor2ForPersistent(const AValue: TCastleColor);
published
  { @link(CurrentItemBorderColor2) that can be visually edited in
    Castle Game Engine Editor, Lazarus and Delphi.
    Normal user code does not need to deal with this,
    instead read or write @link(CurrentItemBorderColor2) directly.

    @seealso CurrentItemBorderColor2 }
  property CurrentItemBorderColor2Persistent: TCastleColorPersistent read FCurrentItemBorderColor2Persistent ;
{$endif read_interface_class}

{$ifdef read_implementation_methods}
function TCastleOnScreenMenu.GetCurrentItemBorderColor2ForPersistent: TCastleColor;
begin
  Result := CurrentItemBorderColor2;
end;

procedure TCastleOnScreenMenu.SetCurrentItemBorderColor2ForPersistent(const AValue: TCastleColor);
begin
  CurrentItemBorderColor2 := AValue;
end;
{$endif read_implementation_methods}

{$ifdef read_implementation_constructor}
  FCurrentItemBorderColor2Persistent := TCastleColorPersistent.Create(nil);
  { Note that some classes (like TCastleVector3Persistent) call SetSubComponent(true)
    on themselves, for backward compatibility. But we should not depend on it,
    some classes (like TFloatRectanglePersisten) may not call it.
    The responsibility of calling "SetSubComponent(true)" should be on the owner
    in general (this is more functional, and more standard too). }
  FCurrentItemBorderColor2Persistent.SetSubComponent(true);
  FCurrentItemBorderColor2Persistent.InternalGetValue := {$ifdef FPC}@{$endif}GetCurrentItemBorderColor2ForPersistent;
  FCurrentItemBorderColor2Persistent.InternalSetValue := {$ifdef FPC}@{$endif}SetCurrentItemBorderColor2ForPersistent;
  FCurrentItemBorderColor2Persistent.InternalDefaultValue := CurrentItemBorderColor2; // current value is default
{$endif read_implementation_constructor}

{$ifdef read_implementation_destructor}
  FreeAndNil(FCurrentItemBorderColor2Persistent);
{$endif read_implementation_destructor}

{ -*- buffer-read-only: t -*-

  Copyright 2018-2022 Michalis Kamburelis.

  This file is part of "Castle Game Engine".

  "Castle Game Engine" is free software; see the file COPYING.txt,
  included in this distribution, for details about the copyright.

  "Castle Game Engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

  ----------------------------------------------------------------------------
}

{ Automatically generated wrapper to make vectors/colors persistent.

  Do not edit this file manually!
  Instead
  - edit tools/internal/generate-persistent-vectors/persistent_vectors_input.txt
  - and run generate-persistent-vectors in that directory.
}

{$ifdef read_interface_class}
strict private
  FCurrentItemColorPersistent: TCastleColorPersistent;
  function GetCurrentItemColorForPersistent: TCastleColor;
  procedure SetCurrentItemColorForPersistent(const AValue: TCastleColor);
published
  { @link(CurrentItemColor) that can be visually edited in
    Castle Game Engine Editor, Lazarus and Delphi.
    Normal user code does not need to deal with this,
    instead read or write @link(CurrentItemColor) directly.

    @seealso CurrentItemColor }
  property CurrentItemColorPersistent: TCastleColorPersistent read FCurrentItemColorPersistent ;
{$endif read_interface_class}

{$ifdef read_implementation_methods}
function TCastleOnScreenMenu.GetCurrentItemColorForPersistent: TCastleColor;
begin
  Result := CurrentItemColor;
end;

procedure TCastleOnScreenMenu.SetCurrentItemColorForPersistent(const AValue: TCastleColor);
begin
  CurrentItemColor := AValue;
end;
{$endif read_implementation_methods}

{$ifdef read_implementation_constructor}
  FCurrentItemColorPersistent := TCastleColorPersistent.Create(nil);
  { Note that some classes (like TCastleVector3Persistent) call SetSubComponent(true)
    on themselves, for backward compatibility. But we should not depend on it,
    some classes (like TFloatRectanglePersisten) may not call it.
    The responsibility of calling "SetSubComponent(true)" should be on the owner
    in general (this is more functional, and more standard too). }
  FCurrentItemColorPersistent.SetSubComponent(true);
  FCurrentItemColorPersistent.InternalGetValue := {$ifdef FPC}@{$endif}GetCurrentItemColorForPersistent;
  FCurrentItemColorPersistent.InternalSetValue := {$ifdef FPC}@{$endif}SetCurrentItemColorForPersistent;
  FCurrentItemColorPersistent.InternalDefaultValue := CurrentItemColor; // current value is default
{$endif read_implementation_constructor}

{$ifdef read_implementation_destructor}
  FreeAndNil(FCurrentItemColorPersistent);
{$endif read_implementation_destructor}

{ -*- buffer-read-only: t -*-

  Copyright 2018-2022 Michalis Kamburelis.

  This file is part of "Castle Game Engine".

  "Castle Game Engine" is free software; see the file COPYING.txt,
  included in this distribution, for details about the copyright.

  "Castle Game Engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

  ----------------------------------------------------------------------------
}

{ Automatically generated wrapper to make vectors/colors persistent.

  Do not edit this file manually!
  Instead
  - edit tools/internal/generate-persistent-vectors/persistent_vectors_input.txt
  - and run generate-persistent-vectors in that directory.
}

{$ifdef read_interface_class}
strict private
  FNonCurrentItemColorPersistent: TCastleColorPersistent;
  function GetNonCurrentItemColorForPersistent: TCastleColor;
  procedure SetNonCurrentItemColorForPersistent(const AValue: TCastleColor);
published
  { @link(NonCurrentItemColor) that can be visually edited in
    Castle Game Engine Editor, Lazarus and Delphi.
    Normal user code does not need to deal with this,
    instead read or write @link(NonCurrentItemColor) directly.

    @seealso NonCurrentItemColor }
  property NonCurrentItemColorPersistent: TCastleColorPersistent read FNonCurrentItemColorPersistent ;
{$endif read_interface_class}

{$ifdef read_implementation_methods}
function TCastleOnScreenMenu.GetNonCurrentItemColorForPersistent: TCastleColor;
begin
  Result := NonCurrentItemColor;
end;

procedure TCastleOnScreenMenu.SetNonCurrentItemColorForPersistent(const AValue: TCastleColor);
begin
  NonCurrentItemColor := AValue;
end;
{$endif read_implementation_methods}

{$ifdef read_implementation_constructor}
  FNonCurrentItemColorPersistent := TCastleColorPersistent.Create(nil);
  { Note that some classes (like TCastleVector3Persistent) call SetSubComponent(true)
    on themselves, for backward compatibility. But we should not depend on it,
    some classes (like TFloatRectanglePersisten) may not call it.
    The responsibility of calling "SetSubComponent(true)" should be on the owner
    in general (this is more functional, and more standard too). }
  FNonCurrentItemColorPersistent.SetSubComponent(true);
  FNonCurrentItemColorPersistent.InternalGetValue := {$ifdef FPC}@{$endif}GetNonCurrentItemColorForPersistent;
  FNonCurrentItemColorPersistent.InternalSetValue := {$ifdef FPC}@{$endif}SetNonCurrentItemColorForPersistent;
  FNonCurrentItemColorPersistent.InternalDefaultValue := NonCurrentItemColor; // current value is default
{$endif read_implementation_constructor}

{$ifdef read_implementation_destructor}
  FreeAndNil(FNonCurrentItemColorPersistent);
{$endif read_implementation_destructor}

{ -*- buffer-read-only: t -*-

  Copyright 2018-2022 Michalis Kamburelis.

  This file is part of "Castle Game Engine".

  "Castle Game Engine" is free software; see the file COPYING.txt,
  included in this distribution, for details about the copyright.

  "Castle Game Engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

  ----------------------------------------------------------------------------
}

{ Automatically generated wrapper to make vectors/colors persistent.

  Do not edit this file manually!
  Instead
  - edit tools/internal/generate-persistent-vectors/persistent_vectors_input.txt
  - and run generate-persistent-vectors in that directory.
}

{$ifdef read_interface_class}
strict private
  FNonFocusableItemColorPersistent: TCastleColorPersistent;
  function GetNonFocusableItemColorForPersistent: TCastleColor;
  procedure SetNonFocusableItemColorForPersistent(const AValue: TCastleColor);
published
  { @link(NonFocusableItemColor) that can be visually edited in
    Castle Game Engine Editor, Lazarus and Delphi.
    Normal user code does not need to deal with this,
    instead read or write @link(NonFocusableItemColor) directly.

    @seealso NonFocusableItemColor }
  property NonFocusableItemColorPersistent: TCastleColorPersistent read FNonFocusableItemColorPersistent ;
{$endif read_interface_class}

{$ifdef read_implementation_methods}
function TCastleOnScreenMenu.GetNonFocusableItemColorForPersistent: TCastleColor;
begin
  Result := NonFocusableItemColor;
end;

procedure TCastleOnScreenMenu.SetNonFocusableItemColorForPersistent(const AValue: TCastleColor);
begin
  NonFocusableItemColor := AValue;
end;
{$endif read_implementation_methods}

{$ifdef read_implementation_constructor}
  FNonFocusableItemColorPersistent := TCastleColorPersistent.Create(nil);
  { Note that some classes (like TCastleVector3Persistent) call SetSubComponent(true)
    on themselves, for backward compatibility. But we should not depend on it,
    some classes (like TFloatRectanglePersisten) may not call it.
    The responsibility of calling "SetSubComponent(true)" should be on the owner
    in general (this is more functional, and more standard too). }
  FNonFocusableItemColorPersistent.SetSubComponent(true);
  FNonFocusableItemColorPersistent.InternalGetValue := {$ifdef FPC}@{$endif}GetNonFocusableItemColorForPersistent;
  FNonFocusableItemColorPersistent.InternalSetValue := {$ifdef FPC}@{$endif}SetNonFocusableItemColorForPersistent;
  FNonFocusableItemColorPersistent.InternalDefaultValue := NonFocusableItemColor; // current value is default
{$endif read_implementation_constructor}

{$ifdef read_implementation_destructor}
  FreeAndNil(FNonFocusableItemColorPersistent);
{$endif read_implementation_destructor}

