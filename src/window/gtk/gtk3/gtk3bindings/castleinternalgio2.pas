{ This is an autogenerated unit using gobject introspection (gir2pascal). Do not Edit. }
unit CastleInternalGio2;

{$MODE OBJFPC}{$H+}

{$PACKRECORDS C}
{$MODESWITCH DUPLICATELOCALS+}

{$ifdef Unix}
{$LINKLIB libgio-2.0.so.0}
{$endif}
{$WARN 3031 off : Values in enumeration types have to be ascending}
interface
uses
  CTypes, CastleInternalGObject2, CastleInternalGlib2;

const
  {$ifdef MsWindows}
  LazGio2_library = 'libgio-2.0.so.dll';
  {$else}
  LazGio2_library = 'libgio-2.0.so.0';
  {$endif}

  G_DBUS_METHOD_INVOCATION_HANDLED = true;
  G_DBUS_METHOD_INVOCATION_UNHANDLED = false;
  G_DEBUG_CONTROLLER_EXTENSION_POINT_NAME = 'gio-debug-controller';
  G_DESKTOP_APP_INFO_LOOKUP_EXTENSION_POINT_NAME = 'gio-desktop-app-info-lookup';
  G_DRIVE_IDENTIFIER_KIND_UNIX_DEVICE = 'unix-device';
  G_FILE_ATTRIBUTE_ACCESS_CAN_DELETE = 'access::can-delete';
  G_FILE_ATTRIBUTE_ACCESS_CAN_EXECUTE = 'access::can-execute';
  G_FILE_ATTRIBUTE_ACCESS_CAN_READ = 'access::can-read';
  G_FILE_ATTRIBUTE_ACCESS_CAN_RENAME = 'access::can-rename';
  G_FILE_ATTRIBUTE_ACCESS_CAN_TRASH = 'access::can-trash';
  G_FILE_ATTRIBUTE_ACCESS_CAN_WRITE = 'access::can-write';
  G_FILE_ATTRIBUTE_DOS_IS_ARCHIVE = 'dos::is-archive';
  G_FILE_ATTRIBUTE_DOS_IS_MOUNTPOINT = 'dos::is-mountpoint';
  G_FILE_ATTRIBUTE_DOS_IS_SYSTEM = 'dos::is-system';
  G_FILE_ATTRIBUTE_DOS_REPARSE_POINT_TAG = 'dos::reparse-point-tag';
  G_FILE_ATTRIBUTE_ETAG_VALUE = 'etag::value';
  G_FILE_ATTRIBUTE_FILESYSTEM_FREE = 'filesystem::free';
  G_FILE_ATTRIBUTE_FILESYSTEM_READONLY = 'filesystem::readonly';
  G_FILE_ATTRIBUTE_FILESYSTEM_REMOTE = 'filesystem::remote';
  G_FILE_ATTRIBUTE_FILESYSTEM_SIZE = 'filesystem::size';
  G_FILE_ATTRIBUTE_FILESYSTEM_TYPE = 'filesystem::type';
  G_FILE_ATTRIBUTE_FILESYSTEM_USED = 'filesystem::used';
  G_FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW = 'filesystem::use-preview';
  G_FILE_ATTRIBUTE_GVFS_BACKEND = 'gvfs::backend';
  G_FILE_ATTRIBUTE_ID_FILE = 'id::file';
  G_FILE_ATTRIBUTE_ID_FILESYSTEM = 'id::filesystem';
  G_FILE_ATTRIBUTE_MOUNTABLE_CAN_EJECT = 'mountable::can-eject';
  G_FILE_ATTRIBUTE_MOUNTABLE_CAN_MOUNT = 'mountable::can-mount';
  G_FILE_ATTRIBUTE_MOUNTABLE_CAN_POLL = 'mountable::can-poll';
  G_FILE_ATTRIBUTE_MOUNTABLE_CAN_START = 'mountable::can-start';
  G_FILE_ATTRIBUTE_MOUNTABLE_CAN_START_DEGRADED = 'mountable::can-start-degraded';
  G_FILE_ATTRIBUTE_MOUNTABLE_CAN_STOP = 'mountable::can-stop';
  G_FILE_ATTRIBUTE_MOUNTABLE_CAN_UNMOUNT = 'mountable::can-unmount';
  G_FILE_ATTRIBUTE_MOUNTABLE_HAL_UDI = 'mountable::hal-udi';
  G_FILE_ATTRIBUTE_MOUNTABLE_IS_MEDIA_CHECK_AUTOMATIC = 'mountable::is-media-check-automatic';
  G_FILE_ATTRIBUTE_MOUNTABLE_START_STOP_TYPE = 'mountable::start-stop-type';
  G_FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE = 'mountable::unix-device';
  G_FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE_FILE = 'mountable::unix-device-file';
  G_FILE_ATTRIBUTE_OWNER_GROUP = 'owner::group';
  G_FILE_ATTRIBUTE_OWNER_USER = 'owner::user';
  G_FILE_ATTRIBUTE_OWNER_USER_REAL = 'owner::user-real';
  G_FILE_ATTRIBUTE_PREVIEW_ICON = 'preview::icon';
  G_FILE_ATTRIBUTE_RECENT_MODIFIED = 'recent::modified';
  G_FILE_ATTRIBUTE_SELINUX_CONTEXT = 'selinux::context';
  G_FILE_ATTRIBUTE_STANDARD_ALLOCATED_SIZE = 'standard::allocated-size';
  G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE = 'standard::content-type';
  G_FILE_ATTRIBUTE_STANDARD_COPY_NAME = 'standard::copy-name';
  G_FILE_ATTRIBUTE_STANDARD_DESCRIPTION = 'standard::description';
  G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME = 'standard::display-name';
  G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME = 'standard::edit-name';
  G_FILE_ATTRIBUTE_STANDARD_FAST_CONTENT_TYPE = 'standard::fast-content-type';
  G_FILE_ATTRIBUTE_STANDARD_ICON = 'standard::icon';
  G_FILE_ATTRIBUTE_STANDARD_IS_BACKUP = 'standard::is-backup';
  G_FILE_ATTRIBUTE_STANDARD_IS_HIDDEN = 'standard::is-hidden';
  G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK = 'standard::is-symlink';
  G_FILE_ATTRIBUTE_STANDARD_IS_VIRTUAL = 'standard::is-virtual';
  G_FILE_ATTRIBUTE_STANDARD_IS_VOLATILE = 'standard::is-volatile';
  G_FILE_ATTRIBUTE_STANDARD_NAME = 'standard::name';
  G_FILE_ATTRIBUTE_STANDARD_SIZE = 'standard::size';
  G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER = 'standard::sort-order';
  G_FILE_ATTRIBUTE_STANDARD_SYMBOLIC_ICON = 'standard::symbolic-icon';
  G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET = 'standard::symlink-target';
  G_FILE_ATTRIBUTE_STANDARD_TARGET_URI = 'standard::target-uri';
  G_FILE_ATTRIBUTE_STANDARD_TYPE = 'standard::type';
  G_FILE_ATTRIBUTE_THUMBNAILING_FAILED = 'thumbnail::failed';
  G_FILE_ATTRIBUTE_THUMBNAIL_IS_VALID = 'thumbnail::is-valid';
  G_FILE_ATTRIBUTE_THUMBNAIL_PATH = 'thumbnail::path';
  G_FILE_ATTRIBUTE_TIME_ACCESS = 'time::access';
  G_FILE_ATTRIBUTE_TIME_ACCESS_NSEC = 'time::access-nsec';
  G_FILE_ATTRIBUTE_TIME_ACCESS_USEC = 'time::access-usec';
  G_FILE_ATTRIBUTE_TIME_CHANGED = 'time::changed';
  G_FILE_ATTRIBUTE_TIME_CHANGED_NSEC = 'time::changed-nsec';
  G_FILE_ATTRIBUTE_TIME_CHANGED_USEC = 'time::changed-usec';
  G_FILE_ATTRIBUTE_TIME_CREATED = 'time::created';
  G_FILE_ATTRIBUTE_TIME_CREATED_NSEC = 'time::created-nsec';
  G_FILE_ATTRIBUTE_TIME_CREATED_USEC = 'time::created-usec';
  G_FILE_ATTRIBUTE_TIME_MODIFIED = 'time::modified';
  G_FILE_ATTRIBUTE_TIME_MODIFIED_NSEC = 'time::modified-nsec';
  G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC = 'time::modified-usec';
  G_FILE_ATTRIBUTE_TRASH_DELETION_DATE = 'trash::deletion-date';
  G_FILE_ATTRIBUTE_TRASH_ITEM_COUNT = 'trash::item-count';
  G_FILE_ATTRIBUTE_TRASH_ORIG_PATH = 'trash::orig-path';
  G_FILE_ATTRIBUTE_UNIX_BLOCKS = 'unix::blocks';
  G_FILE_ATTRIBUTE_UNIX_BLOCK_SIZE = 'unix::block-size';
  G_FILE_ATTRIBUTE_UNIX_DEVICE = 'unix::device';
  G_FILE_ATTRIBUTE_UNIX_GID = 'unix::gid';
  G_FILE_ATTRIBUTE_UNIX_INODE = 'unix::inode';
  G_FILE_ATTRIBUTE_UNIX_IS_MOUNTPOINT = 'unix::is-mountpoint';
  G_FILE_ATTRIBUTE_UNIX_MODE = 'unix::mode';
  G_FILE_ATTRIBUTE_UNIX_NLINK = 'unix::nlink';
  G_FILE_ATTRIBUTE_UNIX_RDEV = 'unix::rdev';
  G_FILE_ATTRIBUTE_UNIX_UID = 'unix::uid';
  G_MEMORY_MONITOR_EXTENSION_POINT_NAME = 'gio-memory-monitor';
  G_MENU_ATTRIBUTE_ACTION = 'action';
  G_MENU_ATTRIBUTE_ACTION_NAMESPACE = 'action-namespace';
  G_MENU_ATTRIBUTE_ICON = 'icon';
  G_MENU_ATTRIBUTE_LABEL = 'label';
  G_MENU_ATTRIBUTE_TARGET = 'target';
  G_MENU_LINK_SECTION = 'section';
  G_MENU_LINK_SUBMENU = 'submenu';
  G_NATIVE_VOLUME_MONITOR_EXTENSION_POINT_NAME = 'gio-native-volume-monitor';
  G_NETWORK_MONITOR_EXTENSION_POINT_NAME = 'gio-network-monitor';
  G_POWER_PROFILE_MONITOR_EXTENSION_POINT_NAME = 'gio-power-profile-monitor';
  G_PROXY_EXTENSION_POINT_NAME = 'gio-proxy';
  G_PROXY_RESOLVER_EXTENSION_POINT_NAME = 'gio-proxy-resolver';
  G_SETTINGS_BACKEND_EXTENSION_POINT_NAME = 'gsettings-backend';
  G_TLS_BACKEND_EXTENSION_POINT_NAME = 'gio-tls-backend';
  G_TLS_DATABASE_PURPOSE_AUTHENTICATE_CLIENT = '1.3.6.1.5.5.7.3.2';
  G_TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER = '1.3.6.1.5.5.7.3.1';
  G_VFS_EXTENSION_POINT_NAME = 'gio-vfs';
  G_VOLUME_IDENTIFIER_KIND_CLASS = 'class';
  G_VOLUME_IDENTIFIER_KIND_HAL_UDI = 'hal-udi';
  G_VOLUME_IDENTIFIER_KIND_LABEL = 'label';
  G_VOLUME_IDENTIFIER_KIND_NFS_MOUNT = 'nfs-mount';
  G_VOLUME_IDENTIFIER_KIND_UNIX_DEVICE = 'unix-device';
  G_VOLUME_IDENTIFIER_KIND_UUID = 'uuid';
  G_VOLUME_MONITOR_EXTENSION_POINT_NAME = 'gio-volume-monitor';
type
  TGAppInfoCreateFlagsIdx = (
    TGAppInfoCreateFlagsIdxMinValue = 0,
    G_APP_INFO_CREATE_NEEDS_TERMINAL = 0,
    G_APP_INFO_CREATE_SUPPORTS_URIS = 1,
    G_APP_INFO_CREATE_SUPPORTS_STARTUP_NOTIFICATION = 2,
    TGAppInfoCreateFlagsIdxMaxValue = 31
  );
  TGAppInfoCreateFlags = Set of TGAppInfoCreateFlagsIdx;
const
  G_APP_INFO_CREATE_NONE = []; {0 = $00000000}

type
  TGApplicationFlagsIdx = (
    TGApplicationFlagsIdxMinValue = 0,
    G_APPLICATION_IS_SERVICE = 0,
    G_APPLICATION_IS_LAUNCHER = 1,
    G_APPLICATION_HANDLES_OPEN = 2,
    G_APPLICATION_HANDLES_COMMAND_LINE = 3,
    G_APPLICATION_SEND_ENVIRONMENT = 4,
    G_APPLICATION_NON_UNIQUE = 5,
    G_APPLICATION_CAN_OVERRIDE_APP_ID = 6,
    G_APPLICATION_ALLOW_REPLACEMENT = 7,
    G_APPLICATION_REPLACE = 8,
    TGApplicationFlagsIdxMaxValue = 31
  );
  TGApplicationFlags = Set of TGApplicationFlagsIdx;
const
  G_APPLICATION_DEFAULT_FLAGS = []; {0 = $00000000}

  G_APPLICATION_FLAGS_NONE = []; {0 = $00000000}

type
  TGDBusConnectionFlagsIdx = (
    TGDBusConnectionFlagsIdxMinValue = 0,
    G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT = 0,
    G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER = 1,
    G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS = 2,
    G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION = 3,
    G_DBUS_CONNECTION_FLAGS_DELAY_MESSAGE_PROCESSING = 4,
    G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER = 5,
    G_DBUS_CONNECTION_FLAGS_CROSS_NAMESPACE = 6,
    TGDBusConnectionFlagsIdxMaxValue = 31
  );
  TGDBusConnectionFlags = Set of TGDBusConnectionFlagsIdx;
const
  G_DBUS_CONNECTION_FLAGS_NONE = []; {0 = $00000000}

type
  TGDBusCallFlagsIdx = (
    TGDBusCallFlagsIdxMinValue = 0,
    G_DBUS_CALL_FLAGS_NO_AUTO_START = 0,
    G_DBUS_CALL_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION = 1,
    TGDBusCallFlagsIdxMaxValue = 31
  );
  TGDBusCallFlags = Set of TGDBusCallFlagsIdx;
const
  G_DBUS_CALL_FLAGS_NONE = []; {0 = $00000000}

type
  TGDBusCapabilityFlagsIdx = (
    TGDBusCapabilityFlagsIdxMinValue = 0,
    G_DBUS_CAPABILITY_FLAGS_UNIX_FD_PASSING = 0,
    TGDBusCapabilityFlagsIdxMaxValue = 31
  );
  TGDBusCapabilityFlags = Set of TGDBusCapabilityFlagsIdx;
const
  G_DBUS_CAPABILITY_FLAGS_NONE = []; {0 = $00000000}

type
  TGDBusSubtreeFlagsIdx = (
    TGDBusSubtreeFlagsIdxMinValue = 0,
    G_DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES = 0,
    TGDBusSubtreeFlagsIdxMaxValue = 31
  );
  TGDBusSubtreeFlags = Set of TGDBusSubtreeFlagsIdx;
const
  G_DBUS_SUBTREE_FLAGS_NONE = []; {0 = $00000000}

type
  TGDBusSendMessageFlagsIdx = (
    TGDBusSendMessageFlagsIdxMinValue = 0,
    G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL = 0,
    TGDBusSendMessageFlagsIdxMaxValue = 31
  );
  TGDBusSendMessageFlags = Set of TGDBusSendMessageFlagsIdx;
const
  G_DBUS_SEND_MESSAGE_FLAGS_NONE = []; {0 = $00000000}

type
  TGDBusSignalFlagsIdx = (
    TGDBusSignalFlagsIdxMinValue = 0,
    G_DBUS_SIGNAL_FLAGS_NO_MATCH_RULE = 0,
    G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_NAMESPACE = 1,
    G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_PATH = 2,
    TGDBusSignalFlagsIdxMaxValue = 31
  );
  TGDBusSignalFlags = Set of TGDBusSignalFlagsIdx;
const
  G_DBUS_SIGNAL_FLAGS_NONE = []; {0 = $00000000}

type
  TGFileCreateFlagsIdx = (
    TGFileCreateFlagsIdxMinValue = 0,
    G_FILE_CREATE_PRIVATE = 0,
    G_FILE_CREATE_REPLACE_DESTINATION = 1,
    TGFileCreateFlagsIdxMaxValue = 31
  );
  TGFileCreateFlags = Set of TGFileCreateFlagsIdx;
const
  G_FILE_CREATE_NONE = []; {0 = $00000000}

type
  TGFileCopyFlagsIdx = (
    TGFileCopyFlagsIdxMinValue = 0,
    G_FILE_COPY_OVERWRITE = 0,
    G_FILE_COPY_BACKUP = 1,
    G_FILE_COPY_NOFOLLOW_SYMLINKS = 2,
    G_FILE_COPY_ALL_METADATA = 3,
    G_FILE_COPY_NO_FALLBACK_FOR_MOVE = 4,
    G_FILE_COPY_TARGET_DEFAULT_PERMS = 5,
    TGFileCopyFlagsIdxMaxValue = 31
  );
  TGFileCopyFlags = Set of TGFileCopyFlagsIdx;
const
  G_FILE_COPY_NONE = []; {0 = $00000000}

type
  TGMountUnmountFlagsIdx = (
    TGMountUnmountFlagsIdxMinValue = 0,
    G_MOUNT_UNMOUNT_FORCE = 0,
    TGMountUnmountFlagsIdxMaxValue = 31
  );
  TGMountUnmountFlags = Set of TGMountUnmountFlagsIdx;
const
  G_MOUNT_UNMOUNT_NONE = []; {0 = $00000000}

type
  TGFileQueryInfoFlagsIdx = (
    TGFileQueryInfoFlagsIdxMinValue = 0,
    G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS = 0,
    TGFileQueryInfoFlagsIdxMaxValue = 31
  );
  TGFileQueryInfoFlags = Set of TGFileQueryInfoFlagsIdx;
const
  G_FILE_QUERY_INFO_NONE = []; {0 = $00000000}

type
  TGFileMeasureFlagsIdx = (
    TGFileMeasureFlagsIdxMinValue = 0,
    G_FILE_MEASURE_REPORT_ANY_ERROR = 1,
    G_FILE_MEASURE_APPARENT_SIZE = 2,
    G_FILE_MEASURE_NO_XDEV = 3,
    TGFileMeasureFlagsIdxMaxValue = 31
  );
  TGFileMeasureFlags = Set of TGFileMeasureFlagsIdx;
const
  G_FILE_MEASURE_NONE = []; {0 = $00000000}

type
  TGFileMonitorFlagsIdx = (
    TGFileMonitorFlagsIdxMinValue = 0,
    G_FILE_MONITOR_WATCH_MOUNTS = 0,
    G_FILE_MONITOR_SEND_MOVED = 1,
    G_FILE_MONITOR_WATCH_HARD_LINKS = 2,
    G_FILE_MONITOR_WATCH_MOVES = 3,
    TGFileMonitorFlagsIdxMaxValue = 31
  );
  TGFileMonitorFlags = Set of TGFileMonitorFlagsIdx;
const
  G_FILE_MONITOR_NONE = []; {0 = $00000000}

type
  TGMountMountFlagsIdx = (
    TGMountMountFlagsIdxMinValue = 0,
    TGMountMountFlagsIdxMaxValue = 31
  );
  TGMountMountFlags = Set of TGMountMountFlagsIdx;
const
  G_MOUNT_MOUNT_NONE = []; {0 = $00000000}

type
  TGFileAttributeType = (
    TGFileAttributeTypeMinValue = -$7FFFFFFF,
    G_FILE_ATTRIBUTE_TYPE_INVALID = 0,
    G_FILE_ATTRIBUTE_TYPE_STRING = 1,
    G_FILE_ATTRIBUTE_TYPE_BYTE_STRING = 2,
    G_FILE_ATTRIBUTE_TYPE_BOOLEAN = 3,
    G_FILE_ATTRIBUTE_TYPE_UINT32 = 4,
    G_FILE_ATTRIBUTE_TYPE_INT32 = 5,
    G_FILE_ATTRIBUTE_TYPE_UINT64 = 6,
    G_FILE_ATTRIBUTE_TYPE_INT64 = 7,
    G_FILE_ATTRIBUTE_TYPE_OBJECT = 8,
    G_FILE_ATTRIBUTE_TYPE_STRINGV = 9,
    TGFileAttributeTypeMaxValue = $7FFFFFFF
  );
  TGDriveStartFlagsIdx = (
    TGDriveStartFlagsIdxMinValue = 0,
    TGDriveStartFlagsIdxMaxValue = 31
  );
  TGDriveStartFlags = Set of TGDriveStartFlagsIdx;
const
  G_DRIVE_START_NONE = []; {0 = $00000000}

type
  TGNotificationPriority = (
    TGNotificationPriorityMinValue = -$7FFFFFFF,
    G_NOTIFICATION_PRIORITY_NORMAL = 0,
    G_NOTIFICATION_PRIORITY_LOW = 1,
    G_NOTIFICATION_PRIORITY_HIGH = 2,
    G_NOTIFICATION_PRIORITY_URGENT = 3,
    TGNotificationPriorityMaxValue = $7FFFFFFF
  );
  TGAskPasswordFlagsIdx = (
    TGAskPasswordFlagsIdxMinValue = 0,
    G_ASK_PASSWORD_NEED_PASSWORD = 0,
    G_ASK_PASSWORD_NEED_USERNAME = 1,
    G_ASK_PASSWORD_NEED_DOMAIN = 2,
    G_ASK_PASSWORD_SAVING_SUPPORTED = 3,
    G_ASK_PASSWORD_ANONYMOUS_SUPPORTED = 4,
    G_ASK_PASSWORD_TCRYPT = 5,
    TGAskPasswordFlagsIdxMaxValue = 31
  );
  TGAskPasswordFlags = Set of TGAskPasswordFlagsIdx;
  TGOutputStreamSpliceFlagsIdx = (
    TGOutputStreamSpliceFlagsIdxMinValue = 0,
    G_OUTPUT_STREAM_SPLICE_CLOSE_SOURCE = 0,
    G_OUTPUT_STREAM_SPLICE_CLOSE_TARGET = 1,
    TGOutputStreamSpliceFlagsIdxMaxValue = 31
  );
  TGOutputStreamSpliceFlags = Set of TGOutputStreamSpliceFlagsIdx;
const
  G_OUTPUT_STREAM_SPLICE_NONE = []; {0 = $00000000}

type
  TGBusNameOwnerFlagsIdx = (
    TGBusNameOwnerFlagsIdxMinValue = 0,
    G_BUS_NAME_OWNER_FLAGS_ALLOW_REPLACEMENT = 0,
    G_BUS_NAME_OWNER_FLAGS_REPLACE = 1,
    G_BUS_NAME_OWNER_FLAGS_DO_NOT_QUEUE = 2,
    TGBusNameOwnerFlagsIdxMaxValue = 31
  );
  TGBusNameOwnerFlags = Set of TGBusNameOwnerFlagsIdx;
const
  G_BUS_NAME_OWNER_FLAGS_NONE = []; {0 = $00000000}

type
  TGBusNameWatcherFlagsIdx = (
    TGBusNameWatcherFlagsIdxMinValue = 0,
    G_BUS_NAME_WATCHER_FLAGS_AUTO_START = 0,
    TGBusNameWatcherFlagsIdxMaxValue = 31
  );
  TGBusNameWatcherFlags = Set of TGBusNameWatcherFlagsIdx;
const
  G_BUS_NAME_WATCHER_FLAGS_NONE = []; {0 = $00000000}

type
  TGBusType = (
    TGBusTypeMinValue = -$7FFFFFFF,
    G_BUS_TYPE_STARTER = -1,
    G_BUS_TYPE_NONE = 0,
    G_BUS_TYPE_SYSTEM = 1,
    G_BUS_TYPE_SESSION = 2,
    TGBusTypeMaxValue = $7FFFFFFF
  );
  TGConverterFlagsIdx = (
    TGConverterFlagsIdxMinValue = 0,
    G_CONVERTER_INPUT_AT_END = 0,
    G_CONVERTER_FLUSH = 1,
    TGConverterFlagsIdxMaxValue = 31
  );
  TGConverterFlags = Set of TGConverterFlagsIdx;
const
  G_CONVERTER_NO_FLAGS = []; {0 = $00000000}

type
  TGConverterResult = (
    TGConverterResultMinValue = -$7FFFFFFF,
    G_CONVERTER_ERROR = 0,
    G_CONVERTER_CONVERTED = 1,
    G_CONVERTER_FINISHED = 2,
    G_CONVERTER_FLUSHED = 3,
    TGConverterResultMaxValue = $7FFFFFFF
  );
  TGCredentialsType = (
    TGCredentialsTypeMinValue = -$7FFFFFFF,
    G_CREDENTIALS_TYPE_INVALID = 0,
    G_CREDENTIALS_TYPE_LINUX_UCRED = 1,
    G_CREDENTIALS_TYPE_FREEBSD_CMSGCRED = 2,
    G_CREDENTIALS_TYPE_OPENBSD_SOCKPEERCRED = 3,
    G_CREDENTIALS_TYPE_SOLARIS_UCRED = 4,
    G_CREDENTIALS_TYPE_NETBSD_UNPCBID = 5,
    G_CREDENTIALS_TYPE_APPLE_XUCRED = 6,
    G_CREDENTIALS_TYPE_WIN32_PID = 7,
    TGCredentialsTypeMaxValue = $7FFFFFFF
  );
  TGIOStreamSpliceFlagsIdx = (
    TGIOStreamSpliceFlagsIdxMinValue = 0,
    G_IO_STREAM_SPLICE_CLOSE_STREAM1 = 0,
    G_IO_STREAM_SPLICE_CLOSE_STREAM2 = 1,
    G_IO_STREAM_SPLICE_WAIT_FOR_BOTH = 2,
    TGIOStreamSpliceFlagsIdxMaxValue = 31
  );
  TGIOStreamSpliceFlags = Set of TGIOStreamSpliceFlagsIdx;
const
  G_IO_STREAM_SPLICE_NONE = []; {0 = $00000000}

type
  TGDBusMessageFlagsIdx = (
    TGDBusMessageFlagsIdxMinValue = 0,
    G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED = 0,
    G_DBUS_MESSAGE_FLAGS_NO_AUTO_START = 1,
    G_DBUS_MESSAGE_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION = 2,
    TGDBusMessageFlagsIdxMaxValue = 31
  );
  TGDBusMessageFlags = Set of TGDBusMessageFlagsIdx;
const
  G_DBUS_MESSAGE_FLAGS_NONE = []; {0 = $00000000}

type
  TGDBusMessageHeaderField = (
    TGDBusMessageHeaderFieldMinValue = -$7FFFFFFF,
    G_DBUS_MESSAGE_HEADER_FIELD_INVALID = 0,
    G_DBUS_MESSAGE_HEADER_FIELD_PATH = 1,
    G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE = 2,
    G_DBUS_MESSAGE_HEADER_FIELD_MEMBER = 3,
    G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME = 4,
    G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL = 5,
    G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION = 6,
    G_DBUS_MESSAGE_HEADER_FIELD_SENDER = 7,
    G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE = 8,
    G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS = 9,
    TGDBusMessageHeaderFieldMaxValue = $7FFFFFFF
  );
  TGDBusMessageByteOrder = (
    TGDBusMessageByteOrderMinValue = -$7FFFFFFF,
    G_DBUS_MESSAGE_BYTE_ORDER_BIG_ENDIAN = 66,
    G_DBUS_MESSAGE_BYTE_ORDER_LITTLE_ENDIAN = 108,
    TGDBusMessageByteOrderMaxValue = $7FFFFFFF
  );
  TGDBusMessageType = (
    TGDBusMessageTypeMinValue = -$7FFFFFFF,
    G_DBUS_MESSAGE_TYPE_INVALID = 0,
    G_DBUS_MESSAGE_TYPE_METHOD_CALL = 1,
    G_DBUS_MESSAGE_TYPE_METHOD_RETURN = 2,
    G_DBUS_MESSAGE_TYPE_ERROR = 3,
    G_DBUS_MESSAGE_TYPE_SIGNAL = 4,
    TGDBusMessageTypeMaxValue = $7FFFFFFF
  );
  TGDBusError = (
    TGDBusErrorMinValue = -$7FFFFFFF,
    G_DBUS_ERROR_FAILED = 0,
    G_DBUS_ERROR_NO_MEMORY = 1,
    G_DBUS_ERROR_SERVICE_UNKNOWN = 2,
    G_DBUS_ERROR_NAME_HAS_NO_OWNER = 3,
    G_DBUS_ERROR_NO_REPLY = 4,
    G_DBUS_ERROR_IO_ERROR = 5,
    G_DBUS_ERROR_BAD_ADDRESS = 6,
    G_DBUS_ERROR_NOT_SUPPORTED = 7,
    G_DBUS_ERROR_LIMITS_EXCEEDED = 8,
    G_DBUS_ERROR_ACCESS_DENIED = 9,
    G_DBUS_ERROR_AUTH_FAILED = 10,
    G_DBUS_ERROR_NO_SERVER = 11,
    G_DBUS_ERROR_TIMEOUT = 12,
    G_DBUS_ERROR_NO_NETWORK = 13,
    G_DBUS_ERROR_ADDRESS_IN_USE = 14,
    G_DBUS_ERROR_DISCONNECTED = 15,
    G_DBUS_ERROR_INVALID_ARGS = 16,
    G_DBUS_ERROR_FILE_NOT_FOUND = 17,
    G_DBUS_ERROR_FILE_EXISTS = 18,
    G_DBUS_ERROR_UNKNOWN_METHOD = 19,
    G_DBUS_ERROR_TIMED_OUT = 20,
    G_DBUS_ERROR_MATCH_RULE_NOT_FOUND = 21,
    G_DBUS_ERROR_MATCH_RULE_INVALID = 22,
    G_DBUS_ERROR_SPAWN_EXEC_FAILED = 23,
    G_DBUS_ERROR_SPAWN_FORK_FAILED = 24,
    G_DBUS_ERROR_SPAWN_CHILD_EXITED = 25,
    G_DBUS_ERROR_SPAWN_CHILD_SIGNALED = 26,
    G_DBUS_ERROR_SPAWN_FAILED = 27,
    G_DBUS_ERROR_SPAWN_SETUP_FAILED = 28,
    G_DBUS_ERROR_SPAWN_CONFIG_INVALID = 29,
    G_DBUS_ERROR_SPAWN_SERVICE_INVALID = 30,
    G_DBUS_ERROR_SPAWN_SERVICE_NOT_FOUND = 31,
    G_DBUS_ERROR_SPAWN_PERMISSIONS_INVALID = 32,
    G_DBUS_ERROR_SPAWN_FILE_INVALID = 33,
    G_DBUS_ERROR_SPAWN_NO_MEMORY = 34,
    G_DBUS_ERROR_UNIX_PROCESS_ID_UNKNOWN = 35,
    G_DBUS_ERROR_INVALID_SIGNATURE = 36,
    G_DBUS_ERROR_INVALID_FILE_CONTENT = 37,
    G_DBUS_ERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN = 38,
    G_DBUS_ERROR_ADT_AUDIT_DATA_UNKNOWN = 39,
    G_DBUS_ERROR_OBJECT_PATH_IN_USE = 40,
    G_DBUS_ERROR_UNKNOWN_OBJECT = 41,
    G_DBUS_ERROR_UNKNOWN_INTERFACE = 42,
    G_DBUS_ERROR_UNKNOWN_PROPERTY = 43,
    G_DBUS_ERROR_PROPERTY_READ_ONLY = 44,
    TGDBusErrorMaxValue = $7FFFFFFF
  );
  TGDBusPropertyInfoFlagsIdx = (
    TGDBusPropertyInfoFlagsIdxMinValue = 0,
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE = 0,
    G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE = 1,
    TGDBusPropertyInfoFlagsIdxMaxValue = 31
  );
  TGDBusPropertyInfoFlags = Set of TGDBusPropertyInfoFlagsIdx;
const
  G_DBUS_PROPERTY_INFO_FLAGS_NONE = []; {0 = $00000000}

type
  TGDBusInterfaceSkeletonFlagsIdx = (
    TGDBusInterfaceSkeletonFlagsIdxMinValue = 0,
    G_DBUS_INTERFACE_SKELETON_FLAGS_HANDLE_METHOD_INVOCATIONS_IN_THREAD = 0,
    TGDBusInterfaceSkeletonFlagsIdxMaxValue = 31
  );
  TGDBusInterfaceSkeletonFlags = Set of TGDBusInterfaceSkeletonFlagsIdx;
const
  G_DBUS_INTERFACE_SKELETON_FLAGS_NONE = []; {0 = $00000000}

type
  TGDBusObjectManagerClientFlagsIdx = (
    TGDBusObjectManagerClientFlagsIdxMinValue = 0,
    G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_DO_NOT_AUTO_START = 0,
    TGDBusObjectManagerClientFlagsIdxMaxValue = 31
  );
  TGDBusObjectManagerClientFlags = Set of TGDBusObjectManagerClientFlagsIdx;
const
  G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE = []; {0 = $00000000}

type
  TGDBusProxyFlagsIdx = (
    TGDBusProxyFlagsIdxMinValue = 0,
    G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES = 0,
    G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS = 1,
    G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START = 2,
    G_DBUS_PROXY_FLAGS_GET_INVALIDATED_PROPERTIES = 3,
    G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION = 4,
    G_DBUS_PROXY_FLAGS_NO_MATCH_RULE = 5,
    TGDBusProxyFlagsIdxMaxValue = 31
  );
  TGDBusProxyFlags = Set of TGDBusProxyFlagsIdx;
const
  G_DBUS_PROXY_FLAGS_NONE = []; {0 = $00000000}

type
  TGDBusServerFlagsIdx = (
    TGDBusServerFlagsIdxMinValue = 0,
    G_DBUS_SERVER_FLAGS_RUN_IN_THREAD = 0,
    G_DBUS_SERVER_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS = 1,
    G_DBUS_SERVER_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER = 2,
    TGDBusServerFlagsIdxMaxValue = 31
  );
  TGDBusServerFlags = Set of TGDBusServerFlagsIdx;
const
  G_DBUS_SERVER_FLAGS_NONE = []; {0 = $00000000}

type
  TGDataStreamByteOrder = (
    TGDataStreamByteOrderMinValue = -$7FFFFFFF,
    G_DATA_STREAM_BYTE_ORDER_BIG_ENDIAN = 0,
    G_DATA_STREAM_BYTE_ORDER_LITTLE_ENDIAN = 1,
    G_DATA_STREAM_BYTE_ORDER_HOST_ENDIAN = 2,
    TGDataStreamByteOrderMaxValue = $7FFFFFFF
  );
  TGDataStreamNewlineType = (
    TGDataStreamNewlineTypeMinValue = -$7FFFFFFF,
    G_DATA_STREAM_NEWLINE_TYPE_LF = 0,
    G_DATA_STREAM_NEWLINE_TYPE_CR = 1,
    G_DATA_STREAM_NEWLINE_TYPE_CR_LF = 2,
    G_DATA_STREAM_NEWLINE_TYPE_ANY = 3,
    TGDataStreamNewlineTypeMaxValue = $7FFFFFFF
  );
  TGMountOperationResult = (
    TGMountOperationResultMinValue = -$7FFFFFFF,
    G_MOUNT_OPERATION_HANDLED = 0,
    G_MOUNT_OPERATION_ABORTED = 1,
    G_MOUNT_OPERATION_UNHANDLED = 2,
    TGMountOperationResultMaxValue = $7FFFFFFF
  );
  TGPasswordSave = (
    TGPasswordSaveMinValue = -$7FFFFFFF,
    G_PASSWORD_SAVE_NEVER = 0,
    G_PASSWORD_SAVE_FOR_SESSION = 1,
    G_PASSWORD_SAVE_PERMANENTLY = 2,
    TGPasswordSaveMaxValue = $7FFFFFFF
  );
  TGDriveStartStopType = (
    TGDriveStartStopTypeMinValue = -$7FFFFFFF,
    G_DRIVE_START_STOP_TYPE_UNKNOWN = 0,
    G_DRIVE_START_STOP_TYPE_SHUTDOWN = 1,
    G_DRIVE_START_STOP_TYPE_NETWORK = 2,
    G_DRIVE_START_STOP_TYPE_MULTIDISK = 3,
    G_DRIVE_START_STOP_TYPE_PASSWORD = 4,
    TGDriveStartStopTypeMaxValue = $7FFFFFFF
  );
  TGTlsCertificateFlagsIdx = (
    TGTlsCertificateFlagsIdxMinValue = 0,
    G_TLS_CERTIFICATE_UNKNOWN_CA = 0,
    G_TLS_CERTIFICATE_BAD_IDENTITY = 1,
    G_TLS_CERTIFICATE_NOT_ACTIVATED = 2,
    G_TLS_CERTIFICATE_EXPIRED = 3,
    G_TLS_CERTIFICATE_REVOKED = 4,
    G_TLS_CERTIFICATE_INSECURE = 5,
    G_TLS_CERTIFICATE_GENERIC_ERROR = 6,
    TGTlsCertificateFlagsIdxMaxValue = 31
  );
  TGTlsCertificateFlags = Set of TGTlsCertificateFlagsIdx;
const
  G_TLS_CERTIFICATE_NO_FLAGS = []; {0 = $00000000}

  G_TLS_CERTIFICATE_VALIDATE_ALL = [
    G_TLS_CERTIFICATE_UNKNOWN_CA,
    G_TLS_CERTIFICATE_BAD_IDENTITY,
    G_TLS_CERTIFICATE_NOT_ACTIVATED,
    G_TLS_CERTIFICATE_EXPIRED,
    G_TLS_CERTIFICATE_REVOKED,
    G_TLS_CERTIFICATE_INSECURE,
    G_TLS_CERTIFICATE_GENERIC_ERROR
  ]; {127 = $0000007F}

type
  TGTlsChannelBindingType = (
    TGTlsChannelBindingTypeMinValue = -$7FFFFFFF,
    G_TLS_CHANNEL_BINDING_TLS_UNIQUE = 0,
    G_TLS_CHANNEL_BINDING_TLS_SERVER_END_POINT = 1,
    G_TLS_CHANNEL_BINDING_TLS_EXPORTER = 2,
    TGTlsChannelBindingTypeMaxValue = $7FFFFFFF
  );
  TGTlsDatabaseLookupFlags = (
    TGTlsDatabaseLookupFlagsMinValue = -$7FFFFFFF,
    G_TLS_DATABASE_LOOKUP_NONE = 0,
    G_TLS_DATABASE_LOOKUP_KEYPAIR = 1,
    TGTlsDatabaseLookupFlagsMaxValue = $7FFFFFFF
  );
  TGTlsDatabaseVerifyFlagsIdx = (
    TGTlsDatabaseVerifyFlagsIdxMinValue = 0,
    TGTlsDatabaseVerifyFlagsIdxMaxValue = 31
  );
  TGTlsDatabaseVerifyFlags = Set of TGTlsDatabaseVerifyFlagsIdx;
const
  G_TLS_DATABASE_VERIFY_NONE = []; {0 = $00000000}

type
  TGTlsCertificateRequestFlags = (
    TGTlsCertificateRequestFlagsMinValue = -$7FFFFFFF,
    G_TLS_CERTIFICATE_REQUEST_NONE = 0,
    TGTlsCertificateRequestFlagsMaxValue = $7FFFFFFF
  );
  TGTlsAuthenticationMode = (
    TGTlsAuthenticationModeMinValue = -$7FFFFFFF,
    G_TLS_AUTHENTICATION_NONE = 0,
    G_TLS_AUTHENTICATION_REQUESTED = 1,
    G_TLS_AUTHENTICATION_REQUIRED = 2,
    TGTlsAuthenticationModeMaxValue = $7FFFFFFF
  );
  TGEmblemOrigin = (
    TGEmblemOriginMinValue = -$7FFFFFFF,
    G_EMBLEM_ORIGIN_UNKNOWN = 0,
    G_EMBLEM_ORIGIN_DEVICE = 1,
    G_EMBLEM_ORIGIN_LIVEMETADATA = 2,
    G_EMBLEM_ORIGIN_TAG = 3,
    TGEmblemOriginMaxValue = $7FFFFFFF
  );
  TGFileMonitorEvent = (
    TGFileMonitorEventMinValue = -$7FFFFFFF,
    G_FILE_MONITOR_EVENT_CHANGED = 0,
    G_FILE_MONITOR_EVENT_CHANGES_DONE_HINT = 1,
    G_FILE_MONITOR_EVENT_DELETED = 2,
    G_FILE_MONITOR_EVENT_CREATED = 3,
    G_FILE_MONITOR_EVENT_ATTRIBUTE_CHANGED = 4,
    G_FILE_MONITOR_EVENT_PRE_UNMOUNT = 5,
    G_FILE_MONITOR_EVENT_UNMOUNTED = 6,
    G_FILE_MONITOR_EVENT_MOVED = 7,
    G_FILE_MONITOR_EVENT_RENAMED = 8,
    G_FILE_MONITOR_EVENT_MOVED_IN = 9,
    G_FILE_MONITOR_EVENT_MOVED_OUT = 10,
    TGFileMonitorEventMaxValue = $7FFFFFFF
  );
  TGFileAttributeStatus = (
    TGFileAttributeStatusMinValue = -$7FFFFFFF,
    G_FILE_ATTRIBUTE_STATUS_UNSET = 0,
    G_FILE_ATTRIBUTE_STATUS_SET = 1,
    G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING = 2,
    TGFileAttributeStatusMaxValue = $7FFFFFFF
  );
  TGFileType = (
    TGFileTypeMinValue = -$7FFFFFFF,
    G_FILE_TYPE_UNKNOWN = 0,
    G_FILE_TYPE_REGULAR = 1,
    G_FILE_TYPE_DIRECTORY = 2,
    G_FILE_TYPE_SYMBOLIC_LINK = 3,
    G_FILE_TYPE_SPECIAL = 4,
    G_FILE_TYPE_SHORTCUT = 5,
    G_FILE_TYPE_MOUNTABLE = 6,
    TGFileTypeMaxValue = $7FFFFFFF
  );
  TGFileAttributeInfoFlagsIdx = (
    TGFileAttributeInfoFlagsIdxMinValue = 0,
    G_FILE_ATTRIBUTE_INFO_COPY_WITH_FILE = 0,
    G_FILE_ATTRIBUTE_INFO_COPY_WHEN_MOVED = 1,
    TGFileAttributeInfoFlagsIdxMaxValue = 31
  );
  TGFileAttributeInfoFlags = Set of TGFileAttributeInfoFlagsIdx;
const
  G_FILE_ATTRIBUTE_INFO_NONE = []; {0 = $00000000}

type
  TGFilesystemPreviewType = (
    TGFilesystemPreviewTypeMinValue = -$7FFFFFFF,
    G_FILESYSTEM_PREVIEW_TYPE_IF_ALWAYS = 0,
    G_FILESYSTEM_PREVIEW_TYPE_IF_LOCAL = 1,
    G_FILESYSTEM_PREVIEW_TYPE_NEVER = 2,
    TGFilesystemPreviewTypeMaxValue = $7FFFFFFF
  );
  TGIOErrorEnum = (
    TGIOErrorEnumMinValue = -$7FFFFFFF,
    G_IO_ERROR_FAILED = 0,
    G_IO_ERROR_NOT_FOUND = 1,
    G_IO_ERROR_EXISTS = 2,
    G_IO_ERROR_IS_DIRECTORY = 3,
    G_IO_ERROR_NOT_DIRECTORY = 4,
    G_IO_ERROR_NOT_EMPTY = 5,
    G_IO_ERROR_NOT_REGULAR_FILE = 6,
    G_IO_ERROR_NOT_SYMBOLIC_LINK = 7,
    G_IO_ERROR_NOT_MOUNTABLE_FILE = 8,
    G_IO_ERROR_FILENAME_TOO_LONG = 9,
    G_IO_ERROR_INVALID_FILENAME = 10,
    G_IO_ERROR_TOO_MANY_LINKS = 11,
    G_IO_ERROR_NO_SPACE = 12,
    G_IO_ERROR_INVALID_ARGUMENT = 13,
    G_IO_ERROR_PERMISSION_DENIED = 14,
    G_IO_ERROR_NOT_SUPPORTED = 15,
    G_IO_ERROR_NOT_MOUNTED = 16,
    G_IO_ERROR_ALREADY_MOUNTED = 17,
    G_IO_ERROR_CLOSED = 18,
    G_IO_ERROR_CANCELLED = 19,
    G_IO_ERROR_PENDING = 20,
    G_IO_ERROR_READ_ONLY = 21,
    G_IO_ERROR_CANT_CREATE_BACKUP = 22,
    G_IO_ERROR_WRONG_ETAG = 23,
    G_IO_ERROR_TIMED_OUT = 24,
    G_IO_ERROR_WOULD_RECURSE = 25,
    G_IO_ERROR_BUSY = 26,
    G_IO_ERROR_WOULD_BLOCK = 27,
    G_IO_ERROR_HOST_NOT_FOUND = 28,
    G_IO_ERROR_WOULD_MERGE = 29,
    G_IO_ERROR_FAILED_HANDLED = 30,
    G_IO_ERROR_TOO_MANY_OPEN_FILES = 31,
    G_IO_ERROR_NOT_INITIALIZED = 32,
    G_IO_ERROR_ADDRESS_IN_USE = 33,
    G_IO_ERROR_PARTIAL_INPUT = 34,
    G_IO_ERROR_INVALID_DATA = 35,
    G_IO_ERROR_DBUS_ERROR = 36,
    G_IO_ERROR_HOST_UNREACHABLE = 37,
    G_IO_ERROR_NETWORK_UNREACHABLE = 38,
    G_IO_ERROR_CONNECTION_REFUSED = 39,
    G_IO_ERROR_PROXY_FAILED = 40,
    G_IO_ERROR_PROXY_AUTH_FAILED = 41,
    G_IO_ERROR_PROXY_NEED_AUTH = 42,
    G_IO_ERROR_PROXY_NOT_ALLOWED = 43,
    G_IO_ERROR_CONNECTION_CLOSED = 44,
    G_IO_ERROR_BROKEN_PIPE = 44,
    G_IO_ERROR_NOT_CONNECTED = 45,
    G_IO_ERROR_MESSAGE_TOO_LARGE = 46,
    G_IO_ERROR_NO_SUCH_DEVICE = 47,
    TGIOErrorEnumMaxValue = $7FFFFFFF
  );
  TGIOModuleScopeFlags = (
    TGIOModuleScopeFlagsMinValue = -$7FFFFFFF,
    G_IO_MODULE_SCOPE_NONE = 0,
    G_IO_MODULE_SCOPE_BLOCK_DUPLICATES = 1,
    TGIOModuleScopeFlagsMaxValue = $7FFFFFFF
  );
  TGSocketFamily = (
    TGSocketFamilyMinValue = -$7FFFFFFF,
    G_SOCKET_FAMILY_INVALID = 0,
    G_SOCKET_FAMILY_UNIX = 1,
    G_SOCKET_FAMILY_IPV4 = 2,
    G_SOCKET_FAMILY_IPV6 = 10,
    TGSocketFamilyMaxValue = $7FFFFFFF
  );
  TGMemoryMonitorWarningLevel = (
    TGMemoryMonitorWarningLevelMinValue = -$7FFFFFFF,
    G_MEMORY_MONITOR_WARNING_LEVEL_LOW = 50,
    G_MEMORY_MONITOR_WARNING_LEVEL_MEDIUM = 100,
    G_MEMORY_MONITOR_WARNING_LEVEL_CRITICAL = 255,
    TGMemoryMonitorWarningLevelMaxValue = $7FFFFFFF
  );
  TGNetworkConnectivity = (
    TGNetworkConnectivityMinValue = -$7FFFFFFF,
    G_NETWORK_CONNECTIVITY_LOCAL = 1,
    G_NETWORK_CONNECTIVITY_LIMITED = 2,
    G_NETWORK_CONNECTIVITY_PORTAL = 3,
    G_NETWORK_CONNECTIVITY_FULL = 4,
    TGNetworkConnectivityMaxValue = $7FFFFFFF
  );
  TGPollableReturn = (
    TGPollableReturnMinValue = -$7FFFFFFF,
    G_POLLABLE_RETURN_WOULD_BLOCK = -27,
    G_POLLABLE_RETURN_FAILED = 0,
    G_POLLABLE_RETURN_OK = 1,
    TGPollableReturnMaxValue = $7FFFFFFF
  );
  TGResolverNameLookupFlagsIdx = (
    TGResolverNameLookupFlagsIdxMinValue = 0,
    G_RESOLVER_NAME_LOOKUP_FLAGS_IPV4_ONLY = 0,
    G_RESOLVER_NAME_LOOKUP_FLAGS_IPV6_ONLY = 1,
    TGResolverNameLookupFlagsIdxMaxValue = 31
  );
  TGResolverNameLookupFlags = Set of TGResolverNameLookupFlagsIdx;
const
  G_RESOLVER_NAME_LOOKUP_FLAGS_DEFAULT = []; {0 = $00000000}

type
  TGResolverRecordType = (
    TGResolverRecordTypeMinValue = -$7FFFFFFF,
    G_RESOLVER_RECORD_SRV = 1,
    G_RESOLVER_RECORD_MX = 2,
    G_RESOLVER_RECORD_TXT = 3,
    G_RESOLVER_RECORD_SOA = 4,
    G_RESOLVER_RECORD_NS = 5,
    TGResolverRecordTypeMaxValue = $7FFFFFFF
  );
  TGResolverError = (
    TGResolverErrorMinValue = -$7FFFFFFF,
    G_RESOLVER_ERROR_NOT_FOUND = 0,
    G_RESOLVER_ERROR_TEMPORARY_FAILURE = 1,
    G_RESOLVER_ERROR_INTERNAL = 2,
    TGResolverErrorMaxValue = $7FFFFFFF
  );
  TGResourceLookupFlagsIdx = (
    TGResourceLookupFlagsIdxMinValue = 0,
    TGResourceLookupFlagsIdxMaxValue = 31
  );
  TGResourceLookupFlags = Set of TGResourceLookupFlagsIdx;
const
  G_RESOURCE_LOOKUP_FLAGS_NONE = []; {0 = $00000000}

type
  TGResourceError = (
    TGResourceErrorMinValue = -$7FFFFFFF,
    G_RESOURCE_ERROR_NOT_FOUND = 0,
    G_RESOURCE_ERROR_INTERNAL = 1,
    TGResourceErrorMaxValue = $7FFFFFFF
  );
  TGResourceFlagsIdx = (
    TGResourceFlagsIdxMinValue = 0,
    G_RESOURCE_FLAGS_COMPRESSED = 0,
    TGResourceFlagsIdxMaxValue = 31
  );
  TGResourceFlags = Set of TGResourceFlagsIdx;
const
  G_RESOURCE_FLAGS_NONE = []; {0 = $00000000}

type
  TGSettingsBindFlagsIdx = (
    TGSettingsBindFlagsIdxMinValue = 0,
    G_SETTINGS_BIND_GET = 0,
    G_SETTINGS_BIND_SET = 1,
    G_SETTINGS_BIND_NO_SENSITIVITY = 2,
    G_SETTINGS_BIND_GET_NO_CHANGES = 3,
    G_SETTINGS_BIND_INVERT_BOOLEAN = 4,
    TGSettingsBindFlagsIdxMaxValue = 31
  );
  TGSettingsBindFlags = Set of TGSettingsBindFlagsIdx;
const
  G_SETTINGS_BIND_DEFAULT = []; {0 = $00000000}

type
  TGSocketType = (
    TGSocketTypeMinValue = -$7FFFFFFF,
    G_SOCKET_TYPE_INVALID = 0,
    G_SOCKET_TYPE_STREAM = 1,
    G_SOCKET_TYPE_DATAGRAM = 2,
    G_SOCKET_TYPE_SEQPACKET = 3,
    TGSocketTypeMaxValue = $7FFFFFFF
  );
  TGSocketProtocol = (
    TGSocketProtocolMinValue = -$7FFFFFFF,
    G_SOCKET_PROTOCOL_UNKNOWN = -1,
    G_SOCKET_PROTOCOL_DEFAULT = 0,
    G_SOCKET_PROTOCOL_TCP = 6,
    G_SOCKET_PROTOCOL_UDP = 17,
    G_SOCKET_PROTOCOL_SCTP = 132,
    TGSocketProtocolMaxValue = $7FFFFFFF
  );
  TGSocketClientEvent = (
    TGSocketClientEventMinValue = -$7FFFFFFF,
    G_SOCKET_CLIENT_RESOLVING = 0,
    G_SOCKET_CLIENT_RESOLVED = 1,
    G_SOCKET_CLIENT_CONNECTING = 2,
    G_SOCKET_CLIENT_CONNECTED = 3,
    G_SOCKET_CLIENT_PROXY_NEGOTIATING = 4,
    G_SOCKET_CLIENT_PROXY_NEGOTIATED = 5,
    G_SOCKET_CLIENT_TLS_HANDSHAKING = 6,
    G_SOCKET_CLIENT_TLS_HANDSHAKED = 7,
    G_SOCKET_CLIENT_COMPLETE = 8,
    TGSocketClientEventMaxValue = $7FFFFFFF
  );
  TGSocketListenerEvent = (
    TGSocketListenerEventMinValue = -$7FFFFFFF,
    G_SOCKET_LISTENER_BINDING = 0,
    G_SOCKET_LISTENER_BOUND = 1,
    G_SOCKET_LISTENER_LISTENING = 2,
    G_SOCKET_LISTENER_LISTENED = 3,
    TGSocketListenerEventMaxValue = $7FFFFFFF
  );
  TGSocketMsgFlagsIdx = (
    TGSocketMsgFlagsIdxMinValue = 0,
    G_SOCKET_MSG_OOB = 0,
    G_SOCKET_MSG_PEEK = 1,
    G_SOCKET_MSG_DONTROUTE = 2,
    TGSocketMsgFlagsIdxMaxValue = 31
  );
  TGSocketMsgFlags = Set of TGSocketMsgFlagsIdx;
const
  G_SOCKET_MSG_NONE = []; {0 = $00000000}

type
  TGSubprocessFlagsIdx = (
    TGSubprocessFlagsIdxMinValue = 0,
    G_SUBPROCESS_FLAGS_STDIN_PIPE = 0,
    G_SUBPROCESS_FLAGS_STDIN_INHERIT = 1,
    G_SUBPROCESS_FLAGS_STDOUT_PIPE = 2,
    G_SUBPROCESS_FLAGS_STDOUT_SILENCE = 3,
    G_SUBPROCESS_FLAGS_STDERR_PIPE = 4,
    G_SUBPROCESS_FLAGS_STDERR_SILENCE = 5,
    G_SUBPROCESS_FLAGS_STDERR_MERGE = 6,
    G_SUBPROCESS_FLAGS_INHERIT_FDS = 7,
    G_SUBPROCESS_FLAGS_SEARCH_PATH_FROM_ENVP = 8,
    TGSubprocessFlagsIdxMaxValue = 31
  );
  TGSubprocessFlags = Set of TGSubprocessFlagsIdx;
const
  G_SUBPROCESS_FLAGS_NONE = []; {0 = $00000000}

type
  TGTestDBusFlagsIdx = (
    TGTestDBusFlagsIdxMinValue = 0,
    TGTestDBusFlagsIdxMaxValue = 31
  );
  TGTestDBusFlags = Set of TGTestDBusFlagsIdx;
const
  G_TEST_DBUS_NONE = []; {0 = $00000000}

type
  TGTlsChannelBindingError = (
    TGTlsChannelBindingErrorMinValue = -$7FFFFFFF,
    G_TLS_CHANNEL_BINDING_ERROR_NOT_IMPLEMENTED = 0,
    G_TLS_CHANNEL_BINDING_ERROR_INVALID_STATE = 1,
    G_TLS_CHANNEL_BINDING_ERROR_NOT_AVAILABLE = 2,
    G_TLS_CHANNEL_BINDING_ERROR_NOT_SUPPORTED = 3,
    G_TLS_CHANNEL_BINDING_ERROR_GENERAL_ERROR = 4,
    TGTlsChannelBindingErrorMaxValue = $7FFFFFFF
  );
  TGTlsError = (
    TGTlsErrorMinValue = -$7FFFFFFF,
    G_TLS_ERROR_UNAVAILABLE = 0,
    G_TLS_ERROR_MISC = 1,
    G_TLS_ERROR_BAD_CERTIFICATE = 2,
    G_TLS_ERROR_NOT_TLS = 3,
    G_TLS_ERROR_HANDSHAKE = 4,
    G_TLS_ERROR_CERTIFICATE_REQUIRED = 5,
    G_TLS_ERROR_EOF = 6,
    G_TLS_ERROR_INAPPROPRIATE_FALLBACK = 7,
    G_TLS_ERROR_BAD_CERTIFICATE_PASSWORD = 8,
    TGTlsErrorMaxValue = $7FFFFFFF
  );
  TGTlsInteractionResult = (
    TGTlsInteractionResultMinValue = -$7FFFFFFF,
    G_TLS_INTERACTION_UNHANDLED = 0,
    G_TLS_INTERACTION_HANDLED = 1,
    G_TLS_INTERACTION_FAILED = 2,
    TGTlsInteractionResultMaxValue = $7FFFFFFF
  );
  TGTlsPasswordFlagsIdx = (
    TGTlsPasswordFlagsIdxMinValue = 0,
    G_TLS_PASSWORD_RETRY = 1,
    G_TLS_PASSWORD_MANY_TRIES = 2,
    G_TLS_PASSWORD_FINAL_TRY = 3,
    G_TLS_PASSWORD_PKCS11_USER = 4,
    G_TLS_PASSWORD_PKCS11_SECURITY_OFFICER = 5,
    G_TLS_PASSWORD_PKCS11_CONTEXT_SPECIFIC = 6,
    TGTlsPasswordFlagsIdxMaxValue = 31
  );
  TGTlsPasswordFlags = Set of TGTlsPasswordFlagsIdx;
const
  G_TLS_PASSWORD_NONE = []; {0 = $00000000}

type
  TGUnixSocketAddressType = (
    TGUnixSocketAddressTypeMinValue = -$7FFFFFFF,
    G_UNIX_SOCKET_ADDRESS_INVALID = 0,
    G_UNIX_SOCKET_ADDRESS_ANONYMOUS = 1,
    G_UNIX_SOCKET_ADDRESS_PATH = 2,
    G_UNIX_SOCKET_ADDRESS_ABSTRACT = 3,
    G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED = 4,
    TGUnixSocketAddressTypeMaxValue = $7FFFFFFF
  );
  TGZlibCompressorFormat = (
    TGZlibCompressorFormatMinValue = -$7FFFFFFF,
    G_ZLIB_COMPRESSOR_FORMAT_ZLIB = 0,
    G_ZLIB_COMPRESSOR_FORMAT_GZIP = 1,
    G_ZLIB_COMPRESSOR_FORMAT_RAW = 2,
    TGZlibCompressorFormatMaxValue = $7FFFFFFF
  );
type


  { TGAction }
  PPGAction = ^PGAction;
  PGAction = ^TGAction;
  TGAction = object
    function name_is_valid(action_name: Pgchar): gboolean; cdecl; inline; static;
    function parse_detailed_name(detailed_name: Pgchar; action_name: PPgchar; target_value: PPGVariant; error: PPGError): gboolean; cdecl; inline; static;
    function print_detailed_name(action_name: Pgchar; target_value: PGVariant): Pgchar; cdecl; inline; static;
    procedure activate(parameter: PGVariant); cdecl; inline;
    procedure change_state(value: PGVariant); cdecl; inline;
    function get_enabled: gboolean; cdecl; inline;
    function get_name: Pgchar; cdecl; inline;
    function get_parameter_type: PGVariantType; cdecl; inline;
    function get_state: PGVariant; cdecl; inline;
    function get_state_hint: PGVariant; cdecl; inline;
    function get_state_type: PGVariantType; cdecl; inline;
    property enabled: gboolean read get_enabled ;
    property name: Pgchar read get_name ;
    property parameter_type: PGVariantType read get_parameter_type ;
    property state: PGVariant read get_state ;
    property state_type: PGVariantType read get_state_type ;
  end;


  { TGSimpleAction }
  PPGSimpleAction = ^PGSimpleAction;
  PGSimpleAction = ^TGSimpleAction;
  TGSimpleAction = object(TGObject)
    function new(name: Pgchar; parameter_type: PGVariantType): PGSimpleAction; cdecl; inline; static;
    function new_stateful(name: Pgchar; parameter_type: PGVariantType; state: PGVariant): PGSimpleAction; cdecl; inline; static;
    procedure set_enabled(enabled: gboolean); cdecl; inline;
    procedure set_state(value: PGVariant); cdecl; inline;
    procedure set_state_hint(state_hint: PGVariant); cdecl; inline;
    //property enabled: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_enabled  { property is writeable but setter not declared } ;
    //property name: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_name  { property is writeable but setter not declared } ;
    //property parameter_type: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_parameter_type  { property is writeable but setter not declared } ;
    //property state: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_state  { property is writeable but setter not declared } ;
    //property state_type: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_state_type ;
  end;


  { TGActionEntry }
  PPGActionEntry = ^PGActionEntry;
  PGActionEntry = ^TGActionEntry;

  TGActionEntry = record
    name: Pgchar;
    activate: procedure(action: PGSimpleAction; parameter: PGVariant; user_data: gpointer); cdecl;
    parameter_type: Pgchar;
    state: Pgchar;
    change_state: procedure(action: PGSimpleAction; value: PGVariant; user_data: gpointer); cdecl;
    padding: array [0..2] of gsize;
  end;




  { TGActionGroup }
  PPGActionGroup = ^PGActionGroup;
  PGActionGroup = ^TGActionGroup;
  TGActionGroup = object
    action_added1: procedure(action_name: Pgchar); cdecl;
    action_enabled_changed1: procedure(action_name: Pgchar; enabled: gboolean); cdecl;
    action_removed1: procedure(action_name: Pgchar); cdecl;
    action_state_changed1: procedure(action_name: Pgchar; value: TGVariant); cdecl;
    procedure action_added(action_name: Pgchar); cdecl; inline;
    procedure action_enabled_changed(action_name: Pgchar; enabled: gboolean); cdecl; inline;
    procedure action_removed(action_name: Pgchar); cdecl; inline;
    procedure action_state_changed(action_name: Pgchar; state: PGVariant); cdecl; inline;
    procedure activate_action(action_name: Pgchar; parameter: PGVariant); cdecl; inline;
    procedure change_action_state(action_name: Pgchar; value: PGVariant); cdecl; inline;
    function get_action_enabled(action_name: Pgchar): gboolean; cdecl; inline;
    function get_action_parameter_type(action_name: Pgchar): PGVariantType; cdecl; inline;
    function get_action_state(action_name: Pgchar): PGVariant; cdecl; inline;
    function get_action_state_hint(action_name: Pgchar): PGVariant; cdecl; inline;
    function get_action_state_type(action_name: Pgchar): PGVariantType; cdecl; inline;
    function has_action(action_name: Pgchar): gboolean; cdecl; inline;
    function list_actions: PPgchar; cdecl; inline;
    function query_action(action_name: Pgchar; enabled: Pgboolean; parameter_type: PPGVariantType; state_type: PPGVariantType; state_hint: PPGVariant; state: PPGVariant): gboolean; cdecl; inline;
  end;


  { TGActionGroupInterface }
  PPGActionGroupInterface = ^PGActionGroupInterface;
  PGActionGroupInterface = ^TGActionGroupInterface;
  TGActionGroupInterface = object
    g_iface: TGTypeInterface;
    has_action: function(action_group: PGActionGroup; action_name: Pgchar): gboolean; cdecl;
    list_actions: function(action_group: PGActionGroup): PPgchar; cdecl;
    get_action_enabled: function(action_group: PGActionGroup; action_name: Pgchar): gboolean; cdecl;
    get_action_parameter_type: function(action_group: PGActionGroup; action_name: Pgchar): PGVariantType; cdecl;
    get_action_state_type: function(action_group: PGActionGroup; action_name: Pgchar): PGVariantType; cdecl;
    get_action_state_hint: function(action_group: PGActionGroup; action_name: Pgchar): PGVariant; cdecl;
    get_action_state: function(action_group: PGActionGroup; action_name: Pgchar): PGVariant; cdecl;
    change_action_state: procedure(action_group: PGActionGroup; action_name: Pgchar; value: PGVariant); cdecl;
    activate_action: procedure(action_group: PGActionGroup; action_name: Pgchar; parameter: PGVariant); cdecl;
    action_added: procedure(action_group: PGActionGroup; action_name: Pgchar); cdecl;
    action_removed: procedure(action_group: PGActionGroup; action_name: Pgchar); cdecl;
    action_enabled_changed: procedure(action_group: PGActionGroup; action_name: Pgchar; enabled: gboolean); cdecl;
    action_state_changed: procedure(action_group: PGActionGroup; action_name: Pgchar; state: PGVariant); cdecl;
    query_action: function(action_group: PGActionGroup; action_name: Pgchar; enabled: Pgboolean; parameter_type: PPGVariantType; state_type: PPGVariantType; state_hint: PPGVariant; state: PPGVariant): gboolean; cdecl;
  end;


  { TGActionInterface }
  PPGActionInterface = ^PGActionInterface;
  PGActionInterface = ^TGActionInterface;
  TGActionInterface = object
    g_iface: TGTypeInterface;
    get_name: function(action: PGAction): Pgchar; cdecl;
    get_parameter_type: function(action: PGAction): PGVariantType; cdecl;
    get_state_type: function(action: PGAction): PGVariantType; cdecl;
    get_state_hint: function(action: PGAction): PGVariant; cdecl;
    get_enabled: function(action: PGAction): gboolean; cdecl;
    get_state: function(action: PGAction): PGVariant; cdecl;
    change_state: procedure(action: PGAction; value: PGVariant); cdecl;
    activate: procedure(action: PGAction; parameter: PGVariant); cdecl;
  end;


  { TGActionMap }
  PPGActionMap = ^PGActionMap;
  PGActionMap = ^TGActionMap;
  TGActionMap = object
    procedure add_action(action: PGAction); cdecl; inline;
    procedure add_action_entries(entries: PGActionEntry; n_entries: gint; user_data: gpointer); cdecl; inline;
    function lookup_action(action_name: Pgchar): PGAction; cdecl; inline;
    procedure remove_action(action_name: Pgchar); cdecl; inline;
  end;


  { TGActionMapInterface }
  PPGActionMapInterface = ^PGActionMapInterface;
  PGActionMapInterface = ^TGActionMapInterface;
  TGActionMapInterface = object
    g_iface: TGTypeInterface;
    lookup_action: function(action_map: PGActionMap; action_name: Pgchar): PGAction; cdecl;
    add_action: procedure(action_map: PGActionMap; action: PGAction); cdecl;
    remove_action: procedure(action_map: PGActionMap; action_name: Pgchar); cdecl;
  end;


  { TGAppInfo }
  PPGAppInfo = ^PGAppInfo;
  PGAppInfo = ^TGAppInfo;


  { TGAppInfoCreateFlags }
  PPGAppInfoCreateFlags = ^PGAppInfoCreateFlags;
  PGAppInfoCreateFlags = ^TGAppInfoCreateFlags;


  { TGAppLaunchContext }
  PPGAppLaunchContext = ^PGAppLaunchContext;
  PGAppLaunchContext = ^TGAppLaunchContext;


  { TGCancellable }
  PPGCancellable = ^PGCancellable;
  PGCancellable = ^TGCancellable;


  { TGAsyncReadyCallback }
  PPGAsyncReadyCallback = ^PGAsyncReadyCallback;
  PGAsyncReadyCallback = ^TGAsyncReadyCallback;


  { TGAsyncResult }
  PPGAsyncResult = ^PGAsyncResult;
  PGAsyncResult = ^TGAsyncResult;
  TGAsyncReadyCallback = procedure(source_object: PGObject; res: PGAsyncResult; user_data: gpointer); cdecl;


  { TGIcon }
  PPGIcon = ^PGIcon;
  PGIcon = ^TGIcon;
  TGAppInfo = object
    function create_from_commandline(commandline: Pgchar; application_name: Pgchar; flags: TGAppInfoCreateFlags; error: PPGError): PGAppInfo; cdecl; inline; static;
    function get_all: PGList; cdecl; inline; static;
    function get_all_for_type(content_type: Pgchar): PGList; cdecl; inline; static;
    function get_default_for_type(content_type: Pgchar; must_support_uris: gboolean): PGAppInfo; cdecl; inline; static;
    function get_default_for_uri_scheme(uri_scheme: Pgchar): PGAppInfo; cdecl; inline; static;
    function get_fallback_for_type(content_type: Pgchar): PGList; cdecl; inline; static;
    function get_recommended_for_type(content_type: Pgchar): PGList; cdecl; inline; static;
    function launch_default_for_uri(uri: Pgchar; context: PGAppLaunchContext; error: PPGError): gboolean; cdecl; inline; static;
    procedure launch_default_for_uri_async(uri: Pgchar; context: PGAppLaunchContext; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline; static;
    function launch_default_for_uri_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl; inline; static;
    procedure reset_type_associations(content_type: Pgchar); cdecl; inline; static;
    function add_supports_type(content_type: Pgchar; error: PPGError): gboolean; cdecl; inline;
    function can_delete: gboolean; cdecl; inline;
    function can_remove_supports_type: gboolean; cdecl; inline;
    function delete: gboolean; cdecl; inline;
    function dup: PGAppInfo; cdecl; inline;
    function equal(appinfo2: PGAppInfo): gboolean; cdecl; inline;
    function get_commandline: Pgchar; cdecl; inline;
    function get_description: Pgchar; cdecl; inline;
    function get_display_name: Pgchar; cdecl; inline;
    function get_executable: Pgchar; cdecl; inline;
    function get_icon: PGIcon; cdecl; inline;
    function get_id: Pgchar; cdecl; inline;
    function get_name: Pgchar; cdecl; inline;
    function get_supported_types: PPgchar; cdecl; inline;
    function launch(files: PGList; context: PGAppLaunchContext; error: PPGError): gboolean; cdecl; inline;
    function launch_uris(uris: PGList; context: PGAppLaunchContext; error: PPGError): gboolean; cdecl; inline;
    procedure launch_uris_async(uris: PGList; context: PGAppLaunchContext; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function launch_uris_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl; inline;
    function remove_supports_type(content_type: Pgchar; error: PPGError): gboolean; cdecl; inline;
    function set_as_default_for_extension(extension: Pgchar; error: PPGError): gboolean; cdecl; inline;
    function set_as_default_for_type(content_type: Pgchar; error: PPGError): gboolean; cdecl; inline;
    function set_as_last_used_for_type(content_type: Pgchar; error: PPGError): gboolean; cdecl; inline;
    function should_show: gboolean; cdecl; inline;
    function supports_files: gboolean; cdecl; inline;
    function supports_uris: gboolean; cdecl; inline;
  end;


  { TGCancellablePrivate }
  PPGCancellablePrivate = ^PGCancellablePrivate;
  PGCancellablePrivate = ^TGCancellablePrivate;
  TGCancellable = object(TGObject)
    priv: PGCancellablePrivate;
    function new: PGCancellable; cdecl; inline; static;
    function get_current: PGCancellable; cdecl; inline; static;
    procedure cancel; cdecl; inline;
    function connect(callback: TGCallback; data: gpointer; data_destroy_func: TGDestroyNotify): gulong; cdecl; inline;
    procedure disconnect(handler_id: gulong); cdecl; inline;
    function get_fd: gint; cdecl; inline;
    function is_cancelled: gboolean; cdecl; inline;
    function make_pollfd(pollfd: PGPollFD): gboolean; cdecl; inline;
    procedure pop_current; cdecl; inline;
    procedure push_current; cdecl; inline;
    procedure release_fd; cdecl; inline;
    procedure reset; cdecl; inline;
    function set_error_if_cancelled(error: PPGError): gboolean; cdecl; inline;
    function source_new: PGSource; cdecl; inline;
  end;
  TGAsyncResult = object
    function get_source_object: PGObject; cdecl; inline;
    function get_user_data: gpointer; cdecl; inline;
    function is_tagged(source_tag: gpointer): gboolean; cdecl; inline;
    function legacy_propagate_error(error: PPGError): gboolean; cdecl; inline;
  end;


  { TGAppLaunchContextPrivate }
  PPGAppLaunchContextPrivate = ^PGAppLaunchContextPrivate;
  PGAppLaunchContextPrivate = ^TGAppLaunchContextPrivate;
  TGAppLaunchContext = object(TGObject)
    priv: PGAppLaunchContextPrivate;
    function new: PGAppLaunchContext; cdecl; inline; static;
    function get_display(info: PGAppInfo; files: PGList): Pgchar; cdecl; inline;
    function get_environment: PPgchar; cdecl; inline;
    function get_startup_notify_id(info: PGAppInfo; files: PGList): Pgchar; cdecl; inline;
    procedure launch_failed(startup_notify_id: Pgchar); cdecl; inline;
    procedure setenv(variable: Pgchar; value: Pgchar); cdecl; inline;
    procedure unsetenv(variable: Pgchar); cdecl; inline;
  end;
  TGIcon = object
    function deserialize(value: PGVariant): PGIcon; cdecl; inline; static;
    function hash(icon: Pgpointer): guint; cdecl; inline; static;
    function new_for_string(str: Pgchar; error: PPGError): PGIcon; cdecl; inline; static;
    function equal(icon2: PGIcon): gboolean; cdecl; inline;
    function serialize: PGVariant; cdecl; inline;
    function to_string: Pgchar; cdecl; inline;
  end;


  { TGAppInfoIface }
  PPGAppInfoIface = ^PGAppInfoIface;
  PGAppInfoIface = ^TGAppInfoIface;
  TGAppInfoIface = object
    g_iface: TGTypeInterface;
    dup: function(appinfo: PGAppInfo): PGAppInfo; cdecl;
    equal: function(appinfo1: PGAppInfo; appinfo2: PGAppInfo): gboolean; cdecl;
    get_id: function(appinfo: PGAppInfo): Pgchar; cdecl;
    get_name: function(appinfo: PGAppInfo): Pgchar; cdecl;
    get_description: function(appinfo: PGAppInfo): Pgchar; cdecl;
    get_executable: function(appinfo: PGAppInfo): Pgchar; cdecl;
    get_icon: function(appinfo: PGAppInfo): PGIcon; cdecl;
    launch: function(appinfo: PGAppInfo; files: PGList; context: PGAppLaunchContext; error: PPGError): gboolean; cdecl;
    supports_uris: function(appinfo: PGAppInfo): gboolean; cdecl;
    supports_files: function(appinfo: PGAppInfo): gboolean; cdecl;
    launch_uris: function(appinfo: PGAppInfo; uris: PGList; context: PGAppLaunchContext; error: PPGError): gboolean; cdecl;
    should_show: function(appinfo: PGAppInfo): gboolean; cdecl;
    set_as_default_for_type: function(appinfo: PGAppInfo; content_type: Pgchar; error: PPGError): gboolean; cdecl;
    set_as_default_for_extension: function(appinfo: PGAppInfo; extension: Pgchar; error: PPGError): gboolean; cdecl;
    add_supports_type: function(appinfo: PGAppInfo; content_type: Pgchar; error: PPGError): gboolean; cdecl;
    can_remove_supports_type: function(appinfo: PGAppInfo): gboolean; cdecl;
    remove_supports_type: function(appinfo: PGAppInfo; content_type: Pgchar; error: PPGError): gboolean; cdecl;
    can_delete: function(appinfo: PGAppInfo): gboolean; cdecl;
    do_delete: function(appinfo: PGAppInfo): gboolean; cdecl;
    get_commandline: function(appinfo: PGAppInfo): Pgchar; cdecl;
    get_display_name: function(appinfo: PGAppInfo): Pgchar; cdecl;
    set_as_last_used_for_type: function(appinfo: PGAppInfo; content_type: Pgchar; error: PPGError): gboolean; cdecl;
    get_supported_types: function(appinfo: PGAppInfo): PPgchar; cdecl;
    launch_uris_async: procedure(appinfo: PGAppInfo; uris: PGList; context: PGAppLaunchContext; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    launch_uris_finish: function(appinfo: PGAppInfo; result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
  end;


  { TGAppInfoMonitor }
  PPGAppInfoMonitor = ^PGAppInfoMonitor;
  PGAppInfoMonitor = ^TGAppInfoMonitor;
  TGAppInfoMonitor = object(TGObject)
    function get: PGAppInfoMonitor; cdecl; inline; static;
  end;

  TGAppLaunchContextPrivate = record
  end;




  { TGAppLaunchContextClass }
  PPGAppLaunchContextClass = ^PGAppLaunchContextClass;
  PGAppLaunchContextClass = ^TGAppLaunchContextClass;
  TGAppLaunchContextClass = object
    parent_class: TGObjectClass;
    get_display: function(context: PGAppLaunchContext; info: PGAppInfo; files: PGList): Pgchar; cdecl;
    get_startup_notify_id: function(context: PGAppLaunchContext; info: PGAppInfo; files: PGList): Pgchar; cdecl;
    launch_failed: procedure(context: PGAppLaunchContext; startup_notify_id: Pgchar); cdecl;
    launched: procedure(context: PGAppLaunchContext; info: PGAppInfo; platform_data: PGVariant); cdecl;
    launch_started: procedure(context: PGAppLaunchContext; info: PGAppInfo; platform_data: PGVariant); cdecl;
    _g_reserved1: procedure; cdecl;
    _g_reserved2: procedure; cdecl;
    _g_reserved3: procedure; cdecl;
  end;


  { TGApplication }
  PPGApplication = ^PGApplication;
  PGApplication = ^TGApplication;


  { TGApplicationFlags }
  PPGApplicationFlags = ^PGApplicationFlags;
  PGApplicationFlags = ^TGApplicationFlags;


  { TGDBusConnection }
  PPGDBusConnection = ^PGDBusConnection;
  PGDBusConnection = ^TGDBusConnection;


  { TGFile }
  PPGFile = ^PGFile;
  PGFile = ^TGFile;


  { TGNotification }
  PPGNotification = ^PGNotification;
  PGNotification = ^TGNotification;


  { TGApplicationPrivate }
  PPGApplicationPrivate = ^PGApplicationPrivate;
  PGApplicationPrivate = ^TGApplicationPrivate;
  TGApplication = object(TGObject)
    priv: PGApplicationPrivate;
    function new(application_id: Pgchar; flags: TGApplicationFlags): PGApplication; cdecl; inline; static;
    function get_default: PGApplication; cdecl; inline; static;
    function id_is_valid(application_id: Pgchar): gboolean; cdecl; inline; static;
    procedure activate; cdecl; inline;
    procedure add_main_option(long_name: Pgchar; short_name: gchar; flags: TGOptionFlags; arg: TGOptionArg; description: Pgchar; arg_description: Pgchar); cdecl; inline;
    procedure add_main_option_entries(entries: PGOptionEntry); cdecl; inline;
    procedure add_option_group(group: PGOptionGroup); cdecl; inline;
    procedure bind_busy_property(object_: PGObject; property_: Pgchar); cdecl; inline;
    function get_application_id: Pgchar; cdecl; inline;
    function get_dbus_connection: PGDBusConnection; cdecl; inline;
    function get_dbus_object_path: Pgchar; cdecl; inline;
    function get_flags: TGApplicationFlags; cdecl; inline;
    function get_inactivity_timeout: guint; cdecl; inline;
    function get_is_busy: gboolean; cdecl; inline;
    function get_is_registered: gboolean; cdecl; inline;
    function get_is_remote: gboolean; cdecl; inline;
    function get_resource_base_path: Pgchar; cdecl; inline;
    procedure hold; cdecl; inline;
    procedure mark_busy; cdecl; inline;
    procedure open(files: PPGFile; n_files: gint; hint: Pgchar); cdecl; inline;
    procedure quit; cdecl; inline;
    function register(cancellable: PGCancellable; error: PPGError): gboolean; cdecl; inline;
    procedure release; cdecl; inline;
    function run(argc: gint; argv: PPgchar): gint; cdecl; inline;
    procedure send_notification(id: Pgchar; notification: PGNotification); cdecl; inline;
    procedure set_application_id(application_id: Pgchar); cdecl; inline;
    procedure set_default; cdecl; inline;
    procedure set_flags(flags: TGApplicationFlags); cdecl; inline;
    procedure set_inactivity_timeout(inactivity_timeout: guint); cdecl; inline;
    procedure set_option_context_description(description: Pgchar); cdecl; inline;
    procedure set_option_context_parameter_string(parameter_string: Pgchar); cdecl; inline;
    procedure set_option_context_summary(summary: Pgchar); cdecl; inline;
    procedure set_resource_base_path(resource_path: Pgchar); cdecl; inline;
    procedure unbind_busy_property(object_: PGObject; property_: Pgchar); cdecl; inline;
    procedure unmark_busy; cdecl; inline;
    procedure withdraw_notification(id: Pgchar); cdecl; inline;
    //property action_group: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_action_group  { property is writeable but setter not declared } ;
    property application_id: Pgchar read get_application_id write set_application_id;
    property flags: TGApplicationFlags read get_flags write set_flags;
    property inactivity_timeout: guint read get_inactivity_timeout write set_inactivity_timeout;
    property is_busy: gboolean read get_is_busy ;
    property is_registered: gboolean read get_is_registered ;
    property is_remote: gboolean read get_is_remote ;
    property resource_base_path: Pgchar read get_resource_base_path write set_resource_base_path;
  end;


  { TGApplicationCommandLine }
  PPGApplicationCommandLine = ^PGApplicationCommandLine;
  PGApplicationCommandLine = ^TGApplicationCommandLine;


  { TGInputStream }
  PPGInputStream = ^PGInputStream;
  PGInputStream = ^TGInputStream;


  { TGApplicationCommandLinePrivate }
  PPGApplicationCommandLinePrivate = ^PGApplicationCommandLinePrivate;
  PGApplicationCommandLinePrivate = ^TGApplicationCommandLinePrivate;
  TGApplicationCommandLine = object(TGObject)
    priv: PGApplicationCommandLinePrivate;
    function create_file_for_arg(arg: Pgchar): PGFile; cdecl; inline;
    function get_arguments(argc: Pgint): PPgchar; cdecl; inline;
    function get_cwd: Pgchar; cdecl; inline;
    function get_environ: PPgchar; cdecl; inline;
    function get_exit_status: gint; cdecl; inline;
    function get_is_remote: gboolean; cdecl; inline;
    function get_options_dict: PGVariantDict; cdecl; inline;
    function get_platform_data: PGVariant; cdecl; inline;
    function get_stdin: PGInputStream; cdecl; inline;
    function getenv(name: Pgchar): Pgchar; cdecl; inline;
    //procedure print(format: Pgchar; args: array of const); cdecl; inline;
    //procedure printerr(format: Pgchar; args: array of const); cdecl; inline;
    procedure set_exit_status(exit_status: gint); cdecl; inline;
    //property arguments: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_arguments  { property is writeable but setter not declared } ;
    property is_remote: gboolean read get_is_remote ;
    //property options: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_options  { property is writeable but setter not declared } ;
    property platform_data: PGVariant read get_platform_data  { property is writeable but setter not declared } ;
  end;


  { TGDBusConnectionFlags }
  PPGDBusConnectionFlags = ^PGDBusConnectionFlags;
  PGDBusConnectionFlags = ^TGDBusConnectionFlags;


  { TGDBusAuthObserver }
  PPGDBusAuthObserver = ^PGDBusAuthObserver;
  PGDBusAuthObserver = ^TGDBusAuthObserver;


  { TGIOStream }
  PPGIOStream = ^PGIOStream;
  PGIOStream = ^TGIOStream;


  { TGDBusMessageFilterFunction }
  PPGDBusMessageFilterFunction = ^PGDBusMessageFilterFunction;
  PGDBusMessageFilterFunction = ^TGDBusMessageFilterFunction;


  { TGDBusMessage }
  PPGDBusMessage = ^PGDBusMessage;
  PGDBusMessage = ^TGDBusMessage;
  TGDBusMessageFilterFunction = function(connection: PGDBusConnection; message: PGDBusMessage; incoming: gboolean; user_data: gpointer): PGDBusMessage; cdecl;


  { TGDBusCallFlags }
  PPGDBusCallFlags = ^PGDBusCallFlags;
  PGDBusCallFlags = ^TGDBusCallFlags;


  { TGUnixFDList }
  PPGUnixFDList = ^PGUnixFDList;
  PGUnixFDList = ^TGUnixFDList;


  { TGMenuModel }
  PPGMenuModel = ^PGMenuModel;
  PGMenuModel = ^TGMenuModel;


  { TGDBusCapabilityFlags }
  PPGDBusCapabilityFlags = ^PGDBusCapabilityFlags;
  PGDBusCapabilityFlags = ^TGDBusCapabilityFlags;


  { TGCredentials }
  PPGCredentials = ^PGCredentials;
  PGCredentials = ^TGCredentials;


  { TGDBusInterfaceInfo }
  PPGDBusInterfaceInfo = ^PGDBusInterfaceInfo;
  PGDBusInterfaceInfo = ^TGDBusInterfaceInfo;


  { TGDBusInterfaceVTable }
  PPGDBusInterfaceVTable = ^PGDBusInterfaceVTable;
  PGDBusInterfaceVTable = ^TGDBusInterfaceVTable;


  { TGDBusSubtreeVTable }
  PPGDBusSubtreeVTable = ^PGDBusSubtreeVTable;
  PGDBusSubtreeVTable = ^TGDBusSubtreeVTable;


  { TGDBusSubtreeFlags }
  PPGDBusSubtreeFlags = ^PGDBusSubtreeFlags;
  PGDBusSubtreeFlags = ^TGDBusSubtreeFlags;


  { TGDBusSendMessageFlags }
  PPGDBusSendMessageFlags = ^PGDBusSendMessageFlags;
  PGDBusSendMessageFlags = ^TGDBusSendMessageFlags;


  { TGDBusSignalFlags }
  PPGDBusSignalFlags = ^PGDBusSignalFlags;
  PGDBusSignalFlags = ^TGDBusSignalFlags;


  { TGDBusSignalCallback }
  PPGDBusSignalCallback = ^PGDBusSignalCallback;
  PGDBusSignalCallback = ^TGDBusSignalCallback;
  TGDBusSignalCallback = procedure(connection: PGDBusConnection; sender_name: Pgchar; object_path: Pgchar; interface_name: Pgchar; signal_name: Pgchar; parameters: PGVariant; user_data: gpointer); cdecl;
  TGDBusConnection = object(TGObject)
    function new_finish(res: PGAsyncResult; error: PPGError): PGDBusConnection; cdecl; inline; static;
    function new_for_address_finish(res: PGAsyncResult; error: PPGError): PGDBusConnection; cdecl; inline; static;
    function new_for_address_sync(address: Pgchar; flags: TGDBusConnectionFlags; observer: PGDBusAuthObserver; cancellable: PGCancellable; error: PPGError): PGDBusConnection; cdecl; inline; static;
    function new_sync(stream: PGIOStream; guid: Pgchar; flags: TGDBusConnectionFlags; observer: PGDBusAuthObserver; cancellable: PGCancellable; error: PPGError): PGDBusConnection; cdecl; inline; static;
    procedure new(stream: PGIOStream; guid: Pgchar; flags: TGDBusConnectionFlags; observer: PGDBusAuthObserver; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline; static;
    procedure new_for_address(address: Pgchar; flags: TGDBusConnectionFlags; observer: PGDBusAuthObserver; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline; static;
    function add_filter(filter_function: TGDBusMessageFilterFunction; user_data: gpointer; user_data_free_func: TGDestroyNotify): guint; cdecl; inline;
    procedure call(bus_name: Pgchar; object_path: Pgchar; interface_name: Pgchar; method_name: Pgchar; parameters: PGVariant; reply_type: PGVariantType; flags: TGDBusCallFlags; timeout_msec: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function call_finish(res: PGAsyncResult; error: PPGError): PGVariant; cdecl; inline;
    function call_sync(bus_name: Pgchar; object_path: Pgchar; interface_name: Pgchar; method_name: Pgchar; parameters: PGVariant; reply_type: PGVariantType; flags: TGDBusCallFlags; timeout_msec: gint; cancellable: PGCancellable; error: PPGError): PGVariant; cdecl; inline;
    procedure call_with_unix_fd_list(bus_name: Pgchar; object_path: Pgchar; interface_name: Pgchar; method_name: Pgchar; parameters: PGVariant; reply_type: PGVariantType; flags: TGDBusCallFlags; timeout_msec: gint; fd_list: PGUnixFDList; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function call_with_unix_fd_list_finish(out_fd_list: PPGUnixFDList; res: PGAsyncResult; error: PPGError): PGVariant; cdecl; inline;
    function call_with_unix_fd_list_sync(bus_name: Pgchar; object_path: Pgchar; interface_name: Pgchar; method_name: Pgchar; parameters: PGVariant; reply_type: PGVariantType; flags: TGDBusCallFlags; timeout_msec: gint; fd_list: PGUnixFDList; out_fd_list: PPGUnixFDList; cancellable: PGCancellable; error: PPGError): PGVariant; cdecl; inline;
    procedure close(cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function close_finish(res: PGAsyncResult; error: PPGError): gboolean; cdecl; inline;
    function close_sync(cancellable: PGCancellable; error: PPGError): gboolean; cdecl; inline;
    function emit_signal(destination_bus_name: Pgchar; object_path: Pgchar; interface_name: Pgchar; signal_name: Pgchar; parameters: PGVariant; error: PPGError): gboolean; cdecl; inline;
    function export_action_group(object_path: Pgchar; action_group: PGActionGroup; error: PPGError): guint; cdecl; inline;
    function export_menu_model(object_path: Pgchar; menu: PGMenuModel; error: PPGError): guint; cdecl; inline;
    procedure flush(cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function flush_finish(res: PGAsyncResult; error: PPGError): gboolean; cdecl; inline;
    function flush_sync(cancellable: PGCancellable; error: PPGError): gboolean; cdecl; inline;
    function get_capabilities: TGDBusCapabilityFlags; cdecl; inline;
    function get_exit_on_close: gboolean; cdecl; inline;
    function get_flags: TGDBusConnectionFlags; cdecl; inline;
    function get_guid: Pgchar; cdecl; inline;
    function get_last_serial: guint32; cdecl; inline;
    function get_peer_credentials: PGCredentials; cdecl; inline;
    function get_stream: PGIOStream; cdecl; inline;
    function get_unique_name: Pgchar; cdecl; inline;
    function is_closed: gboolean; cdecl; inline;
    function register_object(object_path: Pgchar; interface_info: PGDBusInterfaceInfo; vtable: PGDBusInterfaceVTable; user_data: gpointer; user_data_free_func: TGDestroyNotify; error: PPGError): guint; cdecl; inline;
    function register_object_with_closures(object_path: Pgchar; interface_info: PGDBusInterfaceInfo; method_call_closure: PGClosure; get_property_closure: PGClosure; set_property_closure: PGClosure; error: PPGError): guint; cdecl; inline;
    function register_subtree(object_path: Pgchar; vtable: PGDBusSubtreeVTable; flags: TGDBusSubtreeFlags; user_data: gpointer; user_data_free_func: TGDestroyNotify; error: PPGError): guint; cdecl; inline;
    procedure remove_filter(filter_id: guint); cdecl; inline;
    function send_message(message: PGDBusMessage; flags: TGDBusSendMessageFlags; out_serial: Pguint32; error: PPGError): gboolean; cdecl; inline;
    procedure send_message_with_reply(message: PGDBusMessage; flags: TGDBusSendMessageFlags; timeout_msec: gint; out_serial: Pguint32; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function send_message_with_reply_finish(res: PGAsyncResult; error: PPGError): PGDBusMessage; cdecl; inline;
    function send_message_with_reply_sync(message: PGDBusMessage; flags: TGDBusSendMessageFlags; timeout_msec: gint; out_serial: Pguint32; cancellable: PGCancellable; error: PPGError): PGDBusMessage; cdecl; inline;
    procedure set_exit_on_close(exit_on_close: gboolean); cdecl; inline;
    function signal_subscribe(sender: Pgchar; interface_name: Pgchar; member: Pgchar; object_path: Pgchar; arg0: Pgchar; flags: TGDBusSignalFlags; callback: TGDBusSignalCallback; user_data: gpointer; user_data_free_func: TGDestroyNotify): guint; cdecl; inline;
    procedure signal_unsubscribe(subscription_id: guint); cdecl; inline;
    procedure start_message_processing; cdecl; inline;
    procedure unexport_action_group(export_id: guint); cdecl; inline;
    procedure unexport_menu_model(export_id: guint); cdecl; inline;
    function unregister_object(registration_id: guint): gboolean; cdecl; inline;
    function unregister_subtree(registration_id: guint): gboolean; cdecl; inline;
    //property address: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_address  { property is writeable but setter not declared } ;
    //property authentication_observer: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_authentication_observer  { property is writeable but setter not declared } ;
    property capabilities: TGDBusCapabilityFlags read get_capabilities ;
    //property closed: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_closed ;
    property exit_on_close: gboolean read get_exit_on_close write set_exit_on_close;
    property flags: TGDBusConnectionFlags read get_flags  { property is writeable but setter not declared } ;
    property guid: Pgchar read get_guid  { property is writeable but setter not declared } ;
    property stream: PGIOStream read get_stream  { property is writeable but setter not declared } ;
    property unique_name: Pgchar read get_unique_name ;
  end;


  { TGFileIOStream }
  PPGFileIOStream = ^PGFileIOStream;
  PGFileIOStream = ^TGFileIOStream;


  { TGFileOutputStream }
  PPGFileOutputStream = ^PGFileOutputStream;
  PGFileOutputStream = ^TGFileOutputStream;


  { TGFileCreateFlags }
  PPGFileCreateFlags = ^PGFileCreateFlags;
  PGFileCreateFlags = ^TGFileCreateFlags;


  { TGFileCopyFlags }
  PPGFileCopyFlags = ^PGFileCopyFlags;
  PGFileCopyFlags = ^TGFileCopyFlags;


  { TGFileProgressCallback }
  PPGFileProgressCallback = ^PGFileProgressCallback;
  PGFileProgressCallback = ^TGFileProgressCallback;
  TGFileProgressCallback = procedure(current_num_bytes: gint64; total_num_bytes: gint64; user_data: gpointer); cdecl;


  { TGMountUnmountFlags }
  PPGMountUnmountFlags = ^PGMountUnmountFlags;
  PGMountUnmountFlags = ^TGMountUnmountFlags;


  { TGMountOperation }
  PPGMountOperation = ^PGMountOperation;
  PGMountOperation = ^TGMountOperation;


  { TGFileEnumerator }
  PPGFileEnumerator = ^PGFileEnumerator;
  PGFileEnumerator = ^TGFileEnumerator;


  { TGFileQueryInfoFlags }
  PPGFileQueryInfoFlags = ^PGFileQueryInfoFlags;
  PGFileQueryInfoFlags = ^TGFileQueryInfoFlags;


  { TGMount }
  PPGMount = ^PGMount;
  PGMount = ^TGMount;


  { TGFileReadMoreCallback }
  PPGFileReadMoreCallback = ^PGFileReadMoreCallback;
  PGFileReadMoreCallback = ^TGFileReadMoreCallback;
  TGFileReadMoreCallback = function(file_contents: Pgchar; file_size: gint64; user_data: gpointer): gboolean; cdecl;


  { TGFileMeasureFlags }
  PPGFileMeasureFlags = ^PGFileMeasureFlags;
  PGFileMeasureFlags = ^TGFileMeasureFlags;


  { TGFileMeasureProgressCallback }
  PPGFileMeasureProgressCallback = ^PGFileMeasureProgressCallback;
  PGFileMeasureProgressCallback = ^TGFileMeasureProgressCallback;
  TGFileMeasureProgressCallback = procedure(reporting: gboolean; current_size: guint64; num_dirs: guint64; num_files: guint64; user_data: gpointer); cdecl;


  { TGFileMonitor }
  PPGFileMonitor = ^PGFileMonitor;
  PGFileMonitor = ^TGFileMonitor;


  { TGFileMonitorFlags }
  PPGFileMonitorFlags = ^PGFileMonitorFlags;
  PGFileMonitorFlags = ^TGFileMonitorFlags;


  { TGMountMountFlags }
  PPGMountMountFlags = ^PGMountMountFlags;
  PGMountMountFlags = ^TGMountMountFlags;


  { TGFileType }
  PPGFileType = ^PGFileType;
  PGFileType = ^TGFileType;


  { TGFileInfo }
  PPGFileInfo = ^PGFileInfo;
  PGFileInfo = ^TGFileInfo;


  { TGFileAttributeInfoList }
  PPGFileAttributeInfoList = ^PGFileAttributeInfoList;
  PGFileAttributeInfoList = ^TGFileAttributeInfoList;


  { TGFileInputStream }
  PPGFileInputStream = ^PGFileInputStream;
  PGFileInputStream = ^TGFileInputStream;


  { TGFileAttributeType }
  PPGFileAttributeType = ^PGFileAttributeType;
  PGFileAttributeType = ^TGFileAttributeType;


  { TGDriveStartFlags }
  PPGDriveStartFlags = ^PGDriveStartFlags;
  PGDriveStartFlags = ^TGDriveStartFlags;
  TGFile = object
    //function new_build_filename(first_element: Pgchar; args: array of const): PGFile; cdecl; inline; static;
    function new_for_commandline_arg(arg: Pgchar): PGFile; cdecl; inline; static;
    function new_for_commandline_arg_and_cwd(arg: Pgchar; cwd: Pgchar): PGFile; cdecl; inline; static;
    function new_for_path(path: Pgchar): PGFile; cdecl; inline; static;
    function new_for_uri(uri: Pgchar): PGFile; cdecl; inline; static;
    function new_tmp(tmpl: Pgchar; iostream: PPGFileIOStream; error: PPGError): PGFile; cdecl; inline; static;
    function parse_name(parse_name: Pgchar): PGFile; cdecl; inline; static;
    function append_to(flags: TGFileCreateFlags; cancellable: PGCancellable; error: PPGError): PGFileOutputStream; cdecl; inline;
    procedure append_to_async(flags: TGFileCreateFlags; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function append_to_finish(res: PGAsyncResult; error: PPGError): PGFileOutputStream; cdecl; inline;
    function copy(destination: PGFile; flags: TGFileCopyFlags; cancellable: PGCancellable; progress_callback: TGFileProgressCallback; progress_callback_data: gpointer; error: PPGError): gboolean; cdecl; inline;
    procedure copy_async(destination: PGFile; flags: TGFileCopyFlags; io_priority: gint; cancellable: PGCancellable; progress_callback: TGFileProgressCallback; progress_callback_data: gpointer; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function copy_attributes(destination: PGFile; flags: TGFileCopyFlags; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; inline;
    function copy_finish(res: PGAsyncResult; error: PPGError): gboolean; cdecl; inline;
    function create(flags: TGFileCreateFlags; cancellable: PGCancellable; error: PPGError): PGFileOutputStream; cdecl; inline;
    procedure create_async(flags: TGFileCreateFlags; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function create_finish(res: PGAsyncResult; error: PPGError): PGFileOutputStream; cdecl; inline;
    function create_readwrite(flags: TGFileCreateFlags; cancellable: PGCancellable; error: PPGError): PGFileIOStream; cdecl; inline;
    procedure create_readwrite_async(flags: TGFileCreateFlags; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function create_readwrite_finish(res: PGAsyncResult; error: PPGError): PGFileIOStream; cdecl; inline;
    function delete(cancellable: PGCancellable; error: PPGError): gboolean; cdecl; inline;
    procedure delete_async(io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function delete_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl; inline;
    function dup: PGFile; cdecl; inline;
    procedure eject_mountable_with_operation(flags: TGMountUnmountFlags; mount_operation: PGMountOperation; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function eject_mountable_with_operation_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl; inline;
    function enumerate_children(attributes: Pgchar; flags: TGFileQueryInfoFlags; cancellable: PGCancellable; error: PPGError): PGFileEnumerator; cdecl; inline;
    procedure enumerate_children_async(attributes: Pgchar; flags: TGFileQueryInfoFlags; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function enumerate_children_finish(res: PGAsyncResult; error: PPGError): PGFileEnumerator; cdecl; inline;
    function equal(file2: PGFile): gboolean; cdecl; inline;
    function find_enclosing_mount(cancellable: PGCancellable; error: PPGError): PGMount; cdecl; inline;
    procedure find_enclosing_mount_async(io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function find_enclosing_mount_finish(res: PGAsyncResult; error: PPGError): PGMount; cdecl; inline;
    function get_basename: Pgchar; cdecl; inline;
    function get_child(name: Pgchar): PGFile; cdecl; inline;
    function get_child_for_display_name(display_name: Pgchar; error: PPGError): PGFile; cdecl; inline;
    function get_parent: PGFile; cdecl; inline;
    function get_parse_name: Pgchar; cdecl; inline;
    function get_path: Pgchar; cdecl; inline;
    function get_relative_path(descendant: PGFile): Pgchar; cdecl; inline;
    function get_uri: Pgchar; cdecl; inline;
    function get_uri_scheme: Pgchar; cdecl; inline;
    function has_parent(parent: PGFile): gboolean; cdecl; inline;
    function has_prefix(prefix: PGFile): gboolean; cdecl; inline;
    function has_uri_scheme(uri_scheme: Pgchar): gboolean; cdecl; inline;
    function hash: guint; cdecl; inline;
    function is_native: gboolean; cdecl; inline;
    function load_bytes(cancellable: PGCancellable; etag_out: PPgchar; error: PPGError): PGBytes; cdecl; inline;
    procedure load_bytes_async(cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function load_bytes_finish(result_: PGAsyncResult; etag_out: PPgchar; error: PPGError): PGBytes; cdecl; inline;
    function load_contents(cancellable: PGCancellable; contents: PPgchar; length: Pgsize; etag_out: PPgchar; error: PPGError): gboolean; cdecl; inline;
    procedure load_contents_async(cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function load_contents_finish(res: PGAsyncResult; contents: PPgchar; length: Pgsize; etag_out: PPgchar; error: PPGError): gboolean; cdecl; inline;
    procedure load_partial_contents_async(cancellable: PGCancellable; read_more_callback: TGFileReadMoreCallback; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function load_partial_contents_finish(res: PGAsyncResult; contents: PPgchar; length: Pgsize; etag_out: PPgchar; error: PPGError): gboolean; cdecl; inline;
    function make_directory(cancellable: PGCancellable; error: PPGError): gboolean; cdecl; inline;
    procedure make_directory_async(io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function make_directory_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl; inline;
    function make_directory_with_parents(cancellable: PGCancellable; error: PPGError): gboolean; cdecl; inline;
    function make_symbolic_link(symlink_value: Pgchar; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; inline;
    function measure_disk_usage(flags: TGFileMeasureFlags; cancellable: PGCancellable; progress_callback: TGFileMeasureProgressCallback; progress_data: gpointer; disk_usage: Pguint64; num_dirs: Pguint64; num_files: Pguint64; error: PPGError): gboolean; cdecl; inline;
    procedure measure_disk_usage_async(flags: TGFileMeasureFlags; io_priority: gint; cancellable: PGCancellable; progress_callback: TGFileMeasureProgressCallback; progress_data: gpointer; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function measure_disk_usage_finish(result_: PGAsyncResult; disk_usage: Pguint64; num_dirs: Pguint64; num_files: Pguint64; error: PPGError): gboolean; cdecl; inline;
    function monitor(flags: TGFileMonitorFlags; cancellable: PGCancellable; error: PPGError): PGFileMonitor; cdecl; inline;
    function monitor_directory(flags: TGFileMonitorFlags; cancellable: PGCancellable; error: PPGError): PGFileMonitor; cdecl; inline;
    function monitor_file(flags: TGFileMonitorFlags; cancellable: PGCancellable; error: PPGError): PGFileMonitor; cdecl; inline;
    procedure mount_enclosing_volume(flags: TGMountMountFlags; mount_operation: PGMountOperation; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function mount_enclosing_volume_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl; inline;
    procedure mount_mountable(flags: TGMountMountFlags; mount_operation: PGMountOperation; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function mount_mountable_finish(result_: PGAsyncResult; error: PPGError): PGFile; cdecl; inline;
    function move(destination: PGFile; flags: TGFileCopyFlags; cancellable: PGCancellable; progress_callback: TGFileProgressCallback; progress_callback_data: gpointer; error: PPGError): gboolean; cdecl; inline;
    function open_readwrite(cancellable: PGCancellable; error: PPGError): PGFileIOStream; cdecl; inline;
    procedure open_readwrite_async(io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function open_readwrite_finish(res: PGAsyncResult; error: PPGError): PGFileIOStream; cdecl; inline;
    function peek_path: Pgchar; cdecl; inline;
    procedure poll_mountable(cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function poll_mountable_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl; inline;
    function query_default_handler(cancellable: PGCancellable; error: PPGError): PGAppInfo; cdecl; inline;
    procedure query_default_handler_async(io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function query_default_handler_finish(result_: PGAsyncResult; error: PPGError): PGAppInfo; cdecl; inline;
    function query_exists(cancellable: PGCancellable): gboolean; cdecl; inline;
    function query_file_type(flags: TGFileQueryInfoFlags; cancellable: PGCancellable): TGFileType; cdecl; inline;
    function query_filesystem_info(attributes: Pgchar; cancellable: PGCancellable; error: PPGError): PGFileInfo; cdecl; inline;
    procedure query_filesystem_info_async(attributes: Pgchar; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function query_filesystem_info_finish(res: PGAsyncResult; error: PPGError): PGFileInfo; cdecl; inline;
    function query_info(attributes: Pgchar; flags: TGFileQueryInfoFlags; cancellable: PGCancellable; error: PPGError): PGFileInfo; cdecl; inline;
    procedure query_info_async(attributes: Pgchar; flags: TGFileQueryInfoFlags; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function query_info_finish(res: PGAsyncResult; error: PPGError): PGFileInfo; cdecl; inline;
    function query_settable_attributes(cancellable: PGCancellable; error: PPGError): PGFileAttributeInfoList; cdecl; inline;
    function query_writable_namespaces(cancellable: PGCancellable; error: PPGError): PGFileAttributeInfoList; cdecl; inline;
    function read(cancellable: PGCancellable; error: PPGError): PGFileInputStream; cdecl; inline;
    procedure read_async(io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function read_finish(res: PGAsyncResult; error: PPGError): PGFileInputStream; cdecl; inline;
    function replace(etag: Pgchar; make_backup: gboolean; flags: TGFileCreateFlags; cancellable: PGCancellable; error: PPGError): PGFileOutputStream; cdecl; inline;
    procedure replace_async(etag: Pgchar; make_backup: gboolean; flags: TGFileCreateFlags; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function replace_contents(contents: Pgchar; length: gsize; etag: Pgchar; make_backup: gboolean; flags: TGFileCreateFlags; new_etag: PPgchar; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; inline;
    procedure replace_contents_async(contents: Pgchar; length: gsize; etag: Pgchar; make_backup: gboolean; flags: TGFileCreateFlags; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    procedure replace_contents_bytes_async(contents: PGBytes; etag: Pgchar; make_backup: gboolean; flags: TGFileCreateFlags; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function replace_contents_finish(res: PGAsyncResult; new_etag: PPgchar; error: PPGError): gboolean; cdecl; inline;
    function replace_finish(res: PGAsyncResult; error: PPGError): PGFileOutputStream; cdecl; inline;
    function replace_readwrite(etag: Pgchar; make_backup: gboolean; flags: TGFileCreateFlags; cancellable: PGCancellable; error: PPGError): PGFileIOStream; cdecl; inline;
    procedure replace_readwrite_async(etag: Pgchar; make_backup: gboolean; flags: TGFileCreateFlags; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function replace_readwrite_finish(res: PGAsyncResult; error: PPGError): PGFileIOStream; cdecl; inline;
    function resolve_relative_path(relative_path: Pgchar): PGFile; cdecl; inline;
    function set_attribute(attribute: Pgchar; type_: TGFileAttributeType; value_p: gpointer; flags: TGFileQueryInfoFlags; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; inline;
    function set_attribute_byte_string(attribute: Pgchar; value: Pgchar; flags: TGFileQueryInfoFlags; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; inline;
    function set_attribute_int32(attribute: Pgchar; value: gint32; flags: TGFileQueryInfoFlags; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; inline;
    function set_attribute_int64(attribute: Pgchar; value: gint64; flags: TGFileQueryInfoFlags; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; inline;
    function set_attribute_string(attribute: Pgchar; value: Pgchar; flags: TGFileQueryInfoFlags; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; inline;
    function set_attribute_uint32(attribute: Pgchar; value: guint32; flags: TGFileQueryInfoFlags; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; inline;
    function set_attribute_uint64(attribute: Pgchar; value: guint64; flags: TGFileQueryInfoFlags; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; inline;
    procedure set_attributes_async(info: PGFileInfo; flags: TGFileQueryInfoFlags; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function set_attributes_finish(result_: PGAsyncResult; info: PPGFileInfo; error: PPGError): gboolean; cdecl; inline;
    function set_attributes_from_info(info: PGFileInfo; flags: TGFileQueryInfoFlags; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; inline;
    function set_display_name(display_name: Pgchar; cancellable: PGCancellable; error: PPGError): PGFile; cdecl; inline;
    procedure set_display_name_async(display_name: Pgchar; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function set_display_name_finish(res: PGAsyncResult; error: PPGError): PGFile; cdecl; inline;
    procedure start_mountable(flags: TGDriveStartFlags; start_operation: PGMountOperation; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function start_mountable_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl; inline;
    procedure stop_mountable(flags: TGMountUnmountFlags; mount_operation: PGMountOperation; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function stop_mountable_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl; inline;
    function supports_thread_contexts: gboolean; cdecl; inline;
    function trash(cancellable: PGCancellable; error: PPGError): gboolean; cdecl; inline;
    procedure trash_async(io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function trash_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl; inline;
    procedure unmount_mountable_with_operation(flags: TGMountUnmountFlags; mount_operation: PGMountOperation; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function unmount_mountable_with_operation_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl; inline;
  end;


  { TGNotificationPriority }
  PPGNotificationPriority = ^PGNotificationPriority;
  PGNotificationPriority = ^TGNotificationPriority;
  TGNotification = object(TGObject)
    function new(title: Pgchar): PGNotification; cdecl; inline; static;
    procedure add_button(label_: Pgchar; detailed_action: Pgchar); cdecl; inline;
    //procedure add_button_with_target(label_: Pgchar; action: Pgchar; target_format: Pgchar; args: array of const); cdecl; inline;
    procedure add_button_with_target_value(label_: Pgchar; action: Pgchar; target: PGVariant); cdecl; inline;
    procedure set_body(body: Pgchar); cdecl; inline;
    procedure set_default_action(detailed_action: Pgchar); cdecl; inline;
    //procedure set_default_action_and_target(action: Pgchar; target_format: Pgchar; args: array of const); cdecl; inline;
    procedure set_default_action_and_target_value(action: Pgchar; target: PGVariant); cdecl; inline;
    procedure set_icon(icon: PGIcon); cdecl; inline;
    procedure set_priority(priority: TGNotificationPriority); cdecl; inline;
    procedure set_title(title: Pgchar); cdecl; inline;
  end;

  TGApplicationPrivate = record
  end;




  { TGApplicationClass }
  PPGApplicationClass = ^PGApplicationClass;
  PGApplicationClass = ^TGApplicationClass;
  TGApplicationClass = object
    parent_class: TGObjectClass;
    startup: procedure(application: PGApplication); cdecl;
    activate: procedure(application: PGApplication); cdecl;
    open: procedure(application: PGApplication; files: PPGFile; n_files: gint; hint: Pgchar); cdecl;
    command_line: function(application: PGApplication; command_line: PGApplicationCommandLine): gint; cdecl;
    local_command_line: function(application: PGApplication; arguments: PPPgchar; exit_status: Pgint): gboolean; cdecl;
    before_emit: procedure(application: PGApplication; platform_data: PGVariant); cdecl;
    after_emit: procedure(application: PGApplication; platform_data: PGVariant); cdecl;
    add_platform_data: procedure(application: PGApplication; builder: PGVariantBuilder); cdecl;
    quit_mainloop: procedure(application: PGApplication); cdecl;
    run_mainloop: procedure(application: PGApplication); cdecl;
    shutdown: procedure(application: PGApplication); cdecl;
    dbus_register: function(application: PGApplication; connection: PGDBusConnection; object_path: Pgchar; error: PPGError): gboolean; cdecl;
    dbus_unregister: procedure(application: PGApplication; connection: PGDBusConnection; object_path: Pgchar); cdecl;
    handle_local_options: function(application: PGApplication; options: PGVariantDict): gint; cdecl;
    name_lost: function(application: PGApplication): gboolean; cdecl;
    padding: array [0..6] of gpointer;
  end;


  { TGInputStreamPrivate }
  PPGInputStreamPrivate = ^PGInputStreamPrivate;
  PGInputStreamPrivate = ^TGInputStreamPrivate;
  TGInputStream = object(TGObject)
    priv: PGInputStreamPrivate;
    procedure clear_pending; cdecl; inline;
    function close(cancellable: PGCancellable; error: PPGError): gboolean; cdecl; inline;
    procedure close_async(io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function close_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl; inline;
    function has_pending: gboolean; cdecl; inline;
    function is_closed: gboolean; cdecl; inline;
    function read(buffer: Pguint8; count: gsize; cancellable: PGCancellable; error: PPGError): gssize; cdecl; inline;
    function read_all(buffer: Pguint8; count: gsize; bytes_read: Pgsize; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; inline;
    procedure read_all_async(buffer: Pguint8; count: gsize; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function read_all_finish(result_: PGAsyncResult; bytes_read: Pgsize; error: PPGError): gboolean; cdecl; inline;
    procedure read_async(buffer: Pguint8; count: gsize; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function read_bytes(count: gsize; cancellable: PGCancellable; error: PPGError): PGBytes; cdecl; inline;
    procedure read_bytes_async(count: gsize; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function read_bytes_finish(result_: PGAsyncResult; error: PPGError): PGBytes; cdecl; inline;
    function read_finish(result_: PGAsyncResult; error: PPGError): gssize; cdecl; inline;
    function set_pending(error: PPGError): gboolean; cdecl; inline;
    function skip(count: gsize; cancellable: PGCancellable; error: PPGError): gssize; cdecl; inline;
    procedure skip_async(count: gsize; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function skip_finish(result_: PGAsyncResult; error: PPGError): gssize; cdecl; inline;
  end;

  TGApplicationCommandLinePrivate = record
  end;




  { TGApplicationCommandLineClass }
  PPGApplicationCommandLineClass = ^PGApplicationCommandLineClass;
  PGApplicationCommandLineClass = ^TGApplicationCommandLineClass;
  TGApplicationCommandLineClass = object
    parent_class: TGObjectClass;
    print_literal: procedure(cmdline: PGApplicationCommandLine; message: Pgchar); cdecl;
    printerr_literal: procedure(cmdline: PGApplicationCommandLine; message: Pgchar); cdecl;
    get_stdin: function(cmdline: PGApplicationCommandLine): PGInputStream; cdecl;
    padding: array [0..10] of gpointer;
  end;


  { TGAskPasswordFlags }
  PPGAskPasswordFlags = ^PGAskPasswordFlags;
  PGAskPasswordFlags = ^TGAskPasswordFlags;


  { TGAsyncInitable }
  PPGAsyncInitable = ^PGAsyncInitable;
  PGAsyncInitable = ^TGAsyncInitable;
  TGAsyncInitable = object
    //procedure new_async(object_type: TGType; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer; first_property_name: Pgchar; args: array of const); cdecl; inline; static;
    //procedure new_valist_async(object_type: TGType; first_property_name: Pgchar; var_args: Tva_list; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline; static;
    procedure init_async(io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function init_finish(res: PGAsyncResult; error: PPGError): gboolean; cdecl; inline;
    function new_finish(res: PGAsyncResult; error: PPGError): PGObject; cdecl; inline;
  end;


  { TGAsyncInitableIface }
  PPGAsyncInitableIface = ^PGAsyncInitableIface;
  PGAsyncInitableIface = ^TGAsyncInitableIface;
  TGAsyncInitableIface = object
    g_iface: TGTypeInterface;
    init_async: procedure(initable: PGAsyncInitable; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    init_finish: function(initable: PGAsyncInitable; res: PGAsyncResult; error: PPGError): gboolean; cdecl;
  end;


  { TGAsyncResultIface }
  PPGAsyncResultIface = ^PGAsyncResultIface;
  PGAsyncResultIface = ^TGAsyncResultIface;
  TGAsyncResultIface = object
    g_iface: TGTypeInterface;
    get_user_data: function(res: PGAsyncResult): gpointer; cdecl;
    get_source_object: function(res: PGAsyncResult): PGObject; cdecl;
    is_tagged: function(res: PGAsyncResult; source_tag: gpointer): gboolean; cdecl;
  end;


  { TGSeekable }
  PPGSeekable = ^PGSeekable;
  PGSeekable = ^TGSeekable;
  TGSeekable = object
    function can_seek: gboolean; cdecl; inline;
    function can_truncate: gboolean; cdecl; inline;
    function seek(offset: gint64; type_: TGSeekType; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; inline;
    function tell: gint64; cdecl; inline;
    function truncate(offset: gint64; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; inline;
  end;


  { TGBufferedInputStream }
  PPGBufferedInputStream = ^PGBufferedInputStream;
  PGBufferedInputStream = ^TGBufferedInputStream;


  { TGFilterInputStream }
  PPGFilterInputStream = ^PGFilterInputStream;
  PGFilterInputStream = ^TGFilterInputStream;
  TGFilterInputStream = object(TGInputStream)
    base_stream1: PGInputStream;
    function get_base_stream: PGInputStream; cdecl; inline;
    function get_close_base_stream: gboolean; cdecl; inline;
    procedure set_close_base_stream(close_base: gboolean); cdecl; inline;
    property base_stream: PGInputStream read get_base_stream  { property is writeable but setter not declared } ;
    property close_base_stream: gboolean read get_close_base_stream write set_close_base_stream;
  end;


  { TGBufferedInputStreamPrivate }
  PPGBufferedInputStreamPrivate = ^PGBufferedInputStreamPrivate;
  PGBufferedInputStreamPrivate = ^TGBufferedInputStreamPrivate;
  TGBufferedInputStream = object(TGFilterInputStream)
    priv1: PGBufferedInputStreamPrivate;
    function new(base_stream: PGInputStream): PGBufferedInputStream; cdecl; inline; static;
    function new_sized(base_stream: PGInputStream; size: gsize): PGBufferedInputStream; cdecl; inline; static;
    function fill(count: gssize; cancellable: PGCancellable; error: PPGError): gssize; cdecl; inline;
    procedure fill_async(count: gssize; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function fill_finish(result_: PGAsyncResult; error: PPGError): gssize; cdecl; inline;
    function get_available: gsize; cdecl; inline;
    function get_buffer_size: gsize; cdecl; inline;
    function peek(buffer: Pguint8; offset: gsize; count: gsize): gsize; cdecl; inline;
    function peek_buffer(count: Pgsize): Pguint8; cdecl; inline;
    function read_byte(cancellable: PGCancellable; error: PPGError): gint; cdecl; inline;
    procedure set_buffer_size(size: gsize); cdecl; inline;
    property buffer_size: gsize read get_buffer_size write set_buffer_size;
  end;

  TGBufferedInputStreamPrivate = record
  end;




  { TGFilterInputStreamClass }
  PPGFilterInputStreamClass = ^PGFilterInputStreamClass;
  PGFilterInputStreamClass = ^TGFilterInputStreamClass;


  { TGInputStreamClass }
  PPGInputStreamClass = ^PGInputStreamClass;
  PGInputStreamClass = ^TGInputStreamClass;
  TGInputStreamClass = object
    parent_class: TGObjectClass;
    read_fn: function(stream: PGInputStream; buffer: Pgpointer; count: gsize; cancellable: PGCancellable; error: PPGError): gssize; cdecl;
    skip: function(stream: PGInputStream; count: gsize; cancellable: PGCancellable; error: PPGError): gssize; cdecl;
    close_fn: function(stream: PGInputStream; cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
    read_async: procedure(stream: PGInputStream; buffer: Pguint8; count: gsize; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    read_finish: function(stream: PGInputStream; result_: PGAsyncResult; error: PPGError): gssize; cdecl;
    skip_async: procedure(stream: PGInputStream; count: gsize; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    skip_finish: function(stream: PGInputStream; result_: PGAsyncResult; error: PPGError): gssize; cdecl;
    close_async: procedure(stream: PGInputStream; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    close_finish: function(stream: PGInputStream; result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
    _g_reserved1: procedure; cdecl;
    _g_reserved2: procedure; cdecl;
    _g_reserved3: procedure; cdecl;
    _g_reserved4: procedure; cdecl;
    _g_reserved5: procedure; cdecl;
  end;
  TGFilterInputStreamClass = object
    parent_class: TGInputStreamClass;
    _g_reserved1: procedure; cdecl;
    _g_reserved2: procedure; cdecl;
    _g_reserved3: procedure; cdecl;
  end;


  { TGBufferedInputStreamClass }
  PPGBufferedInputStreamClass = ^PGBufferedInputStreamClass;
  PGBufferedInputStreamClass = ^TGBufferedInputStreamClass;
  TGBufferedInputStreamClass = object
    parent_class: TGFilterInputStreamClass;
    fill: function(stream: PGBufferedInputStream; count: gssize; cancellable: PGCancellable; error: PPGError): gssize; cdecl;
    fill_async: procedure(stream: PGBufferedInputStream; count: gssize; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    fill_finish: function(stream: PGBufferedInputStream; result_: PGAsyncResult; error: PPGError): gssize; cdecl;
    _g_reserved1: procedure; cdecl;
    _g_reserved2: procedure; cdecl;
    _g_reserved3: procedure; cdecl;
    _g_reserved4: procedure; cdecl;
    _g_reserved5: procedure; cdecl;
  end;


  { TGOutputStream }
  PPGOutputStream = ^PGOutputStream;
  PGOutputStream = ^TGOutputStream;


  { TGOutputStreamSpliceFlags }
  PPGOutputStreamSpliceFlags = ^PGOutputStreamSpliceFlags;
  PGOutputStreamSpliceFlags = ^TGOutputStreamSpliceFlags;


  { TGOutputVector }
  PPGOutputVector = ^PGOutputVector;
  PGOutputVector = ^TGOutputVector;


  { TGOutputStreamPrivate }
  PPGOutputStreamPrivate = ^PGOutputStreamPrivate;
  PGOutputStreamPrivate = ^TGOutputStreamPrivate;
  TGOutputStream = object(TGObject)
    priv: PGOutputStreamPrivate;
    procedure clear_pending; cdecl; inline;
    function close(cancellable: PGCancellable; error: PPGError): gboolean; cdecl; inline;
    procedure close_async(io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function close_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl; inline;
    function flush(cancellable: PGCancellable; error: PPGError): gboolean; cdecl; inline;
    procedure flush_async(io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function flush_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl; inline;
    function has_pending: gboolean; cdecl; inline;
    function is_closed: gboolean; cdecl; inline;
    function is_closing: gboolean; cdecl; inline;
    //function printf(bytes_written: Pgsize; cancellable: PGCancellable; error: PPGError; format: Pgchar; args: array of const): gboolean; cdecl; inline;
    function set_pending(error: PPGError): gboolean; cdecl; inline;
    function splice(source: PGInputStream; flags: TGOutputStreamSpliceFlags; cancellable: PGCancellable; error: PPGError): gssize; cdecl; inline;
    procedure splice_async(source: PGInputStream; flags: TGOutputStreamSpliceFlags; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function splice_finish(result_: PGAsyncResult; error: PPGError): gssize; cdecl; inline;
    //function vprintf(bytes_written: Pgsize; cancellable: PGCancellable; error: PPGError; format: Pgchar; args: Tva_list): gboolean; cdecl; inline;
    function write(buffer: Pguint8; count: gsize; cancellable: PGCancellable; error: PPGError): gssize; cdecl; inline;
    function write_all(buffer: Pguint8; count: gsize; bytes_written: Pgsize; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; inline;
    procedure write_all_async(buffer: Pguint8; count: gsize; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function write_all_finish(result_: PGAsyncResult; bytes_written: Pgsize; error: PPGError): gboolean; cdecl; inline;
    procedure write_async(buffer: Pguint8; count: gsize; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function write_bytes(bytes: PGBytes; cancellable: PGCancellable; error: PPGError): gssize; cdecl; inline;
    procedure write_bytes_async(bytes: PGBytes; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function write_bytes_finish(result_: PGAsyncResult; error: PPGError): gssize; cdecl; inline;
    function write_finish(result_: PGAsyncResult; error: PPGError): gssize; cdecl; inline;
    function writev(vectors: PGOutputVector; n_vectors: gsize; bytes_written: Pgsize; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; inline;
    function writev_all(vectors: PGOutputVector; n_vectors: gsize; bytes_written: Pgsize; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; inline;
    procedure writev_all_async(vectors: PGOutputVector; n_vectors: gsize; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function writev_all_finish(result_: PGAsyncResult; bytes_written: Pgsize; error: PPGError): gboolean; cdecl; inline;
    procedure writev_async(vectors: PGOutputVector; n_vectors: gsize; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function writev_finish(result_: PGAsyncResult; bytes_written: Pgsize; error: PPGError): gboolean; cdecl; inline;
  end;


  { TGBufferedOutputStream }
  PPGBufferedOutputStream = ^PGBufferedOutputStream;
  PGBufferedOutputStream = ^TGBufferedOutputStream;


  { TGFilterOutputStream }
  PPGFilterOutputStream = ^PGFilterOutputStream;
  PGFilterOutputStream = ^TGFilterOutputStream;
  TGFilterOutputStream = object(TGOutputStream)
    base_stream1: PGOutputStream;
    function get_base_stream: PGOutputStream; cdecl; inline;
    function get_close_base_stream: gboolean; cdecl; inline;
    procedure set_close_base_stream(close_base: gboolean); cdecl; inline;
    property base_stream: PGOutputStream read get_base_stream  { property is writeable but setter not declared } ;
    property close_base_stream: gboolean read get_close_base_stream write set_close_base_stream;
  end;


  { TGBufferedOutputStreamPrivate }
  PPGBufferedOutputStreamPrivate = ^PGBufferedOutputStreamPrivate;
  PGBufferedOutputStreamPrivate = ^TGBufferedOutputStreamPrivate;
  TGBufferedOutputStream = object(TGFilterOutputStream)
    priv1: PGBufferedOutputStreamPrivate;
    function new(base_stream: PGOutputStream): PGBufferedOutputStream; cdecl; inline; static;
    function new_sized(base_stream: PGOutputStream; size: gsize): PGBufferedOutputStream; cdecl; inline; static;
    function get_auto_grow: gboolean; cdecl; inline;
    function get_buffer_size: gsize; cdecl; inline;
    procedure set_auto_grow(auto_grow: gboolean); cdecl; inline;
    procedure set_buffer_size(size: gsize); cdecl; inline;
    property auto_grow: gboolean read get_auto_grow write set_auto_grow;
    property buffer_size: gsize read get_buffer_size write set_buffer_size;
  end;

  TGBufferedOutputStreamPrivate = record
  end;




  { TGFilterOutputStreamClass }
  PPGFilterOutputStreamClass = ^PGFilterOutputStreamClass;
  PGFilterOutputStreamClass = ^TGFilterOutputStreamClass;


  { TGOutputStreamClass }
  PPGOutputStreamClass = ^PGOutputStreamClass;
  PGOutputStreamClass = ^TGOutputStreamClass;
  TGOutputStreamClass = object
    parent_class: TGObjectClass;
    write_fn: function(stream: PGOutputStream; buffer: Pguint8; count: gsize; cancellable: PGCancellable; error: PPGError): gssize; cdecl;
    splice: function(stream: PGOutputStream; source: PGInputStream; flags: TGOutputStreamSpliceFlags; cancellable: PGCancellable; error: PPGError): gssize; cdecl;
    flush: function(stream: PGOutputStream; cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
    close_fn: function(stream: PGOutputStream; cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
    write_async: procedure(stream: PGOutputStream; buffer: Pguint8; count: gsize; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    write_finish: function(stream: PGOutputStream; result_: PGAsyncResult; error: PPGError): gssize; cdecl;
    splice_async: procedure(stream: PGOutputStream; source: PGInputStream; flags: TGOutputStreamSpliceFlags; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    splice_finish: function(stream: PGOutputStream; result_: PGAsyncResult; error: PPGError): gssize; cdecl;
    flush_async: procedure(stream: PGOutputStream; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    flush_finish: function(stream: PGOutputStream; result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
    close_async: procedure(stream: PGOutputStream; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    close_finish: function(stream: PGOutputStream; result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
    writev_fn: function(stream: PGOutputStream; vectors: PGOutputVector; n_vectors: gsize; bytes_written: Pgsize; cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
    writev_async: procedure(stream: PGOutputStream; vectors: PGOutputVector; n_vectors: gsize; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    writev_finish: function(stream: PGOutputStream; result_: PGAsyncResult; bytes_written: Pgsize; error: PPGError): gboolean; cdecl;
    _g_reserved4: procedure; cdecl;
    _g_reserved5: procedure; cdecl;
    _g_reserved6: procedure; cdecl;
    _g_reserved7: procedure; cdecl;
    _g_reserved8: procedure; cdecl;
  end;
  TGFilterOutputStreamClass = object
    parent_class: TGOutputStreamClass;
    _g_reserved1: procedure; cdecl;
    _g_reserved2: procedure; cdecl;
    _g_reserved3: procedure; cdecl;
  end;


  { TGBufferedOutputStreamClass }
  PPGBufferedOutputStreamClass = ^PGBufferedOutputStreamClass;
  PGBufferedOutputStreamClass = ^TGBufferedOutputStreamClass;
  TGBufferedOutputStreamClass = object
    parent_class: TGFilterOutputStreamClass;
    _g_reserved1: procedure; cdecl;
    _g_reserved2: procedure; cdecl;
  end;
  TGBusAcquiredCallback = procedure(connection: PGDBusConnection; name: Pgchar; user_data: gpointer); cdecl;
  TGBusNameAcquiredCallback = procedure(connection: PGDBusConnection; name: Pgchar; user_data: gpointer); cdecl;
  TGBusNameAppearedCallback = procedure(connection: PGDBusConnection; name: Pgchar; name_owner: Pgchar; user_data: gpointer); cdecl;
  TGBusNameLostCallback = procedure(connection: PGDBusConnection; name: Pgchar; user_data: gpointer); cdecl;


  { TGBusNameOwnerFlags }
  PPGBusNameOwnerFlags = ^PGBusNameOwnerFlags;
  PGBusNameOwnerFlags = ^TGBusNameOwnerFlags;
  TGBusNameVanishedCallback = procedure(connection: PGDBusConnection; name: Pgchar; user_data: gpointer); cdecl;


  { TGBusNameWatcherFlags }
  PPGBusNameWatcherFlags = ^PGBusNameWatcherFlags;
  PGBusNameWatcherFlags = ^TGBusNameWatcherFlags;


  { TGBusType }
  PPGBusType = ^PGBusType;
  PGBusType = ^TGBusType;


  { TGLoadableIcon }
  PPGLoadableIcon = ^PGLoadableIcon;
  PGLoadableIcon = ^TGLoadableIcon;
  TGLoadableIcon = object
    function load(size: gint; type_: PPgchar; cancellable: PGCancellable; error: PPGError): PGInputStream; cdecl; inline;
    procedure load_async(size: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function load_finish(res: PGAsyncResult; type_: PPgchar; error: PPGError): PGInputStream; cdecl; inline;
  end;


  { TGBytesIcon }
  PPGBytesIcon = ^PGBytesIcon;
  PGBytesIcon = ^TGBytesIcon;
  TGBytesIcon = object(TGObject)
    function new(bytes: PGBytes): PGBytesIcon; cdecl; inline; static;
    function get_bytes: PGBytes; cdecl; inline;
    property bytes: PGBytes read get_bytes  { property is writeable but setter not declared } ;
  end;

  TGCancellablePrivate = record
  end;




  { TGCancellableClass }
  PPGCancellableClass = ^PGCancellableClass;
  PGCancellableClass = ^TGCancellableClass;
  TGCancellableClass = object
    parent_class: TGObjectClass;
    cancelled: procedure(cancellable: PGCancellable); cdecl;
    _g_reserved1: procedure; cdecl;
    _g_reserved2: procedure; cdecl;
    _g_reserved3: procedure; cdecl;
    _g_reserved4: procedure; cdecl;
    _g_reserved5: procedure; cdecl;
  end;
  TGCancellableSourceFunc = function(cancellable: PGCancellable; user_data: gpointer): gboolean; cdecl;


  { TGConverter }
  PPGConverter = ^PGConverter;
  PGConverter = ^TGConverter;


  { TGConverterResult }
  PPGConverterResult = ^PGConverterResult;
  PGConverterResult = ^TGConverterResult;


  { TGConverterFlags }
  PPGConverterFlags = ^PGConverterFlags;
  PGConverterFlags = ^TGConverterFlags;
  TGConverter = object
    function convert(inbuf: Pguint8; inbuf_size: gsize; outbuf: Pguint8; outbuf_size: gsize; flags: TGConverterFlags; bytes_read: Pgsize; bytes_written: Pgsize; error: PPGError): TGConverterResult; cdecl; inline;
    procedure reset; cdecl; inline;
  end;


  { TGInitable }
  PPGInitable = ^PGInitable;
  PGInitable = ^TGInitable;
  TGInitable = object
    //function new(object_type: TGType; cancellable: PGCancellable; error: PPGError; first_property_name: Pgchar; args: array of const): PGObject; cdecl; inline; static;
    //function new_valist(object_type: TGType; first_property_name: Pgchar; var_args: Tva_list; cancellable: PGCancellable; error: PPGError): PGObject; cdecl; inline; static;
    function init(cancellable: PGCancellable; error: PPGError): gboolean; cdecl; inline;
  end;


  { TGCharsetConverter }
  PPGCharsetConverter = ^PGCharsetConverter;
  PGCharsetConverter = ^TGCharsetConverter;
  TGCharsetConverter = object(TGObject)
    function new(to_charset: Pgchar; from_charset: Pgchar; error: PPGError): PGCharsetConverter; cdecl; inline; static;
    function get_num_fallbacks: guint; cdecl; inline;
    function get_use_fallback: gboolean; cdecl; inline;
    procedure set_use_fallback(use_fallback: gboolean); cdecl; inline;
    //property from_charset: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_from_charset  { property is writeable but setter not declared } ;
    //property to_charset: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_to_charset  { property is writeable but setter not declared } ;
    property use_fallback: gboolean read get_use_fallback write set_use_fallback;
  end;


  { TGCharsetConverterClass }
  PPGCharsetConverterClass = ^PGCharsetConverterClass;
  PGCharsetConverterClass = ^TGCharsetConverterClass;
  TGCharsetConverterClass = object
    parent_class: TGObjectClass;
  end;


  { TGConverterIface }
  PPGConverterIface = ^PGConverterIface;
  PGConverterIface = ^TGConverterIface;
  TGConverterIface = object
    g_iface: TGTypeInterface;
    convert: function(converter: PGConverter; inbuf: Pguint8; inbuf_size: gsize; outbuf: Pguint8; outbuf_size: gsize; flags: TGConverterFlags; bytes_read: Pgsize; bytes_written: Pgsize; error: PPGError): TGConverterResult; cdecl;
    reset: procedure(converter: PGConverter); cdecl;
  end;


  { TGPollableInputStream }
  PPGPollableInputStream = ^PGPollableInputStream;
  PGPollableInputStream = ^TGPollableInputStream;
  TGPollableInputStream = object
    function can_poll: gboolean; cdecl; inline;
    function create_source(cancellable: PGCancellable): PGSource; cdecl; inline;
    function is_readable: gboolean; cdecl; inline;
    function read_nonblocking(buffer: Pguint8; count: gsize; cancellable: PGCancellable; error: PPGError): gssize; cdecl; inline;
  end;


  { TGConverterInputStream }
  PPGConverterInputStream = ^PGConverterInputStream;
  PGConverterInputStream = ^TGConverterInputStream;


  { TGConverterInputStreamPrivate }
  PPGConverterInputStreamPrivate = ^PGConverterInputStreamPrivate;
  PGConverterInputStreamPrivate = ^TGConverterInputStreamPrivate;
  TGConverterInputStream = object(TGFilterInputStream)
    priv1: PGConverterInputStreamPrivate;
    function new(base_stream: PGInputStream; converter: PGConverter): PGConverterInputStream; cdecl; inline; static;
    function get_converter: PGConverter; cdecl; inline;
    property converter: PGConverter read get_converter  { property is writeable but setter not declared } ;
  end;

  TGConverterInputStreamPrivate = record
  end;




  { TGConverterInputStreamClass }
  PPGConverterInputStreamClass = ^PGConverterInputStreamClass;
  PGConverterInputStreamClass = ^TGConverterInputStreamClass;
  TGConverterInputStreamClass = object
    parent_class: TGFilterInputStreamClass;
    _g_reserved1: procedure; cdecl;
    _g_reserved2: procedure; cdecl;
    _g_reserved3: procedure; cdecl;
    _g_reserved4: procedure; cdecl;
    _g_reserved5: procedure; cdecl;
  end;


  { TGPollableOutputStream }
  PPGPollableOutputStream = ^PGPollableOutputStream;
  PGPollableOutputStream = ^TGPollableOutputStream;


  { TGPollableReturn }
  PPGPollableReturn = ^PGPollableReturn;
  PGPollableReturn = ^TGPollableReturn;
  TGPollableOutputStream = object
    function can_poll: gboolean; cdecl; inline;
    function create_source(cancellable: PGCancellable): PGSource; cdecl; inline;
    function is_writable: gboolean; cdecl; inline;
    function write_nonblocking(buffer: Pguint8; count: gsize; cancellable: PGCancellable; error: PPGError): gssize; cdecl; inline;
    function writev_nonblocking(vectors: PGOutputVector; n_vectors: gsize; bytes_written: Pgsize; cancellable: PGCancellable; error: PPGError): TGPollableReturn; cdecl; inline;
  end;


  { TGConverterOutputStream }
  PPGConverterOutputStream = ^PGConverterOutputStream;
  PGConverterOutputStream = ^TGConverterOutputStream;


  { TGConverterOutputStreamPrivate }
  PPGConverterOutputStreamPrivate = ^PGConverterOutputStreamPrivate;
  PGConverterOutputStreamPrivate = ^TGConverterOutputStreamPrivate;
  TGConverterOutputStream = object(TGFilterOutputStream)
    priv1: PGConverterOutputStreamPrivate;
    function new(base_stream: PGOutputStream; converter: PGConverter): PGConverterOutputStream; cdecl; inline; static;
    function get_converter: PGConverter; cdecl; inline;
    property converter: PGConverter read get_converter  { property is writeable but setter not declared } ;
  end;

  TGConverterOutputStreamPrivate = record
  end;




  { TGConverterOutputStreamClass }
  PPGConverterOutputStreamClass = ^PGConverterOutputStreamClass;
  PGConverterOutputStreamClass = ^TGConverterOutputStreamClass;
  TGConverterOutputStreamClass = object
    parent_class: TGFilterOutputStreamClass;
    _g_reserved1: procedure; cdecl;
    _g_reserved2: procedure; cdecl;
    _g_reserved3: procedure; cdecl;
    _g_reserved4: procedure; cdecl;
    _g_reserved5: procedure; cdecl;
  end;


  { TGCredentialsType }
  PPGCredentialsType = ^PGCredentialsType;
  PGCredentialsType = ^TGCredentialsType;
  TGCredentials = object(TGObject)
    function new: PGCredentials; cdecl; inline; static;
    function get_native(native_type: TGCredentialsType): gpointer; cdecl; inline;
    function get_unix_pid(error: PPGError): gint; cdecl; inline;
    function get_unix_user(error: PPGError): guint; cdecl; inline;
    function is_same_user(other_credentials: PGCredentials; error: PPGError): gboolean; cdecl; inline;
    procedure set_native(native_type: TGCredentialsType; native: gpointer); cdecl; inline;
    function set_unix_user(uid: guint; error: PPGError): gboolean; cdecl; inline;
    function to_string: Pgchar; cdecl; inline;
  end;


  { TGCredentialsClass }
  PPGCredentialsClass = ^PGCredentialsClass;
  PGCredentialsClass = ^TGCredentialsClass;
  TGCredentialsClass = object
  end;


  { TGRemoteActionGroup }
  PPGRemoteActionGroup = ^PGRemoteActionGroup;
  PGRemoteActionGroup = ^TGRemoteActionGroup;
  TGRemoteActionGroup = object
    procedure activate_action_full(action_name: Pgchar; parameter: PGVariant; platform_data: PGVariant); cdecl; inline;
    procedure change_action_state_full(action_name: Pgchar; value: PGVariant; platform_data: PGVariant); cdecl; inline;
  end;


  { TGDBusActionGroup }
  PPGDBusActionGroup = ^PGDBusActionGroup;
  PGDBusActionGroup = ^TGDBusActionGroup;
  TGDBusActionGroup = object(TGObject)
    function get(connection: PGDBusConnection; bus_name: Pgchar; object_path: Pgchar): PGDBusActionGroup; cdecl; inline; static;
  end;


  { TGDBusAnnotationInfo }
  PPGDBusAnnotationInfo = ^PGDBusAnnotationInfo;
  PGDBusAnnotationInfo = ^TGDBusAnnotationInfo;
  TGDBusAnnotationInfo = object
    ref_count: gint;
    key: Pgchar;
    value: Pgchar;
    annotations: PPGDBusAnnotationInfo;
    function ref: PGDBusAnnotationInfo; cdecl; inline;
    procedure unref; cdecl; inline;
    function lookup(annotations: PPGDBusAnnotationInfo; name: Pgchar): Pgchar; cdecl; inline; static;
  end;


  { TGDBusArgInfo }
  PPGDBusArgInfo = ^PGDBusArgInfo;
  PGDBusArgInfo = ^TGDBusArgInfo;
  TGDBusArgInfo = object
    ref_count: gint;
    name: Pgchar;
    signature: Pgchar;
    annotations: PPGDBusAnnotationInfo;
    function ref: PGDBusArgInfo; cdecl; inline;
    procedure unref; cdecl; inline;
  end;
  TGDBusAuthObserver = object(TGObject)
    function new: PGDBusAuthObserver; cdecl; inline; static;
    function allow_mechanism(mechanism: Pgchar): gboolean; cdecl; inline;
    function authorize_authenticated_peer(stream: PGIOStream; credentials: PGCredentials): gboolean; cdecl; inline;
  end;


  { TGIOStreamSpliceFlags }
  PPGIOStreamSpliceFlags = ^PGIOStreamSpliceFlags;
  PGIOStreamSpliceFlags = ^TGIOStreamSpliceFlags;


  { TGIOStreamPrivate }
  PPGIOStreamPrivate = ^PGIOStreamPrivate;
  PGIOStreamPrivate = ^TGIOStreamPrivate;
  TGIOStream = object(TGObject)
    priv: PGIOStreamPrivate;
    function splice_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl; inline; static;
    procedure clear_pending; cdecl; inline;
    function close(cancellable: PGCancellable; error: PPGError): gboolean; cdecl; inline;
    procedure close_async(io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function close_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl; inline;
    function get_input_stream: PGInputStream; cdecl; inline;
    function get_output_stream: PGOutputStream; cdecl; inline;
    function has_pending: gboolean; cdecl; inline;
    function is_closed: gboolean; cdecl; inline;
    function set_pending(error: PPGError): gboolean; cdecl; inline;
    procedure splice_async(stream2: PGIOStream; flags: TGIOStreamSpliceFlags; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    //property closed: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_closed ;
    property input_stream: PGInputStream read get_input_stream ;
    property output_stream: PGOutputStream read get_output_stream ;
  end;


  { TGUnixFDListPrivate }
  PPGUnixFDListPrivate = ^PGUnixFDListPrivate;
  PGUnixFDListPrivate = ^TGUnixFDListPrivate;
  TGUnixFDList = object(TGObject)
    priv: PGUnixFDListPrivate;
    function new: PGUnixFDList; cdecl; inline; static;
    function new_from_array(fds: Pgint; n_fds: gint): PGUnixFDList; cdecl; inline; static;
    function append(fd: gint; error: PPGError): gint; cdecl; inline;
    function get(index_: gint; error: PPGError): gint; cdecl; inline;
    function get_length: gint; cdecl; inline;
    function peek_fds(length: Pgint): Pgint; cdecl; inline;
    function steal_fds(length: Pgint): Pgint; cdecl; inline;
  end;


  { TGMenuAttributeIter }
  PPGMenuAttributeIter = ^PGMenuAttributeIter;
  PGMenuAttributeIter = ^TGMenuAttributeIter;


  { TGMenuLinkIter }
  PPGMenuLinkIter = ^PGMenuLinkIter;
  PGMenuLinkIter = ^TGMenuLinkIter;


  { TGMenuModelPrivate }
  PPGMenuModelPrivate = ^PGMenuModelPrivate;
  PGMenuModelPrivate = ^TGMenuModelPrivate;
  TGMenuModel = object(TGObject)
    priv: PGMenuModelPrivate;
    //function get_item_attribute(item_index: gint; attribute: Pgchar; format_string: Pgchar; args: array of const): gboolean; cdecl; inline;
    function get_item_attribute_value(item_index: gint; attribute: Pgchar; expected_type: PGVariantType): PGVariant; cdecl; inline;
    function get_item_link(item_index: gint; link: Pgchar): PGMenuModel; cdecl; inline;
    function get_n_items: gint; cdecl; inline;
    function is_mutable: gboolean; cdecl; inline;
    procedure items_changed(position: gint; removed: gint; added: gint); cdecl; inline;
    function iterate_item_attributes(item_index: gint): PGMenuAttributeIter; cdecl; inline;
    function iterate_item_links(item_index: gint): PGMenuLinkIter; cdecl; inline;
  end;


  { TGDBusMethodInfo }
  PPGDBusMethodInfo = ^PGDBusMethodInfo;
  PGDBusMethodInfo = ^TGDBusMethodInfo;


  { TGDBusPropertyInfo }
  PPGDBusPropertyInfo = ^PGDBusPropertyInfo;
  PGDBusPropertyInfo = ^TGDBusPropertyInfo;


  { TGDBusSignalInfo }
  PPGDBusSignalInfo = ^PGDBusSignalInfo;
  PGDBusSignalInfo = ^TGDBusSignalInfo;
  TGDBusInterfaceInfo = object
    ref_count: gint;
    name: Pgchar;
    methods: PPGDBusMethodInfo;
    signals: PPGDBusSignalInfo;
    properties: PPGDBusPropertyInfo;
    annotations: PPGDBusAnnotationInfo;
    procedure cache_build; cdecl; inline;
    procedure cache_release; cdecl; inline;
    procedure generate_xml(indent: guint; string_builder: PGString); cdecl; inline;
    function lookup_method(name: Pgchar): PGDBusMethodInfo; cdecl; inline;
    function lookup_property(name: Pgchar): PGDBusPropertyInfo; cdecl; inline;
    function lookup_signal(name: Pgchar): PGDBusSignalInfo; cdecl; inline;
    function ref: PGDBusInterfaceInfo; cdecl; inline;
    procedure unref; cdecl; inline;
  end;


  { TGDBusInterfaceMethodCallFunc }
  PPGDBusInterfaceMethodCallFunc = ^PGDBusInterfaceMethodCallFunc;
  PGDBusInterfaceMethodCallFunc = ^TGDBusInterfaceMethodCallFunc;


  { TGDBusMethodInvocation }
  PPGDBusMethodInvocation = ^PGDBusMethodInvocation;
  PGDBusMethodInvocation = ^TGDBusMethodInvocation;
  TGDBusInterfaceMethodCallFunc = procedure(connection: PGDBusConnection; sender: Pgchar; object_path: Pgchar; interface_name: Pgchar; method_name: Pgchar; parameters: PGVariant; invocation: PGDBusMethodInvocation; user_data: gpointer); cdecl;


  { TGDBusInterfaceGetPropertyFunc }
  PPGDBusInterfaceGetPropertyFunc = ^PGDBusInterfaceGetPropertyFunc;
  PGDBusInterfaceGetPropertyFunc = ^TGDBusInterfaceGetPropertyFunc;
  TGDBusInterfaceGetPropertyFunc = function(connection: PGDBusConnection; sender: Pgchar; object_path: Pgchar; interface_name: Pgchar; property_name: Pgchar; error: PPGError; user_data: gpointer): PGVariant; cdecl;


  { TGDBusInterfaceSetPropertyFunc }
  PPGDBusInterfaceSetPropertyFunc = ^PGDBusInterfaceSetPropertyFunc;
  PGDBusInterfaceSetPropertyFunc = ^TGDBusInterfaceSetPropertyFunc;
  TGDBusInterfaceSetPropertyFunc = function(connection: PGDBusConnection; sender: Pgchar; object_path: Pgchar; interface_name: Pgchar; property_name: Pgchar; value: PGVariant; error: PPGError; user_data: gpointer): gboolean; cdecl;

  TGDBusInterfaceVTable = record
    method_call: TGDBusInterfaceMethodCallFunc;
    get_property: TGDBusInterfaceGetPropertyFunc;
    set_property: TGDBusInterfaceSetPropertyFunc;
    padding: array [0..7] of gpointer;
  end;




  { TGDBusSubtreeEnumerateFunc }
  PPGDBusSubtreeEnumerateFunc = ^PGDBusSubtreeEnumerateFunc;
  PGDBusSubtreeEnumerateFunc = ^TGDBusSubtreeEnumerateFunc;
  TGDBusSubtreeEnumerateFunc = function(connection: PGDBusConnection; sender: Pgchar; object_path: Pgchar; user_data: gpointer): PPgchar; cdecl;


  { TGDBusSubtreeIntrospectFunc }
  PPGDBusSubtreeIntrospectFunc = ^PGDBusSubtreeIntrospectFunc;
  PGDBusSubtreeIntrospectFunc = ^TGDBusSubtreeIntrospectFunc;
  TGDBusSubtreeIntrospectFunc = function(connection: PGDBusConnection; sender: Pgchar; object_path: Pgchar; node: Pgchar; user_data: gpointer): PPGDBusInterfaceInfo; cdecl;


  { TGDBusSubtreeDispatchFunc }
  PPGDBusSubtreeDispatchFunc = ^PGDBusSubtreeDispatchFunc;
  PGDBusSubtreeDispatchFunc = ^TGDBusSubtreeDispatchFunc;
  TGDBusSubtreeDispatchFunc = function(connection: PGDBusConnection; sender: Pgchar; object_path: Pgchar; interface_name: Pgchar; node: Pgchar; out_user_data: Pgpointer; user_data: gpointer): PGDBusInterfaceVTable; cdecl;

  TGDBusSubtreeVTable = record
    enumerate: TGDBusSubtreeEnumerateFunc;
    introspect: TGDBusSubtreeIntrospectFunc;
    dispatch: TGDBusSubtreeDispatchFunc;
    padding: array [0..7] of gpointer;
  end;




  { TGDBusMessageByteOrder }
  PPGDBusMessageByteOrder = ^PGDBusMessageByteOrder;
  PGDBusMessageByteOrder = ^TGDBusMessageByteOrder;


  { TGDBusMessageFlags }
  PPGDBusMessageFlags = ^PGDBusMessageFlags;
  PGDBusMessageFlags = ^TGDBusMessageFlags;


  { TGDBusMessageHeaderField }
  PPGDBusMessageHeaderField = ^PGDBusMessageHeaderField;
  PGDBusMessageHeaderField = ^TGDBusMessageHeaderField;


  { TGDBusMessageType }
  PPGDBusMessageType = ^PGDBusMessageType;
  PGDBusMessageType = ^TGDBusMessageType;
  TGDBusMessage = object(TGObject)
    function new: PGDBusMessage; cdecl; inline; static;
    function new_from_blob(blob: Pguint8; blob_len: gsize; capabilities: TGDBusCapabilityFlags; error: PPGError): PGDBusMessage; cdecl; inline; static;
    function new_method_call(name: Pgchar; path: Pgchar; interface_: Pgchar; method: Pgchar): PGDBusMessage; cdecl; inline; static;
    function new_signal(path: Pgchar; interface_: Pgchar; signal: Pgchar): PGDBusMessage; cdecl; inline; static;
    function bytes_needed(blob: Pguint8; blob_len: gsize; error: PPGError): gssize; cdecl; inline; static;
    function copy(error: PPGError): PGDBusMessage; cdecl; inline;
    function get_arg0: Pgchar; cdecl; inline;
    function get_body: PGVariant; cdecl; inline;
    function get_byte_order: TGDBusMessageByteOrder; cdecl; inline;
    function get_destination: Pgchar; cdecl; inline;
    function get_error_name: Pgchar; cdecl; inline;
    function get_flags: TGDBusMessageFlags; cdecl; inline;
    function get_header(header_field: TGDBusMessageHeaderField): PGVariant; cdecl; inline;
    function get_header_fields: Pguint8; cdecl; inline;
    function get_interface: Pgchar; cdecl; inline;
    function get_locked: gboolean; cdecl; inline;
    function get_member: Pgchar; cdecl; inline;
    function get_message_type: TGDBusMessageType; cdecl; inline;
    function get_num_unix_fds: guint32; cdecl; inline;
    function get_path: Pgchar; cdecl; inline;
    function get_reply_serial: guint32; cdecl; inline;
    function get_sender: Pgchar; cdecl; inline;
    function get_serial: guint32; cdecl; inline;
    function get_signature: Pgchar; cdecl; inline;
    function get_unix_fd_list: PGUnixFDList; cdecl; inline;
    procedure lock; cdecl; inline;
    //function new_method_error(error_name: Pgchar; error_message_format: Pgchar; args: array of const): PGDBusMessage; cdecl; inline;
    function new_method_error_literal(error_name: Pgchar; error_message: Pgchar): PGDBusMessage; cdecl; inline;
    //function new_method_error_valist(error_name: Pgchar; error_message_format: Pgchar; var_args: Tva_list): PGDBusMessage; cdecl; inline;
    function new_method_reply: PGDBusMessage; cdecl; inline;
    function print(indent: guint): Pgchar; cdecl; inline;
    procedure set_body(body: PGVariant); cdecl; inline;
    procedure set_byte_order(byte_order: TGDBusMessageByteOrder); cdecl; inline;
    procedure set_destination(value: Pgchar); cdecl; inline;
    procedure set_error_name(value: Pgchar); cdecl; inline;
    procedure set_flags(flags: TGDBusMessageFlags); cdecl; inline;
    procedure set_header(header_field: TGDBusMessageHeaderField; value: PGVariant); cdecl; inline;
    procedure set_interface(value: Pgchar); cdecl; inline;
    procedure set_member(value: Pgchar); cdecl; inline;
    procedure set_message_type(type_: TGDBusMessageType); cdecl; inline;
    procedure set_num_unix_fds(value: guint32); cdecl; inline;
    procedure set_path(value: Pgchar); cdecl; inline;
    procedure set_reply_serial(value: guint32); cdecl; inline;
    procedure set_sender(value: Pgchar); cdecl; inline;
    procedure set_serial(serial: guint32); cdecl; inline;
    procedure set_signature(value: Pgchar); cdecl; inline;
    procedure set_unix_fd_list(fd_list: PGUnixFDList); cdecl; inline;
    function to_blob(out_size: Pgsize; capabilities: TGDBusCapabilityFlags; error: PPGError): Pguint8; cdecl; inline;
    function to_gerror(error: PPGError): gboolean; cdecl; inline;
    property locked: gboolean read get_locked ;
  end;


  { TGDBusErrorEntry }
  PPPGDBusErrorEntry = ^PPGDBusErrorEntry;
  PPGDBusErrorEntry = ^PGDBusErrorEntry;
  PGDBusErrorEntry = ^TGDBusErrorEntry;

  TGDBusErrorEntry = record
    error_code: gint;
    dbus_error_name: Pgchar;
  end;




  { TGDBusError }
  PPGDBusError = ^PGDBusError;
  PGDBusError = ^TGDBusError;


  { TGDBusObject }
  PPGDBusObject = ^PGDBusObject;
  PGDBusObject = ^TGDBusObject;


  { TGDBusInterface }
  PPGDBusInterface = ^PGDBusInterface;
  PGDBusInterface = ^TGDBusInterface;
  TGDBusInterface = object
    function dup_object: PGDBusObject; cdecl; inline;
    function get_info: PGDBusInterfaceInfo; cdecl; inline;
    function get_object: PGDBusObject; cdecl; inline;
    procedure set_object(object_: PGDBusObject); cdecl; inline;
  end;
  TGDBusObject = object
    interface_added: procedure(interface_: TGDBusInterface); cdecl;
    interface_removed: procedure(interface_: TGDBusInterface); cdecl;
    function get_interface(interface_name: Pgchar): PGDBusInterface; cdecl; inline;
    function get_interfaces: PGList; cdecl; inline;
    function get_object_path: Pgchar; cdecl; inline;
  end;


  { TGDBusInterfaceIface }
  PPGDBusInterfaceIface = ^PGDBusInterfaceIface;
  PGDBusInterfaceIface = ^TGDBusInterfaceIface;
  TGDBusInterfaceIface = object
    parent_iface: TGTypeInterface;
    get_info: function(interface_: PGDBusInterface): PGDBusInterfaceInfo; cdecl;
    get_object: function(interface_: PGDBusInterface): PGDBusObject; cdecl;
    set_object: procedure(interface_: PGDBusInterface; object_: PGDBusObject); cdecl;
    dup_object: function(interface_: PGDBusInterface): PGDBusObject; cdecl;
  end;
  TGDBusMethodInfo = object
    ref_count: gint;
    name: Pgchar;
    in_args: PPGDBusArgInfo;
    out_args: PPGDBusArgInfo;
    annotations: PPGDBusAnnotationInfo;
    function ref: PGDBusMethodInfo; cdecl; inline;
    procedure unref; cdecl; inline;
  end;
  TGDBusSignalInfo = object
    ref_count: gint;
    name: Pgchar;
    args: PPGDBusArgInfo;
    annotations: PPGDBusAnnotationInfo;
    function ref: PGDBusSignalInfo; cdecl; inline;
    procedure unref; cdecl; inline;
  end;


  { TGDBusPropertyInfoFlags }
  PPGDBusPropertyInfoFlags = ^PGDBusPropertyInfoFlags;
  PGDBusPropertyInfoFlags = ^TGDBusPropertyInfoFlags;
  TGDBusPropertyInfo = object
    ref_count: gint;
    name: Pgchar;
    signature: Pgchar;
    flags: TGDBusPropertyInfoFlags;
    annotations: PPGDBusAnnotationInfo;
    function ref: PGDBusPropertyInfo; cdecl; inline;
    procedure unref; cdecl; inline;
  end;
  TGDBusMethodInvocation = object(TGObject)
    function get_connection: PGDBusConnection; cdecl; inline;
    function get_interface_name: Pgchar; cdecl; inline;
    function get_message: PGDBusMessage; cdecl; inline;
    function get_method_info: PGDBusMethodInfo; cdecl; inline;
    function get_method_name: Pgchar; cdecl; inline;
    function get_object_path: Pgchar; cdecl; inline;
    function get_parameters: PGVariant; cdecl; inline;
    function get_property_info: PGDBusPropertyInfo; cdecl; inline;
    function get_sender: Pgchar; cdecl; inline;
    function get_user_data: gpointer; cdecl; inline;
    procedure return_dbus_error(error_name: Pgchar; error_message: Pgchar); cdecl; inline;
    //procedure return_error(domain: TGQuark; code: gint; format: Pgchar; args: array of const); cdecl; inline;
    procedure return_error_literal(domain: TGQuark; code: gint; message: Pgchar); cdecl; inline;
    //procedure return_error_valist(domain: TGQuark; code: gint; format: Pgchar; var_args: Tva_list); cdecl; inline;
    procedure return_gerror(error: PGError); cdecl; inline;
    procedure return_value(parameters: PGVariant); cdecl; inline;
    procedure return_value_with_unix_fd_list(parameters: PGVariant; fd_list: PGUnixFDList); cdecl; inline;
    procedure take_error(error: PGError); cdecl; inline;
  end;


  { TGDBusInterfaceSkeleton }
  PPGDBusInterfaceSkeleton = ^PGDBusInterfaceSkeleton;
  PGDBusInterfaceSkeleton = ^TGDBusInterfaceSkeleton;


  { TGDBusInterfaceSkeletonFlags }
  PPGDBusInterfaceSkeletonFlags = ^PGDBusInterfaceSkeletonFlags;
  PGDBusInterfaceSkeletonFlags = ^TGDBusInterfaceSkeletonFlags;


  { TGDBusInterfaceSkeletonPrivate }
  PPGDBusInterfaceSkeletonPrivate = ^PGDBusInterfaceSkeletonPrivate;
  PGDBusInterfaceSkeletonPrivate = ^TGDBusInterfaceSkeletonPrivate;
  TGDBusInterfaceSkeleton = object(TGObject)
    priv: PGDBusInterfaceSkeletonPrivate;
    function export(connection: PGDBusConnection; object_path: Pgchar; error: PPGError): gboolean; cdecl; inline;
    procedure flush; cdecl; inline;
    function get_connection: PGDBusConnection; cdecl; inline;
    function get_connections: PGList; cdecl; inline;
    function get_flags: TGDBusInterfaceSkeletonFlags; cdecl; inline;
    function get_info: PGDBusInterfaceInfo; cdecl; inline;
    function get_object_path: Pgchar; cdecl; inline;
    function get_properties: PGVariant; cdecl; inline;
    function get_vtable: PGDBusInterfaceVTable; cdecl; inline;
    function has_connection(connection: PGDBusConnection): gboolean; cdecl; inline;
    procedure set_flags(flags: TGDBusInterfaceSkeletonFlags); cdecl; inline;
    procedure unexport; cdecl; inline;
    procedure unexport_from_connection(connection: PGDBusConnection); cdecl; inline;
    //property g_flags: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_g_flags  { property is writeable but setter not declared } ;
  end;

  TGDBusInterfaceSkeletonPrivate = record
  end;




  { TGDBusInterfaceSkeletonClass }
  PPGDBusInterfaceSkeletonClass = ^PGDBusInterfaceSkeletonClass;
  PGDBusInterfaceSkeletonClass = ^TGDBusInterfaceSkeletonClass;
  TGDBusInterfaceSkeletonClass = object
    parent_class: TGObjectClass;
    get_info: function(interface_: PGDBusInterfaceSkeleton): PGDBusInterfaceInfo; cdecl;
    get_vtable: function(interface_: PGDBusInterfaceSkeleton): PGDBusInterfaceVTable; cdecl;
    get_properties: function(interface_: PGDBusInterfaceSkeleton): PGVariant; cdecl;
    flush: procedure(interface_: PGDBusInterfaceSkeleton); cdecl;
    vfunc_padding: array [0..7] of gpointer;
    g_authorize_method: function(interface_: PGDBusInterfaceSkeleton; invocation: PGDBusMethodInvocation): gboolean; cdecl;
    signal_padding: array [0..7] of gpointer;
  end;


  { TGDBusMenuModel }
  PPGDBusMenuModel = ^PGDBusMenuModel;
  PGDBusMenuModel = ^TGDBusMenuModel;
  TGDBusMenuModel = object(TGMenuModel)
    function get(connection: PGDBusConnection; bus_name: Pgchar; object_path: Pgchar): PGDBusMenuModel; cdecl; inline; static;
  end;


  { TGDBusNodeInfo }
  PPGDBusNodeInfo = ^PGDBusNodeInfo;
  PGDBusNodeInfo = ^TGDBusNodeInfo;
  TGDBusNodeInfo = object
    ref_count: gint;
    path: Pgchar;
    interfaces: PPGDBusInterfaceInfo;
    nodes: PPGDBusNodeInfo;
    annotations: PPGDBusAnnotationInfo;
    function new_for_xml(xml_data: Pgchar; error: PPGError): PGDBusNodeInfo; cdecl; inline; static;
    procedure generate_xml(indent: guint; string_builder: PGString); cdecl; inline;
    function lookup_interface(name: Pgchar): PGDBusInterfaceInfo; cdecl; inline;
    function ref: PGDBusNodeInfo; cdecl; inline;
    procedure unref; cdecl; inline;
  end;


  { TGDBusObjectIface }
  PPGDBusObjectIface = ^PGDBusObjectIface;
  PGDBusObjectIface = ^TGDBusObjectIface;
  TGDBusObjectIface = object
    parent_iface: TGTypeInterface;
    get_object_path: function(object_: PGDBusObject): Pgchar; cdecl;
    get_interfaces: function(object_: PGDBusObject): PGList; cdecl;
    get_interface: function(object_: PGDBusObject; interface_name: Pgchar): PGDBusInterface; cdecl;
    interface_added: procedure(object_: PGDBusObject; interface_: PGDBusInterface); cdecl;
    interface_removed: procedure(object_: PGDBusObject; interface_: PGDBusInterface); cdecl;
  end;


  { TGDBusObjectManager }
  PPGDBusObjectManager = ^PGDBusObjectManager;
  PGDBusObjectManager = ^TGDBusObjectManager;
  TGDBusObjectManager = object
    interface_added: procedure(object_: TGDBusObject; interface_: TGDBusInterface); cdecl;
    interface_removed: procedure(object_: TGDBusObject; interface_: TGDBusInterface); cdecl;
    object_added: procedure(object_: TGDBusObject); cdecl;
    object_removed: procedure(object_: TGDBusObject); cdecl;
    function get_interface(object_path: Pgchar; interface_name: Pgchar): PGDBusInterface; cdecl; inline;
    function get_object(object_path: Pgchar): PGDBusObject; cdecl; inline;
    function get_object_path: Pgchar; cdecl; inline;
    function get_objects: PGList; cdecl; inline;
  end;


  { TGDBusObjectManagerClient }
  PPGDBusObjectManagerClient = ^PGDBusObjectManagerClient;
  PGDBusObjectManagerClient = ^TGDBusObjectManagerClient;


  { TGDBusObjectManagerClientFlags }
  PPGDBusObjectManagerClientFlags = ^PGDBusObjectManagerClientFlags;
  PGDBusObjectManagerClientFlags = ^TGDBusObjectManagerClientFlags;


  { TGDBusProxyTypeFunc }
  PPGDBusProxyTypeFunc = ^PGDBusProxyTypeFunc;
  PGDBusProxyTypeFunc = ^TGDBusProxyTypeFunc;
  TGDBusProxyTypeFunc = function(manager: PGDBusObjectManagerClient; object_path: Pgchar; interface_name: Pgchar; user_data: gpointer): TGType; cdecl;


  { TGDBusObjectManagerClientPrivate }
  PPGDBusObjectManagerClientPrivate = ^PGDBusObjectManagerClientPrivate;
  PGDBusObjectManagerClientPrivate = ^TGDBusObjectManagerClientPrivate;
  TGDBusObjectManagerClient = object(TGObject)
    priv: PGDBusObjectManagerClientPrivate;
    function new_finish(res: PGAsyncResult; error: PPGError): PGDBusObjectManagerClient; cdecl; inline; static;
    function new_for_bus_finish(res: PGAsyncResult; error: PPGError): PGDBusObjectManagerClient; cdecl; inline; static;
    function new_for_bus_sync(bus_type: TGBusType; flags: TGDBusObjectManagerClientFlags; name: Pgchar; object_path: Pgchar; get_proxy_type_func: TGDBusProxyTypeFunc; get_proxy_type_user_data: gpointer; get_proxy_type_destroy_notify: TGDestroyNotify; cancellable: PGCancellable; error: PPGError): PGDBusObjectManagerClient; cdecl; inline; static;
    function new_sync(connection: PGDBusConnection; flags: TGDBusObjectManagerClientFlags; name: Pgchar; object_path: Pgchar; get_proxy_type_func: TGDBusProxyTypeFunc; get_proxy_type_user_data: gpointer; get_proxy_type_destroy_notify: TGDestroyNotify; cancellable: PGCancellable; error: PPGError): PGDBusObjectManagerClient; cdecl; inline; static;
    procedure new(connection: PGDBusConnection; flags: TGDBusObjectManagerClientFlags; name: Pgchar; object_path: Pgchar; get_proxy_type_func: TGDBusProxyTypeFunc; get_proxy_type_user_data: gpointer; get_proxy_type_destroy_notify: TGDestroyNotify; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline; static;
    procedure new_for_bus(bus_type: TGBusType; flags: TGDBusObjectManagerClientFlags; name: Pgchar; object_path: Pgchar; get_proxy_type_func: TGDBusProxyTypeFunc; get_proxy_type_user_data: gpointer; get_proxy_type_destroy_notify: TGDestroyNotify; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline; static;
    function get_connection: PGDBusConnection; cdecl; inline;
    function get_flags: TGDBusObjectManagerClientFlags; cdecl; inline;
    function get_name: Pgchar; cdecl; inline;
    function get_name_owner: Pgchar; cdecl; inline;
    //property bus_type: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_bus_type  { property is writeable but setter not declared } ;
    property connection: PGDBusConnection read get_connection  { property is writeable but setter not declared } ;
    property flags: TGDBusObjectManagerClientFlags read get_flags  { property is writeable but setter not declared } ;
    //property get_proxy_type_destroy_notify: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_get_proxy_type_destroy_notify  { property is writeable but setter not declared } ;
    //property get_proxy_type_func: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_get_proxy_type_func  { property is writeable but setter not declared } ;
    //property get_proxy_type_user_data: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_get_proxy_type_user_data  { property is writeable but setter not declared } ;
    property name: Pgchar read get_name  { property is writeable but setter not declared } ;
    property name_owner: Pgchar read get_name_owner ;
    //property object_path: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_object_path  { property is writeable but setter not declared } ;
  end;


  { TGDBusObjectProxy }
  PPGDBusObjectProxy = ^PGDBusObjectProxy;
  PGDBusObjectProxy = ^TGDBusObjectProxy;


  { TGDBusObjectProxyPrivate }
  PPGDBusObjectProxyPrivate = ^PGDBusObjectProxyPrivate;
  PGDBusObjectProxyPrivate = ^TGDBusObjectProxyPrivate;
  TGDBusObjectProxy = object(TGObject)
    priv: PGDBusObjectProxyPrivate;
    function new(connection: PGDBusConnection; object_path: Pgchar): PGDBusObjectProxy; cdecl; inline; static;
    function get_connection: PGDBusConnection; cdecl; inline;
    //property g_connection: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_g_connection  { property is writeable but setter not declared } ;
    //property g_object_path: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_g_object_path  { property is writeable but setter not declared } ;
  end;


  { TGDBusProxy }
  PPGDBusProxy = ^PGDBusProxy;
  PGDBusProxy = ^TGDBusProxy;


  { TGDBusProxyFlags }
  PPGDBusProxyFlags = ^PGDBusProxyFlags;
  PGDBusProxyFlags = ^TGDBusProxyFlags;


  { TGDBusProxyPrivate }
  PPGDBusProxyPrivate = ^PGDBusProxyPrivate;
  PGDBusProxyPrivate = ^TGDBusProxyPrivate;
  TGDBusProxy = object(TGObject)
    priv: PGDBusProxyPrivate;
    function new_finish(res: PGAsyncResult; error: PPGError): PGDBusProxy; cdecl; inline; static;
    function new_for_bus_finish(res: PGAsyncResult; error: PPGError): PGDBusProxy; cdecl; inline; static;
    function new_for_bus_sync(bus_type: TGBusType; flags: TGDBusProxyFlags; info: PGDBusInterfaceInfo; name: Pgchar; object_path: Pgchar; interface_name: Pgchar; cancellable: PGCancellable; error: PPGError): PGDBusProxy; cdecl; inline; static;
    function new_sync(connection: PGDBusConnection; flags: TGDBusProxyFlags; info: PGDBusInterfaceInfo; name: Pgchar; object_path: Pgchar; interface_name: Pgchar; cancellable: PGCancellable; error: PPGError): PGDBusProxy; cdecl; inline; static;
    procedure new(connection: PGDBusConnection; flags: TGDBusProxyFlags; info: PGDBusInterfaceInfo; name: Pgchar; object_path: Pgchar; interface_name: Pgchar; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline; static;
    procedure new_for_bus(bus_type: TGBusType; flags: TGDBusProxyFlags; info: PGDBusInterfaceInfo; name: Pgchar; object_path: Pgchar; interface_name: Pgchar; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline; static;
    procedure call(method_name: Pgchar; parameters: PGVariant; flags: TGDBusCallFlags; timeout_msec: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function call_finish(res: PGAsyncResult; error: PPGError): PGVariant; cdecl; inline;
    function call_sync(method_name: Pgchar; parameters: PGVariant; flags: TGDBusCallFlags; timeout_msec: gint; cancellable: PGCancellable; error: PPGError): PGVariant; cdecl; inline;
    procedure call_with_unix_fd_list(method_name: Pgchar; parameters: PGVariant; flags: TGDBusCallFlags; timeout_msec: gint; fd_list: PGUnixFDList; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function call_with_unix_fd_list_finish(out_fd_list: PPGUnixFDList; res: PGAsyncResult; error: PPGError): PGVariant; cdecl; inline;
    function call_with_unix_fd_list_sync(method_name: Pgchar; parameters: PGVariant; flags: TGDBusCallFlags; timeout_msec: gint; fd_list: PGUnixFDList; out_fd_list: PPGUnixFDList; cancellable: PGCancellable; error: PPGError): PGVariant; cdecl; inline;
    function get_cached_property(property_name: Pgchar): PGVariant; cdecl; inline;
    function get_cached_property_names: PPgchar; cdecl; inline;
    function get_connection: PGDBusConnection; cdecl; inline;
    function get_default_timeout: gint; cdecl; inline;
    function get_flags: TGDBusProxyFlags; cdecl; inline;
    function get_interface_info: PGDBusInterfaceInfo; cdecl; inline;
    function get_interface_name: Pgchar; cdecl; inline;
    function get_name: Pgchar; cdecl; inline;
    function get_name_owner: Pgchar; cdecl; inline;
    function get_object_path: Pgchar; cdecl; inline;
    procedure set_cached_property(property_name: Pgchar; value: PGVariant); cdecl; inline;
    procedure set_default_timeout(timeout_msec: gint); cdecl; inline;
    procedure set_interface_info(info: PGDBusInterfaceInfo); cdecl; inline;
    //property g_bus_type: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_g_bus_type  { property is writeable but setter not declared } ;
    //property g_connection: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_g_connection  { property is writeable but setter not declared } ;
    //property g_default_timeout: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_g_default_timeout  { property is writeable but setter not declared } ;
    //property g_flags: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_g_flags  { property is writeable but setter not declared } ;
    //property g_interface_info: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_g_interface_info  { property is writeable but setter not declared } ;
    //property g_interface_name: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_g_interface_name  { property is writeable but setter not declared } ;
    //property g_name: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_g_name  { property is writeable but setter not declared } ;
    //property g_name_owner: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_g_name_owner ;
    //property g_object_path: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_g_object_path  { property is writeable but setter not declared } ;
  end;

  TGDBusObjectManagerClientPrivate = record
  end;




  { TGDBusObjectManagerClientClass }
  PPGDBusObjectManagerClientClass = ^PGDBusObjectManagerClientClass;
  PGDBusObjectManagerClientClass = ^TGDBusObjectManagerClientClass;
  TGDBusObjectManagerClientClass = object
    parent_class: TGObjectClass;
    interface_proxy_signal: procedure(manager: PGDBusObjectManagerClient; object_proxy: PGDBusObjectProxy; interface_proxy: PGDBusProxy; sender_name: Pgchar; signal_name: Pgchar; parameters: PGVariant); cdecl;
    interface_proxy_properties_changed: procedure(manager: PGDBusObjectManagerClient; object_proxy: PGDBusObjectProxy; interface_proxy: PGDBusProxy; changed_properties: PGVariant; invalidated_properties: PPgchar); cdecl;
    padding: array [0..7] of gpointer;
  end;


  { TGDBusObjectManagerIface }
  PPGDBusObjectManagerIface = ^PGDBusObjectManagerIface;
  PGDBusObjectManagerIface = ^TGDBusObjectManagerIface;
  TGDBusObjectManagerIface = object
    parent_iface: TGTypeInterface;
    get_object_path: function(manager: PGDBusObjectManager): Pgchar; cdecl;
    get_objects: function(manager: PGDBusObjectManager): PGList; cdecl;
    get_object: function(manager: PGDBusObjectManager; object_path: Pgchar): PGDBusObject; cdecl;
    get_interface: function(manager: PGDBusObjectManager; object_path: Pgchar; interface_name: Pgchar): PGDBusInterface; cdecl;
    object_added: procedure(manager: PGDBusObjectManager; object_: PGDBusObject); cdecl;
    object_removed: procedure(manager: PGDBusObjectManager; object_: PGDBusObject); cdecl;
    interface_added: procedure(manager: PGDBusObjectManager; object_: PGDBusObject; interface_: PGDBusInterface); cdecl;
    interface_removed: procedure(manager: PGDBusObjectManager; object_: PGDBusObject; interface_: PGDBusInterface); cdecl;
  end;


  { TGDBusObjectManagerServer }
  PPGDBusObjectManagerServer = ^PGDBusObjectManagerServer;
  PGDBusObjectManagerServer = ^TGDBusObjectManagerServer;


  { TGDBusObjectSkeleton }
  PPGDBusObjectSkeleton = ^PGDBusObjectSkeleton;
  PGDBusObjectSkeleton = ^TGDBusObjectSkeleton;


  { TGDBusObjectManagerServerPrivate }
  PPGDBusObjectManagerServerPrivate = ^PGDBusObjectManagerServerPrivate;
  PGDBusObjectManagerServerPrivate = ^TGDBusObjectManagerServerPrivate;
  TGDBusObjectManagerServer = object(TGObject)
    priv: PGDBusObjectManagerServerPrivate;
    function new(object_path: Pgchar): PGDBusObjectManagerServer; cdecl; inline; static;
    procedure export(object_: PGDBusObjectSkeleton); cdecl; inline;
    procedure export_uniquely(object_: PGDBusObjectSkeleton); cdecl; inline;
    function get_connection: PGDBusConnection; cdecl; inline;
    function is_exported(object_: PGDBusObjectSkeleton): gboolean; cdecl; inline;
    procedure set_connection(connection: PGDBusConnection); cdecl; inline;
    function unexport(object_path: Pgchar): gboolean; cdecl; inline;
    property connection: PGDBusConnection read get_connection write set_connection;
    //property object_path: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_object_path  { property is writeable but setter not declared } ;
  end;


  { TGDBusObjectSkeletonPrivate }
  PPGDBusObjectSkeletonPrivate = ^PGDBusObjectSkeletonPrivate;
  PGDBusObjectSkeletonPrivate = ^TGDBusObjectSkeletonPrivate;
  TGDBusObjectSkeleton = object(TGObject)
    priv: PGDBusObjectSkeletonPrivate;
    function new(object_path: Pgchar): PGDBusObjectSkeleton; cdecl; inline; static;
    procedure add_interface(interface_: PGDBusInterfaceSkeleton); cdecl; inline;
    procedure flush; cdecl; inline;
    procedure remove_interface(interface_: PGDBusInterfaceSkeleton); cdecl; inline;
    procedure remove_interface_by_name(interface_name: Pgchar); cdecl; inline;
    procedure set_object_path(object_path: Pgchar); cdecl; inline;
    //property g_object_path: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_g_object_path  { property is writeable but setter not declared } ;
  end;

  TGDBusObjectManagerServerPrivate = record
  end;




  { TGDBusObjectManagerServerClass }
  PPGDBusObjectManagerServerClass = ^PGDBusObjectManagerServerClass;
  PGDBusObjectManagerServerClass = ^TGDBusObjectManagerServerClass;
  TGDBusObjectManagerServerClass = object
    parent_class: TGObjectClass;
    padding: array [0..7] of gpointer;
  end;

  TGDBusObjectProxyPrivate = record
  end;




  { TGDBusObjectProxyClass }
  PPGDBusObjectProxyClass = ^PGDBusObjectProxyClass;
  PGDBusObjectProxyClass = ^TGDBusObjectProxyClass;
  TGDBusObjectProxyClass = object
    parent_class: TGObjectClass;
    padding: array [0..7] of gpointer;
  end;

  TGDBusObjectSkeletonPrivate = record
  end;




  { TGDBusObjectSkeletonClass }
  PPGDBusObjectSkeletonClass = ^PGDBusObjectSkeletonClass;
  PGDBusObjectSkeletonClass = ^TGDBusObjectSkeletonClass;
  TGDBusObjectSkeletonClass = object
    parent_class: TGObjectClass;
    authorize_method: function(object_: PGDBusObjectSkeleton; interface_: PGDBusInterfaceSkeleton; invocation: PGDBusMethodInvocation): gboolean; cdecl;
    padding: array [0..7] of gpointer;
  end;

  TGDBusProxyPrivate = record
  end;




  { TGDBusProxyClass }
  PPGDBusProxyClass = ^PGDBusProxyClass;
  PGDBusProxyClass = ^TGDBusProxyClass;
  TGDBusProxyClass = object
    parent_class: TGObjectClass;
    g_properties_changed: procedure(proxy: PGDBusProxy; changed_properties: PGVariant; invalidated_properties: PPgchar); cdecl;
    g_signal: procedure(proxy: PGDBusProxy; sender_name: Pgchar; signal_name: Pgchar; parameters: PGVariant); cdecl;
    padding: array [0..31] of gpointer;
  end;


  { TGDBusServer }
  PPGDBusServer = ^PGDBusServer;
  PGDBusServer = ^TGDBusServer;


  { TGDBusServerFlags }
  PPGDBusServerFlags = ^PGDBusServerFlags;
  PGDBusServerFlags = ^TGDBusServerFlags;
  TGDBusServer = object(TGObject)
    function new_sync(address: Pgchar; flags: TGDBusServerFlags; guid: Pgchar; observer: PGDBusAuthObserver; cancellable: PGCancellable; error: PPGError): PGDBusServer; cdecl; inline; static;
    function get_client_address: Pgchar; cdecl; inline;
    function get_flags: TGDBusServerFlags; cdecl; inline;
    function get_guid: Pgchar; cdecl; inline;
    function is_active: gboolean; cdecl; inline;
    procedure start; cdecl; inline;
    procedure stop; cdecl; inline;
    //property active: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_active ;
    //property address: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_address  { property is writeable but setter not declared } ;
    //property authentication_observer: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_authentication_observer  { property is writeable but setter not declared } ;
    property client_address: Pgchar read get_client_address ;
    property flags: TGDBusServerFlags read get_flags  { property is writeable but setter not declared } ;
    property guid: Pgchar read get_guid  { property is writeable but setter not declared } ;
  end;


  { TGDataInputStream }
  PPGDataInputStream = ^PGDataInputStream;
  PGDataInputStream = ^TGDataInputStream;


  { TGDataStreamByteOrder }
  PPGDataStreamByteOrder = ^PGDataStreamByteOrder;
  PGDataStreamByteOrder = ^TGDataStreamByteOrder;


  { TGDataStreamNewlineType }
  PPGDataStreamNewlineType = ^PGDataStreamNewlineType;
  PGDataStreamNewlineType = ^TGDataStreamNewlineType;


  { TGDataInputStreamPrivate }
  PPGDataInputStreamPrivate = ^PGDataInputStreamPrivate;
  PGDataInputStreamPrivate = ^TGDataInputStreamPrivate;
  TGDataInputStream = object(TGBufferedInputStream)
    priv2: PGDataInputStreamPrivate;
    function new(base_stream: PGInputStream): PGDataInputStream; cdecl; inline; static;
    function get_byte_order: TGDataStreamByteOrder; cdecl; inline;
    function get_newline_type: TGDataStreamNewlineType; cdecl; inline;
    function read_byte(cancellable: PGCancellable; error: PPGError): guint8; cdecl; inline;
    function read_int16(cancellable: PGCancellable; error: PPGError): gint16; cdecl; inline;
    function read_int32(cancellable: PGCancellable; error: PPGError): gint32; cdecl; inline;
    function read_int64(cancellable: PGCancellable; error: PPGError): gint64; cdecl; inline;
    function read_line(length: Pgsize; cancellable: PGCancellable; error: PPGError): Pgchar; cdecl; inline;
    procedure read_line_async(io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function read_line_finish(result_: PGAsyncResult; length: Pgsize; error: PPGError): Pgchar; cdecl; inline;
    function read_line_finish_utf8(result_: PGAsyncResult; length: Pgsize; error: PPGError): Pgchar; cdecl; inline;
    function read_line_utf8(length: Pgsize; cancellable: PGCancellable; error: PPGError): Pgchar; cdecl; inline;
    function read_uint16(cancellable: PGCancellable; error: PPGError): guint16; cdecl; inline;
    function read_uint32(cancellable: PGCancellable; error: PPGError): guint32; cdecl; inline;
    function read_uint64(cancellable: PGCancellable; error: PPGError): guint64; cdecl; inline;
    function read_upto(stop_chars: Pgchar; stop_chars_len: gssize; length: Pgsize; cancellable: PGCancellable; error: PPGError): Pgchar; cdecl; inline;
    procedure read_upto_async(stop_chars: Pgchar; stop_chars_len: gssize; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function read_upto_finish(result_: PGAsyncResult; length: Pgsize; error: PPGError): Pgchar; cdecl; inline;
    procedure set_byte_order(order: TGDataStreamByteOrder); cdecl; inline;
    procedure set_newline_type(type_: TGDataStreamNewlineType); cdecl; inline;
    property byte_order: TGDataStreamByteOrder read get_byte_order write set_byte_order;
    property newline_type: TGDataStreamNewlineType read get_newline_type write set_newline_type;
  end;

  TGDataInputStreamPrivate = record
  end;




  { TGDataInputStreamClass }
  PPGDataInputStreamClass = ^PGDataInputStreamClass;
  PGDataInputStreamClass = ^TGDataInputStreamClass;
  TGDataInputStreamClass = object
    parent_class: TGBufferedInputStreamClass;
    _g_reserved1: procedure; cdecl;
    _g_reserved2: procedure; cdecl;
    _g_reserved3: procedure; cdecl;
    _g_reserved4: procedure; cdecl;
    _g_reserved5: procedure; cdecl;
  end;


  { TGDataOutputStream }
  PPGDataOutputStream = ^PGDataOutputStream;
  PGDataOutputStream = ^TGDataOutputStream;


  { TGDataOutputStreamPrivate }
  PPGDataOutputStreamPrivate = ^PGDataOutputStreamPrivate;
  PGDataOutputStreamPrivate = ^TGDataOutputStreamPrivate;
  TGDataOutputStream = object(TGFilterOutputStream)
    priv1: PGDataOutputStreamPrivate;
    function new(base_stream: PGOutputStream): PGDataOutputStream; cdecl; inline; static;
    function get_byte_order: TGDataStreamByteOrder; cdecl; inline;
    function put_byte(data: guint8; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; inline;
    function put_int16(data: gint16; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; inline;
    function put_int32(data: gint32; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; inline;
    function put_int64(data: gint64; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; inline;
    function put_string(str: Pgchar; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; inline;
    function put_uint16(data: guint16; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; inline;
    function put_uint32(data: guint32; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; inline;
    function put_uint64(data: guint64; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; inline;
    procedure set_byte_order(order: TGDataStreamByteOrder); cdecl; inline;
    property byte_order: TGDataStreamByteOrder read get_byte_order write set_byte_order;
  end;

  TGDataOutputStreamPrivate = record
  end;




  { TGDataOutputStreamClass }
  PPGDataOutputStreamClass = ^PGDataOutputStreamClass;
  PGDataOutputStreamClass = ^TGDataOutputStreamClass;
  TGDataOutputStreamClass = object
    parent_class: TGFilterOutputStreamClass;
    _g_reserved1: procedure; cdecl;
    _g_reserved2: procedure; cdecl;
    _g_reserved3: procedure; cdecl;
    _g_reserved4: procedure; cdecl;
    _g_reserved5: procedure; cdecl;
  end;


  { TGDatagramBased }
  PPGDatagramBased = ^PGDatagramBased;
  PGDatagramBased = ^TGDatagramBased;


  { TGInputMessage }
  PPGInputMessage = ^PGInputMessage;
  PGInputMessage = ^TGInputMessage;


  { TGOutputMessage }
  PPGOutputMessage = ^PGOutputMessage;
  PGOutputMessage = ^TGOutputMessage;
  TGDatagramBased = object
    function condition_check(condition: TGIOCondition): TGIOCondition; cdecl; inline;
    function condition_wait(condition: TGIOCondition; timeout: gint64; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; inline;
    function create_source(condition: TGIOCondition; cancellable: PGCancellable): PGSource; cdecl; inline;
    function receive_messages(messages: PGInputMessage; num_messages: guint; flags: gint; timeout: gint64; cancellable: PGCancellable; error: PPGError): gint; cdecl; inline;
    function send_messages(messages: PGOutputMessage; num_messages: guint; flags: gint; timeout: gint64; cancellable: PGCancellable; error: PPGError): gint; cdecl; inline;
  end;


  { TGSocketAddress }
  PPGSocketAddress = ^PGSocketAddress;
  PGSocketAddress = ^TGSocketAddress;


  { TGInputVector }
  PPGInputVector = ^PGInputVector;
  PGInputVector = ^TGInputVector;


  { TGSocketControlMessage }
  PPPGSocketControlMessage = ^PPGSocketControlMessage;
  PPGSocketControlMessage = ^PGSocketControlMessage;
  PGSocketControlMessage = ^TGSocketControlMessage;

  TGInputMessage = record
    address: PPGSocketAddress;
    vectors: PGInputVector;
    num_vectors: guint;
    bytes_received: gsize;
    flags: gint;
    control_messages: PPPGSocketControlMessage;
    num_control_messages: Pguint;
  end;



  TGOutputMessage = record
    address: PGSocketAddress;
    vectors: PGOutputVector;
    num_vectors: guint;
    bytes_sent: guint;
    control_messages: PPGSocketControlMessage;
    num_control_messages: guint;
  end;




  { TGDatagramBasedInterface }
  PPGDatagramBasedInterface = ^PGDatagramBasedInterface;
  PGDatagramBasedInterface = ^TGDatagramBasedInterface;
  TGDatagramBasedInterface = object
    g_iface: TGTypeInterface;
    receive_messages: function(datagram_based: PGDatagramBased; messages: PGInputMessage; num_messages: guint; flags: gint; timeout: gint64; cancellable: PGCancellable; error: PPGError): gint; cdecl;
    send_messages: function(datagram_based: PGDatagramBased; messages: PGOutputMessage; num_messages: guint; flags: gint; timeout: gint64; cancellable: PGCancellable; error: PPGError): gint; cdecl;
    create_source: function(datagram_based: PGDatagramBased; condition: TGIOCondition; cancellable: PGCancellable): PGSource; cdecl;
    condition_check: function(datagram_based: PGDatagramBased; condition: TGIOCondition): TGIOCondition; cdecl;
    condition_wait: function(datagram_based: PGDatagramBased; condition: TGIOCondition; timeout: gint64; cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
  end;
  TGDatagramBasedSourceFunc = function(datagram_based: PGDatagramBased; condition: TGIOCondition; user_data: gpointer): gboolean; cdecl;


  { TGDesktopAppInfo }
  PPGDesktopAppInfo = ^PGDesktopAppInfo;
  PGDesktopAppInfo = ^TGDesktopAppInfo;


  { TGDesktopAppLaunchCallback }
  PPGDesktopAppLaunchCallback = ^PGDesktopAppLaunchCallback;
  PGDesktopAppLaunchCallback = ^TGDesktopAppLaunchCallback;
  TGDesktopAppLaunchCallback = procedure(appinfo: PGDesktopAppInfo; pid: TGPid; user_data: gpointer); cdecl;
  TGDesktopAppInfo = object(TGObject)
    function new(desktop_id: Pgchar): PGDesktopAppInfo; cdecl; inline; static;
    function new_from_filename(filename: Pgchar): PGDesktopAppInfo; cdecl; inline; static;
    function new_from_keyfile(key_file: PGKeyFile): PGDesktopAppInfo; cdecl; inline; static;
    function get_implementations(interface_: Pgchar): PGList; cdecl; inline; static;
    function search(search_string: Pgchar): PPPgchar; cdecl; inline; static;
    function get_action_name(action_name: Pgchar): Pgchar; cdecl; inline;
    function get_boolean(key: Pgchar): gboolean; cdecl; inline;
    function get_categories: Pgchar; cdecl; inline;
    function get_filename: Pgchar; cdecl; inline;
    function get_generic_name: Pgchar; cdecl; inline;
    function get_is_hidden: gboolean; cdecl; inline;
    function get_keywords: PPgchar; cdecl; inline;
    function get_locale_string(key: Pgchar): Pgchar; cdecl; inline;
    function get_nodisplay: gboolean; cdecl; inline;
    function get_show_in(desktop_env: Pgchar): gboolean; cdecl; inline;
    function get_startup_wm_class: Pgchar; cdecl; inline;
    function get_string(key: Pgchar): Pgchar; cdecl; inline;
    function get_string_list(key: Pgchar; length: Pgsize): PPgchar; cdecl; inline;
    function has_key(key: Pgchar): gboolean; cdecl; inline;
    procedure launch_action(action_name: Pgchar; launch_context: PGAppLaunchContext); cdecl; inline;
    function launch_uris_as_manager(uris: PGList; launch_context: PGAppLaunchContext; spawn_flags: TGSpawnFlags; user_setup: TGSpawnChildSetupFunc; user_setup_data: gpointer; pid_callback: TGDesktopAppLaunchCallback; pid_callback_data: gpointer; error: PPGError): gboolean; cdecl; inline;
    function launch_uris_as_manager_with_fds(uris: PGList; launch_context: PGAppLaunchContext; spawn_flags: TGSpawnFlags; user_setup: TGSpawnChildSetupFunc; user_setup_data: gpointer; pid_callback: TGDesktopAppLaunchCallback; pid_callback_data: gpointer; stdin_fd: gint; stdout_fd: gint; stderr_fd: gint; error: PPGError): gboolean; cdecl; inline;
    function list_actions: PPgchar; cdecl; inline;
    property filename: Pgchar read get_filename  { property is writeable but setter not declared } ;
  end;


  { TGDesktopAppInfoClass }
  PPGDesktopAppInfoClass = ^PGDesktopAppInfoClass;
  PGDesktopAppInfoClass = ^TGDesktopAppInfoClass;
  TGDesktopAppInfoClass = object
    parent_class: TGObjectClass;
  end;


  { TGDesktopAppInfoLookup }
  PPGDesktopAppInfoLookup = ^PGDesktopAppInfoLookup;
  PGDesktopAppInfoLookup = ^TGDesktopAppInfoLookup;
  TGDesktopAppInfoLookup = object
  end;


  { TGDesktopAppInfoLookupIface }
  PPGDesktopAppInfoLookupIface = ^PGDesktopAppInfoLookupIface;
  PGDesktopAppInfoLookupIface = ^TGDesktopAppInfoLookupIface;
  TGDesktopAppInfoLookupIface = object
    g_iface: TGTypeInterface;
    get_default_for_uri_scheme: function(lookup: PGDesktopAppInfoLookup; uri_scheme: Pgchar): PGAppInfo; cdecl;
  end;


  { TGDrive }
  PPGDrive = ^PGDrive;
  PGDrive = ^TGDrive;


  { TGDriveStartStopType }
  PPGDriveStartStopType = ^PGDriveStartStopType;
  PGDriveStartStopType = ^TGDriveStartStopType;
  TGDrive = object
    changed: procedure; cdecl;
    disconnected: procedure; cdecl;
    eject_button: procedure; cdecl;
    stop_button: procedure; cdecl;
    function can_eject: gboolean; cdecl; inline;
    function can_poll_for_media: gboolean; cdecl; inline;
    function can_start: gboolean; cdecl; inline;
    function can_start_degraded: gboolean; cdecl; inline;
    function can_stop: gboolean; cdecl; inline;
    procedure eject_with_operation(flags: TGMountUnmountFlags; mount_operation: PGMountOperation; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function eject_with_operation_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl; inline;
    function enumerate_identifiers: PPgchar; cdecl; inline;
    function get_icon: PGIcon; cdecl; inline;
    function get_identifier(kind: Pgchar): Pgchar; cdecl; inline;
    function get_name: Pgchar; cdecl; inline;
    function get_sort_key: Pgchar; cdecl; inline;
    function get_start_stop_type: TGDriveStartStopType; cdecl; inline;
    function get_symbolic_icon: PGIcon; cdecl; inline;
    function get_volumes: PGList; cdecl; inline;
    function has_media: gboolean; cdecl; inline;
    function has_volumes: gboolean; cdecl; inline;
    function is_media_check_automatic: gboolean; cdecl; inline;
    function is_media_removable: gboolean; cdecl; inline;
    function is_removable: gboolean; cdecl; inline;
    procedure poll_for_media(cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function poll_for_media_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl; inline;
    procedure start(flags: TGDriveStartFlags; mount_operation: PGMountOperation; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function start_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl; inline;
    procedure stop(flags: TGMountUnmountFlags; mount_operation: PGMountOperation; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function stop_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl; inline;
  end;


  { TGPasswordSave }
  PPGPasswordSave = ^PGPasswordSave;
  PGPasswordSave = ^TGPasswordSave;


  { TGMountOperationResult }
  PPGMountOperationResult = ^PGMountOperationResult;
  PGMountOperationResult = ^TGMountOperationResult;


  { TGMountOperationPrivate }
  PPGMountOperationPrivate = ^PGMountOperationPrivate;
  PGMountOperationPrivate = ^TGMountOperationPrivate;
  TGMountOperation = object(TGObject)
    priv: PGMountOperationPrivate;
    function new: PGMountOperation; cdecl; inline; static;
    function get_anonymous: gboolean; cdecl; inline;
    function get_choice: gint; cdecl; inline;
    function get_domain: Pgchar; cdecl; inline;
    function get_is_tcrypt_hidden_volume: gboolean; cdecl; inline;
    function get_is_tcrypt_system_volume: gboolean; cdecl; inline;
    function get_password: Pgchar; cdecl; inline;
    function get_password_save: TGPasswordSave; cdecl; inline;
    function get_pim: guint; cdecl; inline;
    function get_username: Pgchar; cdecl; inline;
    procedure reply(result_: TGMountOperationResult); cdecl; inline;
    procedure set_anonymous(anonymous: gboolean); cdecl; inline;
    procedure set_choice(choice: gint); cdecl; inline;
    procedure set_domain(domain: Pgchar); cdecl; inline;
    procedure set_is_tcrypt_hidden_volume(hidden_volume: gboolean); cdecl; inline;
    procedure set_is_tcrypt_system_volume(system_volume: gboolean); cdecl; inline;
    procedure set_password(password: Pgchar); cdecl; inline;
    procedure set_password_save(save: TGPasswordSave); cdecl; inline;
    procedure set_pim(pim: guint); cdecl; inline;
    procedure set_username(username: Pgchar); cdecl; inline;
    property anonymous: gboolean read get_anonymous write set_anonymous;
    property choice: gint read get_choice write set_choice;
    property domain: Pgchar read get_domain write set_domain;
    property is_tcrypt_hidden_volume: gboolean read get_is_tcrypt_hidden_volume write set_is_tcrypt_hidden_volume;
    property is_tcrypt_system_volume: gboolean read get_is_tcrypt_system_volume write set_is_tcrypt_system_volume;
    property password: Pgchar read get_password write set_password;
    property password_save: TGPasswordSave read get_password_save write set_password_save;
    property pim: guint read get_pim write set_pim;
    property username: Pgchar read get_username write set_username;
  end;


  { TGDriveIface }
  PPGDriveIface = ^PGDriveIface;
  PGDriveIface = ^TGDriveIface;
  TGDriveIface = object
    g_iface: TGTypeInterface;
    changed: procedure(drive: PGDrive); cdecl;
    disconnected: procedure(drive: PGDrive); cdecl;
    eject_button: procedure(drive: PGDrive); cdecl;
    get_name: function(drive: PGDrive): Pgchar; cdecl;
    get_icon: function(drive: PGDrive): PGIcon; cdecl;
    has_volumes: function(drive: PGDrive): gboolean; cdecl;
    get_volumes: function(drive: PGDrive): PGList; cdecl;
    is_media_removable: function(drive: PGDrive): gboolean; cdecl;
    has_media: function(drive: PGDrive): gboolean; cdecl;
    is_media_check_automatic: function(drive: PGDrive): gboolean; cdecl;
    can_eject: function(drive: PGDrive): gboolean; cdecl;
    can_poll_for_media: function(drive: PGDrive): gboolean; cdecl;
    eject: procedure(drive: PGDrive; flags: TGMountUnmountFlags; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    eject_finish: function(drive: PGDrive; result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
    poll_for_media: procedure(drive: PGDrive; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    poll_for_media_finish: function(drive: PGDrive; result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
    get_identifier: function(drive: PGDrive; kind: Pgchar): Pgchar; cdecl;
    enumerate_identifiers: function(drive: PGDrive): PPgchar; cdecl;
    get_start_stop_type: function(drive: PGDrive): TGDriveStartStopType; cdecl;
    can_start: function(drive: PGDrive): gboolean; cdecl;
    can_start_degraded: function(drive: PGDrive): gboolean; cdecl;
    start: procedure(drive: PGDrive; flags: TGDriveStartFlags; mount_operation: PGMountOperation; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    start_finish: function(drive: PGDrive; result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
    can_stop: function(drive: PGDrive): gboolean; cdecl;
    stop: procedure(drive: PGDrive; flags: TGMountUnmountFlags; mount_operation: PGMountOperation; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    stop_finish: function(drive: PGDrive; result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
    stop_button: procedure(drive: PGDrive); cdecl;
    eject_with_operation: procedure(drive: PGDrive; flags: TGMountUnmountFlags; mount_operation: PGMountOperation; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    eject_with_operation_finish: function(drive: PGDrive; result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
    get_sort_key: function(drive: PGDrive): Pgchar; cdecl;
    get_symbolic_icon: function(drive: PGDrive): PGIcon; cdecl;
    is_removable: function(drive: PGDrive): gboolean; cdecl;
  end;


  { TGDtlsClientConnection }
  PPGDtlsClientConnection = ^PGDtlsClientConnection;
  PGDtlsClientConnection = ^TGDtlsClientConnection;


  { TGSocketConnectable }
  PPGSocketConnectable = ^PGSocketConnectable;
  PGSocketConnectable = ^TGSocketConnectable;


  { TGTlsCertificateFlags }
  PPGTlsCertificateFlags = ^PGTlsCertificateFlags;
  PGTlsCertificateFlags = ^TGTlsCertificateFlags;
  TGDtlsClientConnection = object
    function new(base_socket: PGDatagramBased; server_identity: PGSocketConnectable; error: PPGError): PGDtlsClientConnection; cdecl; inline; static;
    function get_accepted_cas: PGList; cdecl; inline;
    function get_server_identity: PGSocketConnectable; cdecl; inline;
    function get_validation_flags: TGTlsCertificateFlags; cdecl; inline; deprecated 'Do not attempt to ignore validation errors.';
    procedure set_server_identity(identity: PGSocketConnectable); cdecl; inline;
    procedure set_validation_flags(flags: TGTlsCertificateFlags); cdecl; inline; deprecated 'Do not attempt to ignore validation errors.';
    property accepted_cas: PGList read get_accepted_cas ;
    property server_identity: PGSocketConnectable read get_server_identity write set_server_identity;
  end;


  { TGSocketAddressEnumerator }
  PPGSocketAddressEnumerator = ^PGSocketAddressEnumerator;
  PGSocketAddressEnumerator = ^TGSocketAddressEnumerator;
  TGSocketConnectable = object
    function enumerate: PGSocketAddressEnumerator; cdecl; inline;
    function proxy_enumerate: PGSocketAddressEnumerator; cdecl; inline;
    function to_string: Pgchar; cdecl; inline;
  end;


  { TGDtlsClientConnectionInterface }
  PPGDtlsClientConnectionInterface = ^PGDtlsClientConnectionInterface;
  PGDtlsClientConnectionInterface = ^TGDtlsClientConnectionInterface;
  TGDtlsClientConnectionInterface = object
    g_iface: TGTypeInterface;
  end;


  { TGDtlsConnection }
  PPGDtlsConnection = ^PGDtlsConnection;
  PGDtlsConnection = ^TGDtlsConnection;


  { TGTlsCertificate }
  PPGTlsCertificate = ^PGTlsCertificate;
  PGTlsCertificate = ^TGTlsCertificate;


  { TGTlsChannelBindingType }
  PPGTlsChannelBindingType = ^PGTlsChannelBindingType;
  PGTlsChannelBindingType = ^TGTlsChannelBindingType;


  { TGTlsDatabase }
  PPGTlsDatabase = ^PGTlsDatabase;
  PGTlsDatabase = ^TGTlsDatabase;


  { TGTlsInteraction }
  PPGTlsInteraction = ^PGTlsInteraction;
  PGTlsInteraction = ^TGTlsInteraction;


  { TGTlsCertificatePrivate }
  PPGTlsCertificatePrivate = ^PGTlsCertificatePrivate;
  PGTlsCertificatePrivate = ^TGTlsCertificatePrivate;
  TGTlsCertificate = object(TGObject)
    priv: PGTlsCertificatePrivate;
    function new_from_file(file_: Pgchar; error: PPGError): PGTlsCertificate; cdecl; inline; static;
    function new_from_files(cert_file: Pgchar; key_file: Pgchar; error: PPGError): PGTlsCertificate; cdecl; inline; static;
    function new_from_pem(data: Pgchar; length: gssize; error: PPGError): PGTlsCertificate; cdecl; inline; static;
    function list_new_from_file(file_: Pgchar; error: PPGError): PGList; cdecl; inline; static;
    function get_issuer: PGTlsCertificate; cdecl; inline;
    function is_same(cert_two: PGTlsCertificate): gboolean; cdecl; inline;
    function verify(identity: PGSocketConnectable; trusted_ca: PGTlsCertificate): TGTlsCertificateFlags; cdecl; inline;
    //property certificate: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_certificate  { property is writeable but setter not declared } ;
    //property certificate_pem: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_certificate_pem  { property is writeable but setter not declared } ;
    property issuer: PGTlsCertificate read get_issuer  { property is writeable but setter not declared } ;
    //property private_key: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_private_key  { property is writeable but setter not declared } ;
    //property private_key_pem: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_private_key_pem  { property is writeable but setter not declared } ;
  end;
  TGDtlsConnection = object
    accept_certificate: function(peer_cert: TGTlsCertificate; errors: TGTlsCertificateFlags): gboolean; cdecl;
    function close(cancellable: PGCancellable; error: PPGError): gboolean; cdecl; inline;
    procedure close_async(io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function close_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl; inline;
    function emit_accept_certificate(peer_cert: PGTlsCertificate; errors: TGTlsCertificateFlags): gboolean; cdecl; inline;
    function get_certificate: PGTlsCertificate; cdecl; inline;
    {$IFDEF USEGTK3LATESTBINDINGS}
    function get_channel_binding_data(type_: TGTlsChannelBindingType; data: Pguint8; error: PPGError): gboolean; cdecl; inline;
    {$ENDIF}
    function get_database: PGTlsDatabase; cdecl; inline;
    function get_interaction: PGTlsInteraction; cdecl; inline;
    function get_negotiated_protocol: Pgchar; cdecl; inline;
    function get_peer_certificate: PGTlsCertificate; cdecl; inline;
    function get_peer_certificate_errors: TGTlsCertificateFlags; cdecl; inline;
    function get_require_close_notify: gboolean; cdecl; inline;
    function handshake(cancellable: PGCancellable; error: PPGError): gboolean; cdecl; inline;
    procedure handshake_async(io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function handshake_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl; inline;
    procedure set_advertised_protocols(protocols: PPgchar); cdecl; inline;
    procedure set_certificate(certificate: PGTlsCertificate); cdecl; inline;
    procedure set_database(database: PGTlsDatabase); cdecl; inline;
    procedure set_interaction(interaction: PGTlsInteraction); cdecl; inline;
    procedure set_require_close_notify(require_close_notify: gboolean); cdecl; inline;
    function shutdown(shutdown_read: gboolean; shutdown_write: gboolean; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; inline;
    procedure shutdown_async(shutdown_read: gboolean; shutdown_write: gboolean; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function shutdown_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl; inline;
    //property advertised_protocols: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_advertised_protocols  { property is writeable but setter not declared } ;
    //property base_socket: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_base_socket  { property is writeable but setter not declared } ;
    property certificate: PGTlsCertificate read get_certificate write set_certificate;
    property database: PGTlsDatabase read get_database write set_database;
    property interaction: PGTlsInteraction read get_interaction write set_interaction;
    property negotiated_protocol: Pgchar read get_negotiated_protocol ;
    property peer_certificate: PGTlsCertificate read get_peer_certificate ;
    property peer_certificate_errors: TGTlsCertificateFlags read get_peer_certificate_errors ;
    property require_close_notify: gboolean read get_require_close_notify write set_require_close_notify;
  end;


  { TGTlsDatabaseLookupFlags }
  PPGTlsDatabaseLookupFlags = ^PGTlsDatabaseLookupFlags;
  PGTlsDatabaseLookupFlags = ^TGTlsDatabaseLookupFlags;


  { TGTlsDatabaseVerifyFlags }
  PPGTlsDatabaseVerifyFlags = ^PGTlsDatabaseVerifyFlags;
  PGTlsDatabaseVerifyFlags = ^TGTlsDatabaseVerifyFlags;


  { TGTlsDatabasePrivate }
  PPGTlsDatabasePrivate = ^PGTlsDatabasePrivate;
  PGTlsDatabasePrivate = ^TGTlsDatabasePrivate;
  TGTlsDatabase = object(TGObject)
    priv: PGTlsDatabasePrivate;
    function create_certificate_handle(certificate: PGTlsCertificate): Pgchar; cdecl; inline;
    function lookup_certificate_for_handle(handle: Pgchar; interaction: PGTlsInteraction; flags: TGTlsDatabaseLookupFlags; cancellable: PGCancellable; error: PPGError): PGTlsCertificate; cdecl; inline;
    procedure lookup_certificate_for_handle_async(handle: Pgchar; interaction: PGTlsInteraction; flags: TGTlsDatabaseLookupFlags; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function lookup_certificate_for_handle_finish(result_: PGAsyncResult; error: PPGError): PGTlsCertificate; cdecl; inline;
    function lookup_certificate_issuer(certificate: PGTlsCertificate; interaction: PGTlsInteraction; flags: TGTlsDatabaseLookupFlags; cancellable: PGCancellable; error: PPGError): PGTlsCertificate; cdecl; inline;
    procedure lookup_certificate_issuer_async(certificate: PGTlsCertificate; interaction: PGTlsInteraction; flags: TGTlsDatabaseLookupFlags; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function lookup_certificate_issuer_finish(result_: PGAsyncResult; error: PPGError): PGTlsCertificate; cdecl; inline;
    function lookup_certificates_issued_by(issuer_raw_dn: Pguint8; interaction: PGTlsInteraction; flags: TGTlsDatabaseLookupFlags; cancellable: PGCancellable; error: PPGError): PGList; cdecl; inline;
    procedure lookup_certificates_issued_by_async(issuer_raw_dn: Pguint8; interaction: PGTlsInteraction; flags: TGTlsDatabaseLookupFlags; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function lookup_certificates_issued_by_finish(result_: PGAsyncResult; error: PPGError): PGList; cdecl; inline;
    function verify_chain(chain: PGTlsCertificate; purpose: Pgchar; identity: PGSocketConnectable; interaction: PGTlsInteraction; flags: TGTlsDatabaseVerifyFlags; cancellable: PGCancellable; error: PPGError): TGTlsCertificateFlags; cdecl; inline;
    procedure verify_chain_async(chain: PGTlsCertificate; purpose: Pgchar; identity: PGSocketConnectable; interaction: PGTlsInteraction; flags: TGTlsDatabaseVerifyFlags; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function verify_chain_finish(result_: PGAsyncResult; error: PPGError): TGTlsCertificateFlags; cdecl; inline;
  end;


  { TGTlsInteractionResult }
  PPGTlsInteractionResult = ^PGTlsInteractionResult;
  PGTlsInteractionResult = ^TGTlsInteractionResult;


  { TGTlsPassword }
  PPGTlsPassword = ^PGTlsPassword;
  PGTlsPassword = ^TGTlsPassword;


  { TGTlsConnection }
  PPGTlsConnection = ^PGTlsConnection;
  PGTlsConnection = ^TGTlsConnection;


  { TGTlsCertificateRequestFlags }
  PPGTlsCertificateRequestFlags = ^PGTlsCertificateRequestFlags;
  PGTlsCertificateRequestFlags = ^TGTlsCertificateRequestFlags;


  { TGTlsInteractionPrivate }
  PPGTlsInteractionPrivate = ^PGTlsInteractionPrivate;
  PGTlsInteractionPrivate = ^TGTlsInteractionPrivate;
  TGTlsInteraction = object(TGObject)
    priv: PGTlsInteractionPrivate;
    function ask_password(password: PGTlsPassword; cancellable: PGCancellable; error: PPGError): TGTlsInteractionResult; cdecl; inline;
    procedure ask_password_async(password: PGTlsPassword; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function ask_password_finish(result_: PGAsyncResult; error: PPGError): TGTlsInteractionResult; cdecl; inline;
    function invoke_ask_password(password: PGTlsPassword; cancellable: PGCancellable; error: PPGError): TGTlsInteractionResult; cdecl; inline;
    function invoke_request_certificate(connection: PGTlsConnection; flags: TGTlsCertificateRequestFlags; cancellable: PGCancellable; error: PPGError): TGTlsInteractionResult; cdecl; inline;
    function request_certificate(connection: PGTlsConnection; flags: TGTlsCertificateRequestFlags; cancellable: PGCancellable; error: PPGError): TGTlsInteractionResult; cdecl; inline;
    procedure request_certificate_async(connection: PGTlsConnection; flags: TGTlsCertificateRequestFlags; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function request_certificate_finish(result_: PGAsyncResult; error: PPGError): TGTlsInteractionResult; cdecl; inline;
  end;


  { TGDtlsConnectionInterface }
  PPGDtlsConnectionInterface = ^PGDtlsConnectionInterface;
  PGDtlsConnectionInterface = ^TGDtlsConnectionInterface;
  TGDtlsConnectionInterface = object
    g_iface: TGTypeInterface;
    accept_certificate: function(connection: PGDtlsConnection; peer_cert: PGTlsCertificate; errors: TGTlsCertificateFlags): gboolean; cdecl;
    handshake: function(conn: PGDtlsConnection; cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
    handshake_async: procedure(conn: PGDtlsConnection; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    handshake_finish: function(conn: PGDtlsConnection; result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
    shutdown: function(conn: PGDtlsConnection; shutdown_read: gboolean; shutdown_write: gboolean; cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
    shutdown_async: procedure(conn: PGDtlsConnection; shutdown_read: gboolean; shutdown_write: gboolean; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    shutdown_finish: function(conn: PGDtlsConnection; result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
    set_advertised_protocols: procedure(conn: PGDtlsConnection; protocols: PPgchar); cdecl;
    get_negotiated_protocol: function(conn: PGDtlsConnection): Pgchar; cdecl;
    get_binding_data: function(conn: PGDtlsConnection; type_: TGTlsChannelBindingType; data: Pguint8; error: PPGError): gboolean; cdecl;
  end;


  { TGDtlsServerConnection }
  PPGDtlsServerConnection = ^PGDtlsServerConnection;
  PGDtlsServerConnection = ^TGDtlsServerConnection;
  TGDtlsServerConnection = object
    function new(base_socket: PGDatagramBased; certificate: PGTlsCertificate; error: PPGError): PGDtlsServerConnection; cdecl; inline; static;
    //property authentication_mode: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_authentication_mode  { property is writeable but setter not declared } ;
  end;


  { TGTlsAuthenticationMode }
  PPGTlsAuthenticationMode = ^PGTlsAuthenticationMode;
  PGTlsAuthenticationMode = ^TGTlsAuthenticationMode;


  { TGDtlsServerConnectionInterface }
  PPGDtlsServerConnectionInterface = ^PGDtlsServerConnectionInterface;
  PGDtlsServerConnectionInterface = ^TGDtlsServerConnectionInterface;
  TGDtlsServerConnectionInterface = object
    g_iface: TGTypeInterface;
  end;


  { TGEmblem }
  PPGEmblem = ^PGEmblem;
  PGEmblem = ^TGEmblem;


  { TGEmblemOrigin }
  PPGEmblemOrigin = ^PGEmblemOrigin;
  PGEmblemOrigin = ^TGEmblemOrigin;
  TGEmblem = object(TGObject)
    function new(icon: PGIcon): PGEmblem; cdecl; inline; static;
    function new_with_origin(icon: PGIcon; origin: TGEmblemOrigin): PGEmblem; cdecl; inline; static;
    function get_icon: PGIcon; cdecl; inline;
    function get_origin: TGEmblemOrigin; cdecl; inline;
    property icon: PGIcon read get_icon  { property is writeable but setter not declared } ;
    property origin: TGEmblemOrigin read get_origin  { property is writeable but setter not declared } ;
  end;


  { TGEmblemClass }
  PPGEmblemClass = ^PGEmblemClass;
  PGEmblemClass = ^TGEmblemClass;
  TGEmblemClass = object
  end;


  { TGEmblemedIcon }
  PPGEmblemedIcon = ^PGEmblemedIcon;
  PGEmblemedIcon = ^TGEmblemedIcon;


  { TGEmblemedIconPrivate }
  PPGEmblemedIconPrivate = ^PGEmblemedIconPrivate;
  PGEmblemedIconPrivate = ^TGEmblemedIconPrivate;
  TGEmblemedIcon = object(TGObject)
    priv: PGEmblemedIconPrivate;
    function new(icon: PGIcon; emblem: PGEmblem): PGEmblemedIcon; cdecl; inline; static;
    procedure add_emblem(emblem: PGEmblem); cdecl; inline;
    procedure clear_emblems; cdecl; inline;
    function get_emblems: PGList; cdecl; inline;
    function get_icon: PGIcon; cdecl; inline;
    //property gicon: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_gicon  { property is writeable but setter not declared } ;
  end;

  TGEmblemedIconPrivate = record
  end;




  { TGEmblemedIconClass }
  PPGEmblemedIconClass = ^PGEmblemedIconClass;
  PGEmblemedIconClass = ^TGEmblemedIconClass;
  TGEmblemedIconClass = object
    parent_class: TGObjectClass;
  end;


  { TGFileIOStreamPrivate }
  PPGFileIOStreamPrivate = ^PGFileIOStreamPrivate;
  PGFileIOStreamPrivate = ^TGFileIOStreamPrivate;
  TGFileIOStream = object(TGIOStream)
    priv1: PGFileIOStreamPrivate;
    function get_etag: Pgchar; cdecl; inline;
    function query_info(attributes: Pgchar; cancellable: PGCancellable; error: PPGError): PGFileInfo; cdecl; inline;
    procedure query_info_async(attributes: Pgchar; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function query_info_finish(result_: PGAsyncResult; error: PPGError): PGFileInfo; cdecl; inline;
  end;


  { TGFileOutputStreamPrivate }
  PPGFileOutputStreamPrivate = ^PGFileOutputStreamPrivate;
  PGFileOutputStreamPrivate = ^TGFileOutputStreamPrivate;
  TGFileOutputStream = object(TGOutputStream)
    priv1: PGFileOutputStreamPrivate;
    function get_etag: Pgchar; cdecl; inline;
    function query_info(attributes: Pgchar; cancellable: PGCancellable; error: PPGError): PGFileInfo; cdecl; inline;
    procedure query_info_async(attributes: Pgchar; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function query_info_finish(result_: PGAsyncResult; error: PPGError): PGFileInfo; cdecl; inline;
  end;


  { TGFileEnumeratorPrivate }
  PPGFileEnumeratorPrivate = ^PGFileEnumeratorPrivate;
  PGFileEnumeratorPrivate = ^TGFileEnumeratorPrivate;
  TGFileEnumerator = object(TGObject)
    priv: PGFileEnumeratorPrivate;
    function close(cancellable: PGCancellable; error: PPGError): gboolean; cdecl; inline;
    procedure close_async(io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function close_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl; inline;
    function get_child(info: PGFileInfo): PGFile; cdecl; inline;
    function get_container: PGFile; cdecl; inline;
    function has_pending: gboolean; cdecl; inline;
    function is_closed: gboolean; cdecl; inline;
    function iterate(out_info: PPGFileInfo; out_child: PPGFile; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; inline;
    function next_file(cancellable: PGCancellable; error: PPGError): PGFileInfo; cdecl; inline;
    procedure next_files_async(num_files: gint; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function next_files_finish(result_: PGAsyncResult; error: PPGError): PGList; cdecl; inline;
    procedure set_pending(pending: gboolean); cdecl; inline;
    property container: PGFile read get_container  { property is writeable but setter not declared } ;
  end;


  { TGVolume }
  PPGVolume = ^PGVolume;
  PGVolume = ^TGVolume;
  TGMount = object
    changed: procedure; cdecl;
    pre_unmount: procedure; cdecl;
    unmounted: procedure; cdecl;
    function can_eject: gboolean; cdecl; inline;
    function can_unmount: gboolean; cdecl; inline;
    procedure eject_with_operation(flags: TGMountUnmountFlags; mount_operation: PGMountOperation; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function eject_with_operation_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl; inline;
    function get_default_location: PGFile; cdecl; inline;
    function get_drive: PGDrive; cdecl; inline;
    function get_icon: PGIcon; cdecl; inline;
    function get_name: Pgchar; cdecl; inline;
    function get_root: PGFile; cdecl; inline;
    function get_sort_key: Pgchar; cdecl; inline;
    function get_symbolic_icon: PGIcon; cdecl; inline;
    function get_uuid: Pgchar; cdecl; inline;
    function get_volume: PGVolume; cdecl; inline;
    procedure guess_content_type(force_rescan: gboolean; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function guess_content_type_finish(result_: PGAsyncResult; error: PPGError): PPgchar; cdecl; inline;
    function guess_content_type_sync(force_rescan: gboolean; cancellable: PGCancellable; error: PPGError): PPgchar; cdecl; inline;
    function is_shadowed: gboolean; cdecl; inline;
    procedure remount(flags: TGMountMountFlags; mount_operation: PGMountOperation; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function remount_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl; inline;
    procedure shadow; cdecl; inline;
    procedure unmount_with_operation(flags: TGMountUnmountFlags; mount_operation: PGMountOperation; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function unmount_with_operation_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl; inline;
    procedure unshadow; cdecl; inline;
  end;


  { TGFileMonitorEvent }
  PPGFileMonitorEvent = ^PGFileMonitorEvent;
  PGFileMonitorEvent = ^TGFileMonitorEvent;


  { TGFileMonitorPrivate }
  PPGFileMonitorPrivate = ^PGFileMonitorPrivate;
  PGFileMonitorPrivate = ^TGFileMonitorPrivate;
  TGFileMonitor = object(TGObject)
    priv: PGFileMonitorPrivate;
    function cancel: gboolean; cdecl; inline;
    procedure emit_event(child: PGFile; other_file: PGFile; event_type: TGFileMonitorEvent); cdecl; inline;
    function is_cancelled: gboolean; cdecl; inline;
    procedure set_rate_limit(limit_msecs: gint); cdecl; inline;
    //property cancelled: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_cancelled ;
    //property rate_limit: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_rate_limit  { property is writeable but setter not declared } ;
  end;


  { TGFileAttributeStatus }
  PPGFileAttributeStatus = ^PGFileAttributeStatus;
  PGFileAttributeStatus = ^TGFileAttributeStatus;


  { TGFileAttributeMatcher }
  PPGFileAttributeMatcher = ^PGFileAttributeMatcher;
  PGFileAttributeMatcher = ^TGFileAttributeMatcher;
  TGFileInfo = object(TGObject)
    function new: PGFileInfo; cdecl; inline; static;
    procedure clear_status; cdecl; inline;
    procedure copy_into(dest_info: PGFileInfo); cdecl; inline;
    function dup: PGFileInfo; cdecl; inline;
    function get_attribute_as_string(attribute: Pgchar): Pgchar; cdecl; inline;
    function get_attribute_boolean(attribute: Pgchar): gboolean; cdecl; inline;
    function get_attribute_byte_string(attribute: Pgchar): Pgchar; cdecl; inline;
    function get_attribute_data(attribute: Pgchar; type_: PGFileAttributeType; value_pp: Pgpointer; status: PGFileAttributeStatus): gboolean; cdecl; inline;
    function get_attribute_int32(attribute: Pgchar): gint32; cdecl; inline;
    function get_attribute_int64(attribute: Pgchar): gint64; cdecl; inline;
    function get_attribute_object(attribute: Pgchar): PGObject; cdecl; inline;
    function get_attribute_status(attribute: Pgchar): TGFileAttributeStatus; cdecl; inline;
    function get_attribute_string(attribute: Pgchar): Pgchar; cdecl; inline;
    function get_attribute_stringv(attribute: Pgchar): PPgchar; cdecl; inline;
    function get_attribute_type(attribute: Pgchar): TGFileAttributeType; cdecl; inline;
    function get_attribute_uint32(attribute: Pgchar): guint32; cdecl; inline;
    function get_attribute_uint64(attribute: Pgchar): guint64; cdecl; inline;
    function get_content_type: Pgchar; cdecl; inline;
    function get_deletion_date: PGDateTime; cdecl; inline;
    function get_display_name: Pgchar; cdecl; inline;
    function get_edit_name: Pgchar; cdecl; inline;
    function get_etag: Pgchar; cdecl; inline;
    function get_file_type: TGFileType; cdecl; inline;
    function get_icon: PGIcon; cdecl; inline;
    function get_is_backup: gboolean; cdecl; inline;
    function get_is_hidden: gboolean; cdecl; inline;
    function get_is_symlink: gboolean; cdecl; inline;
    function get_modification_date_time: PGDateTime; cdecl; inline;
    function get_name: Pgchar; cdecl; inline;
    function get_size: gint64; cdecl; inline;
    function get_sort_order: gint32; cdecl; inline;
    function get_symbolic_icon: PGIcon; cdecl; inline;
    function get_symlink_target: Pgchar; cdecl; inline;
    function has_attribute(attribute: Pgchar): gboolean; cdecl; inline;
    function has_namespace(name_space: Pgchar): gboolean; cdecl; inline;
    function list_attributes(name_space: Pgchar): PPgchar; cdecl; inline;
    procedure remove_attribute(attribute: Pgchar); cdecl; inline;
    procedure set_attribute(attribute: Pgchar; type_: TGFileAttributeType; value_p: gpointer); cdecl; inline;
    procedure set_attribute_boolean(attribute: Pgchar; attr_value: gboolean); cdecl; inline;
    procedure set_attribute_byte_string(attribute: Pgchar; attr_value: Pgchar); cdecl; inline;
    procedure set_attribute_int32(attribute: Pgchar; attr_value: gint32); cdecl; inline;
    procedure set_attribute_int64(attribute: Pgchar; attr_value: gint64); cdecl; inline;
    procedure set_attribute_mask(mask: PGFileAttributeMatcher); cdecl; inline;
    procedure set_attribute_object(attribute: Pgchar; attr_value: PGObject); cdecl; inline;
    function set_attribute_status(attribute: Pgchar; status: TGFileAttributeStatus): gboolean; cdecl; inline;
    procedure set_attribute_string(attribute: Pgchar; attr_value: Pgchar); cdecl; inline;
    procedure set_attribute_stringv(attribute: Pgchar; attr_value: PPgchar); cdecl; inline;
    procedure set_attribute_uint32(attribute: Pgchar; attr_value: guint32); cdecl; inline;
    procedure set_attribute_uint64(attribute: Pgchar; attr_value: guint64); cdecl; inline;
    procedure set_content_type(content_type: Pgchar); cdecl; inline;
    procedure set_display_name(display_name: Pgchar); cdecl; inline;
    procedure set_edit_name(edit_name: Pgchar); cdecl; inline;
    procedure set_file_type(type_: TGFileType); cdecl; inline;
    procedure set_icon(icon: PGIcon); cdecl; inline;
    procedure set_is_hidden(is_hidden: gboolean); cdecl; inline;
    procedure set_is_symlink(is_symlink: gboolean); cdecl; inline;
    procedure set_modification_date_time(mtime: PGDateTime); cdecl; inline;
    procedure set_name(name: Pgchar); cdecl; inline;
    procedure set_size(size: gint64); cdecl; inline;
    procedure set_sort_order(sort_order: gint32); cdecl; inline;
    procedure set_symbolic_icon(icon: PGIcon); cdecl; inline;
    procedure set_symlink_target(symlink_target: Pgchar); cdecl; inline;
    procedure unset_attribute_mask; cdecl; inline;
  end;


  { TGFileAttributeInfoFlags }
  PPGFileAttributeInfoFlags = ^PGFileAttributeInfoFlags;
  PGFileAttributeInfoFlags = ^TGFileAttributeInfoFlags;


  { TGFileAttributeInfo }
  PPGFileAttributeInfo = ^PGFileAttributeInfo;
  PGFileAttributeInfo = ^TGFileAttributeInfo;
  TGFileAttributeInfoList = object
    infos: PGFileAttributeInfo;
    n_infos: gint;
    function new: PGFileAttributeInfoList; cdecl; inline; static;
    procedure add(name: Pgchar; type_: TGFileAttributeType; flags: TGFileAttributeInfoFlags); cdecl; inline;
    function dup: PGFileAttributeInfoList; cdecl; inline;
    function lookup(name: Pgchar): PGFileAttributeInfo; cdecl; inline;
    function ref: PGFileAttributeInfoList; cdecl; inline;
    procedure unref; cdecl; inline;
  end;


  { TGFileInputStreamPrivate }
  PPGFileInputStreamPrivate = ^PGFileInputStreamPrivate;
  PGFileInputStreamPrivate = ^TGFileInputStreamPrivate;
  TGFileInputStream = object(TGInputStream)
    priv1: PGFileInputStreamPrivate;
    function query_info(attributes: Pgchar; cancellable: PGCancellable; error: PPGError): PGFileInfo; cdecl; inline;
    procedure query_info_async(attributes: Pgchar; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function query_info_finish(result_: PGAsyncResult; error: PPGError): PGFileInfo; cdecl; inline;
  end;

  TGFileAttributeInfo = record
    name: Pgchar;
    type_: TGFileAttributeType;
    flags: TGFileAttributeInfoFlags;
  end;


  TGFileAttributeMatcher = object
    function new(attributes: Pgchar): PGFileAttributeMatcher; cdecl; inline; static;
    function enumerate_namespace(ns: Pgchar): gboolean; cdecl; inline;
    function enumerate_next: Pgchar; cdecl; inline;
    function matches(attribute: Pgchar): gboolean; cdecl; inline;
    function matches_only(attribute: Pgchar): gboolean; cdecl; inline;
    function ref: PGFileAttributeMatcher; cdecl; inline;
    function subtract(subtract: PGFileAttributeMatcher): PGFileAttributeMatcher; cdecl; inline;
    function to_string: Pgchar; cdecl; inline;
    procedure unref; cdecl; inline;
  end;


  { TGFileDescriptorBased }
  PPGFileDescriptorBased = ^PGFileDescriptorBased;
  PGFileDescriptorBased = ^TGFileDescriptorBased;
  TGFileDescriptorBased = object
    function get_fd: gint; cdecl; inline;
  end;


  { TGFileDescriptorBasedIface }
  PPGFileDescriptorBasedIface = ^PGFileDescriptorBasedIface;
  PGFileDescriptorBasedIface = ^TGFileDescriptorBasedIface;
  TGFileDescriptorBasedIface = object
    g_iface: TGTypeInterface;
    get_fd: function(fd_based: PGFileDescriptorBased): gint; cdecl;
  end;

  TGFileEnumeratorPrivate = record
  end;




  { TGFileEnumeratorClass }
  PPGFileEnumeratorClass = ^PGFileEnumeratorClass;
  PGFileEnumeratorClass = ^TGFileEnumeratorClass;
  TGFileEnumeratorClass = object
    parent_class: TGObjectClass;
    next_file: function(enumerator: PGFileEnumerator; cancellable: PGCancellable; error: PPGError): PGFileInfo; cdecl;
    close_fn: function(enumerator: PGFileEnumerator; cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
    next_files_async: procedure(enumerator: PGFileEnumerator; num_files: gint; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    next_files_finish: function(enumerator: PGFileEnumerator; result_: PGAsyncResult; error: PPGError): PGList; cdecl;
    close_async: procedure(enumerator: PGFileEnumerator; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    close_finish: function(enumerator: PGFileEnumerator; result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
    _g_reserved1: procedure; cdecl;
    _g_reserved2: procedure; cdecl;
    _g_reserved3: procedure; cdecl;
    _g_reserved4: procedure; cdecl;
    _g_reserved5: procedure; cdecl;
    _g_reserved6: procedure; cdecl;
    _g_reserved7: procedure; cdecl;
  end;

  TGFileIOStreamPrivate = record
  end;




  { TGIOStreamClass }
  PPGIOStreamClass = ^PGIOStreamClass;
  PGIOStreamClass = ^TGIOStreamClass;
  TGIOStreamClass = object
    parent_class: TGObjectClass;
    get_input_stream: function(stream: PGIOStream): PGInputStream; cdecl;
    get_output_stream: function(stream: PGIOStream): PGOutputStream; cdecl;
    close_fn: function(stream: PGIOStream; cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
    close_async: procedure(stream: PGIOStream; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    close_finish: function(stream: PGIOStream; result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
    _g_reserved1: procedure; cdecl;
    _g_reserved2: procedure; cdecl;
    _g_reserved3: procedure; cdecl;
    _g_reserved4: procedure; cdecl;
    _g_reserved5: procedure; cdecl;
    _g_reserved6: procedure; cdecl;
    _g_reserved7: procedure; cdecl;
    _g_reserved8: procedure; cdecl;
    _g_reserved9: procedure; cdecl;
    _g_reserved10: procedure; cdecl;
  end;


  { TGFileIOStreamClass }
  PPGFileIOStreamClass = ^PGFileIOStreamClass;
  PGFileIOStreamClass = ^TGFileIOStreamClass;
  TGFileIOStreamClass = object
    parent_class: TGIOStreamClass;
    tell: function(stream: PGFileIOStream): gint64; cdecl;
    can_seek: function(stream: PGFileIOStream): gboolean; cdecl;
    seek: function(stream: PGFileIOStream; offset: gint64; type_: TGSeekType; cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
    can_truncate: function(stream: PGFileIOStream): gboolean; cdecl;
    truncate_fn: function(stream: PGFileIOStream; size: gint64; cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
    query_info: function(stream: PGFileIOStream; attributes: Pgchar; cancellable: PGCancellable; error: PPGError): PGFileInfo; cdecl;
    query_info_async: procedure(stream: PGFileIOStream; attributes: Pgchar; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    query_info_finish: function(stream: PGFileIOStream; result_: PGAsyncResult; error: PPGError): PGFileInfo; cdecl;
    get_etag: function(stream: PGFileIOStream): Pgchar; cdecl;
    _g_reserved1: procedure; cdecl;
    _g_reserved2: procedure; cdecl;
    _g_reserved3: procedure; cdecl;
    _g_reserved4: procedure; cdecl;
    _g_reserved5: procedure; cdecl;
  end;


  { TGFileIcon }
  PPGFileIcon = ^PGFileIcon;
  PGFileIcon = ^TGFileIcon;
  TGFileIcon = object(TGObject)
    function new(file_: PGFile): PGFileIcon; cdecl; inline; static;
    function get_file: PGFile; cdecl; inline;
    property file_: PGFile read get_file  { property is writeable but setter not declared } ;
  end;


  { TGFileIconClass }
  PPGFileIconClass = ^PGFileIconClass;
  PGFileIconClass = ^TGFileIconClass;
  TGFileIconClass = object
  end;


  { TGFileIface }
  PPGFileIface = ^PGFileIface;
  PGFileIface = ^TGFileIface;
  TGFileIface = object
    g_iface: TGTypeInterface;
    dup: function(file_: PGFile): PGFile; cdecl;
    hash: function(file_: PGFile): guint; cdecl;
    equal: function(file1: PGFile; file2: PGFile): gboolean; cdecl;
    is_native: function(file_: PGFile): gboolean; cdecl;
    has_uri_scheme: function(file_: PGFile; uri_scheme: Pgchar): gboolean; cdecl;
    get_uri_scheme: function(file_: PGFile): Pgchar; cdecl;
    get_basename: function(file_: PGFile): Pgchar; cdecl;
    get_path: function(file_: PGFile): Pgchar; cdecl;
    get_uri: function(file_: PGFile): Pgchar; cdecl;
    get_parse_name: function(file_: PGFile): Pgchar; cdecl;
    get_parent: function(file_: PGFile): PGFile; cdecl;
    prefix_matches: function(prefix: PGFile; file_: PGFile): gboolean; cdecl;
    get_relative_path: function(parent: PGFile; descendant: PGFile): Pgchar; cdecl;
    resolve_relative_path: function(file_: PGFile; relative_path: Pgchar): PGFile; cdecl;
    get_child_for_display_name: function(file_: PGFile; display_name: Pgchar; error: PPGError): PGFile; cdecl;
    enumerate_children: function(file_: PGFile; attributes: Pgchar; flags: TGFileQueryInfoFlags; cancellable: PGCancellable; error: PPGError): PGFileEnumerator; cdecl;
    enumerate_children_async: procedure(file_: PGFile; attributes: Pgchar; flags: TGFileQueryInfoFlags; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    enumerate_children_finish: function(file_: PGFile; res: PGAsyncResult; error: PPGError): PGFileEnumerator; cdecl;
    query_info: function(file_: PGFile; attributes: Pgchar; flags: TGFileQueryInfoFlags; cancellable: PGCancellable; error: PPGError): PGFileInfo; cdecl;
    query_info_async: procedure(file_: PGFile; attributes: Pgchar; flags: TGFileQueryInfoFlags; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    query_info_finish: function(file_: PGFile; res: PGAsyncResult; error: PPGError): PGFileInfo; cdecl;
    query_filesystem_info: function(file_: PGFile; attributes: Pgchar; cancellable: PGCancellable; error: PPGError): PGFileInfo; cdecl;
    query_filesystem_info_async: procedure(file_: PGFile; attributes: Pgchar; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    query_filesystem_info_finish: function(file_: PGFile; res: PGAsyncResult; error: PPGError): PGFileInfo; cdecl;
    find_enclosing_mount: function(file_: PGFile; cancellable: PGCancellable; error: PPGError): PGMount; cdecl;
    find_enclosing_mount_async: procedure(file_: PGFile; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    find_enclosing_mount_finish: function(file_: PGFile; res: PGAsyncResult; error: PPGError): PGMount; cdecl;
    set_display_name: function(file_: PGFile; display_name: Pgchar; cancellable: PGCancellable; error: PPGError): PGFile; cdecl;
    set_display_name_async: procedure(file_: PGFile; display_name: Pgchar; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    set_display_name_finish: function(file_: PGFile; res: PGAsyncResult; error: PPGError): PGFile; cdecl;
    query_settable_attributes: function(file_: PGFile; cancellable: PGCancellable; error: PPGError): PGFileAttributeInfoList; cdecl;
    _query_settable_attributes_async: procedure; cdecl;
    _query_settable_attributes_finish: procedure; cdecl;
    query_writable_namespaces: function(file_: PGFile; cancellable: PGCancellable; error: PPGError): PGFileAttributeInfoList; cdecl;
    _query_writable_namespaces_async: procedure; cdecl;
    _query_writable_namespaces_finish: procedure; cdecl;
    set_attribute: function(file_: PGFile; attribute: Pgchar; type_: TGFileAttributeType; value_p: gpointer; flags: TGFileQueryInfoFlags; cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
    set_attributes_from_info: function(file_: PGFile; info: PGFileInfo; flags: TGFileQueryInfoFlags; cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
    set_attributes_async: procedure(file_: PGFile; info: PGFileInfo; flags: TGFileQueryInfoFlags; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    set_attributes_finish: function(file_: PGFile; result_: PGAsyncResult; info: PPGFileInfo; error: PPGError): gboolean; cdecl;
    read_fn: function(file_: PGFile; cancellable: PGCancellable; error: PPGError): PGFileInputStream; cdecl;
    read_async: procedure(file_: PGFile; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    read_finish: function(file_: PGFile; res: PGAsyncResult; error: PPGError): PGFileInputStream; cdecl;
    append_to: function(file_: PGFile; flags: TGFileCreateFlags; cancellable: PGCancellable; error: PPGError): PGFileOutputStream; cdecl;
    append_to_async: procedure(file_: PGFile; flags: TGFileCreateFlags; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    append_to_finish: function(file_: PGFile; res: PGAsyncResult; error: PPGError): PGFileOutputStream; cdecl;
    create: function(file_: PGFile; flags: TGFileCreateFlags; cancellable: PGCancellable; error: PPGError): PGFileOutputStream; cdecl;
    create_async: procedure(file_: PGFile; flags: TGFileCreateFlags; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    create_finish: function(file_: PGFile; res: PGAsyncResult; error: PPGError): PGFileOutputStream; cdecl;
    replace: function(file_: PGFile; etag: Pgchar; make_backup: gboolean; flags: TGFileCreateFlags; cancellable: PGCancellable; error: PPGError): PGFileOutputStream; cdecl;
    replace_async: procedure(file_: PGFile; etag: Pgchar; make_backup: gboolean; flags: TGFileCreateFlags; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    replace_finish: function(file_: PGFile; res: PGAsyncResult; error: PPGError): PGFileOutputStream; cdecl;
    delete_file: function(file_: PGFile; cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
    delete_file_async: procedure(file_: PGFile; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    delete_file_finish: function(file_: PGFile; result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
    trash: function(file_: PGFile; cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
    trash_async: procedure(file_: PGFile; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    trash_finish: function(file_: PGFile; result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
    make_directory: function(file_: PGFile; cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
    make_directory_async: procedure(file_: PGFile; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    make_directory_finish: function(file_: PGFile; result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
    make_symbolic_link: function(file_: PGFile; symlink_value: Pgchar; cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
    make_symbolic_link_async: procedure(file_: PGFile; symlink_value: Pgchar; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    make_symbolic_link_finish: function(file_: PGFile; result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
    copy: function(source: PGFile; destination: PGFile; flags: TGFileCopyFlags; cancellable: PGCancellable; progress_callback: TGFileProgressCallback; progress_callback_data: gpointer; error: PPGError): gboolean; cdecl;
    copy_async: procedure(source: PGFile; destination: PGFile; flags: TGFileCopyFlags; io_priority: gint; cancellable: PGCancellable; progress_callback: TGFileProgressCallback; progress_callback_data: gpointer; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    copy_finish: function(file_: PGFile; res: PGAsyncResult; error: PPGError): gboolean; cdecl;
    move: function(source: PGFile; destination: PGFile; flags: TGFileCopyFlags; cancellable: PGCancellable; progress_callback: TGFileProgressCallback; progress_callback_data: gpointer; error: PPGError): gboolean; cdecl;
    move_async: procedure(source: PGFile; destination: PGFile; flags: TGFileCopyFlags; io_priority: gint; cancellable: PGCancellable; progress_callback: TGFileProgressCallback; progress_callback_data: gpointer; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    move_finish: function(file_: PGFile; result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
    mount_mountable: procedure(file_: PGFile; flags: TGMountMountFlags; mount_operation: PGMountOperation; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    mount_mountable_finish: function(file_: PGFile; result_: PGAsyncResult; error: PPGError): PGFile; cdecl;
    unmount_mountable: procedure(file_: PGFile; flags: TGMountUnmountFlags; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    unmount_mountable_finish: function(file_: PGFile; result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
    eject_mountable: procedure(file_: PGFile; flags: TGMountUnmountFlags; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    eject_mountable_finish: function(file_: PGFile; result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
    mount_enclosing_volume: procedure(location: PGFile; flags: TGMountMountFlags; mount_operation: PGMountOperation; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    mount_enclosing_volume_finish: function(location: PGFile; result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
    monitor_dir: function(file_: PGFile; flags: TGFileMonitorFlags; cancellable: PGCancellable; error: PPGError): PGFileMonitor; cdecl;
    monitor_file: function(file_: PGFile; flags: TGFileMonitorFlags; cancellable: PGCancellable; error: PPGError): PGFileMonitor; cdecl;
    open_readwrite: function(file_: PGFile; cancellable: PGCancellable; error: PPGError): PGFileIOStream; cdecl;
    open_readwrite_async: procedure(file_: PGFile; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    open_readwrite_finish: function(file_: PGFile; res: PGAsyncResult; error: PPGError): PGFileIOStream; cdecl;
    create_readwrite: function(file_: PGFile; flags: TGFileCreateFlags; cancellable: PGCancellable; error: PPGError): PGFileIOStream; cdecl;
    create_readwrite_async: procedure(file_: PGFile; flags: TGFileCreateFlags; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    create_readwrite_finish: function(file_: PGFile; res: PGAsyncResult; error: PPGError): PGFileIOStream; cdecl;
    replace_readwrite: function(file_: PGFile; etag: Pgchar; make_backup: gboolean; flags: TGFileCreateFlags; cancellable: PGCancellable; error: PPGError): PGFileIOStream; cdecl;
    replace_readwrite_async: procedure(file_: PGFile; etag: Pgchar; make_backup: gboolean; flags: TGFileCreateFlags; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    replace_readwrite_finish: function(file_: PGFile; res: PGAsyncResult; error: PPGError): PGFileIOStream; cdecl;
    start_mountable: procedure(file_: PGFile; flags: TGDriveStartFlags; start_operation: PGMountOperation; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    start_mountable_finish: function(file_: PGFile; result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
    stop_mountable: procedure(file_: PGFile; flags: TGMountUnmountFlags; mount_operation: PGMountOperation; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    stop_mountable_finish: function(file_: PGFile; result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
    supports_thread_contexts: gboolean;
    unmount_mountable_with_operation: procedure(file_: PGFile; flags: TGMountUnmountFlags; mount_operation: PGMountOperation; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    unmount_mountable_with_operation_finish: function(file_: PGFile; result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
    eject_mountable_with_operation: procedure(file_: PGFile; flags: TGMountUnmountFlags; mount_operation: PGMountOperation; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    eject_mountable_with_operation_finish: function(file_: PGFile; result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
    poll_mountable: procedure(file_: PGFile; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    poll_mountable_finish: function(file_: PGFile; result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
    measure_disk_usage: function(file_: PGFile; flags: TGFileMeasureFlags; cancellable: PGCancellable; progress_callback: TGFileMeasureProgressCallback; progress_data: gpointer; disk_usage: Pguint64; num_dirs: Pguint64; num_files: Pguint64; error: PPGError): gboolean; cdecl;
    measure_disk_usage_async: procedure(file_: PGFile; flags: TGFileMeasureFlags; io_priority: gint; cancellable: PGCancellable; progress_callback: TGFileMeasureProgressCallback; progress_data: gpointer; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    measure_disk_usage_finish: function(file_: PGFile; result_: PGAsyncResult; disk_usage: Pguint64; num_dirs: Pguint64; num_files: Pguint64; error: PPGError): gboolean; cdecl;
  end;


  { TGFileInfoClass }
  PPGFileInfoClass = ^PGFileInfoClass;
  PGFileInfoClass = ^TGFileInfoClass;
  TGFileInfoClass = object
  end;

  TGFileInputStreamPrivate = record
  end;




  { TGFileInputStreamClass }
  PPGFileInputStreamClass = ^PGFileInputStreamClass;
  PGFileInputStreamClass = ^TGFileInputStreamClass;
  TGFileInputStreamClass = object
    parent_class: TGInputStreamClass;
    tell: function(stream: PGFileInputStream): gint64; cdecl;
    can_seek: function(stream: PGFileInputStream): gboolean; cdecl;
    seek: function(stream: PGFileInputStream; offset: gint64; type_: TGSeekType; cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
    query_info: function(stream: PGFileInputStream; attributes: Pgchar; cancellable: PGCancellable; error: PPGError): PGFileInfo; cdecl;
    query_info_async: procedure(stream: PGFileInputStream; attributes: Pgchar; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    query_info_finish: function(stream: PGFileInputStream; result_: PGAsyncResult; error: PPGError): PGFileInfo; cdecl;
    _g_reserved1: procedure; cdecl;
    _g_reserved2: procedure; cdecl;
    _g_reserved3: procedure; cdecl;
    _g_reserved4: procedure; cdecl;
    _g_reserved5: procedure; cdecl;
  end;

  TGFileMonitorPrivate = record
  end;




  { TGFileMonitorClass }
  PPGFileMonitorClass = ^PGFileMonitorClass;
  PGFileMonitorClass = ^TGFileMonitorClass;
  TGFileMonitorClass = object
    parent_class: TGObjectClass;
    changed: procedure(monitor: PGFileMonitor; file_: PGFile; other_file: PGFile; event_type: TGFileMonitorEvent); cdecl;
    cancel: function(monitor: PGFileMonitor): gboolean; cdecl;
    _g_reserved1: procedure; cdecl;
    _g_reserved2: procedure; cdecl;
    _g_reserved3: procedure; cdecl;
    _g_reserved4: procedure; cdecl;
    _g_reserved5: procedure; cdecl;
  end;

  TGFileOutputStreamPrivate = record
  end;




  { TGFileOutputStreamClass }
  PPGFileOutputStreamClass = ^PGFileOutputStreamClass;
  PGFileOutputStreamClass = ^TGFileOutputStreamClass;
  TGFileOutputStreamClass = object
    parent_class: TGOutputStreamClass;
    tell: function(stream: PGFileOutputStream): gint64; cdecl;
    can_seek: function(stream: PGFileOutputStream): gboolean; cdecl;
    seek: function(stream: PGFileOutputStream; offset: gint64; type_: TGSeekType; cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
    can_truncate: function(stream: PGFileOutputStream): gboolean; cdecl;
    truncate_fn: function(stream: PGFileOutputStream; size: gint64; cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
    query_info: function(stream: PGFileOutputStream; attributes: Pgchar; cancellable: PGCancellable; error: PPGError): PGFileInfo; cdecl;
    query_info_async: procedure(stream: PGFileOutputStream; attributes: Pgchar; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    query_info_finish: function(stream: PGFileOutputStream; result_: PGAsyncResult; error: PPGError): PGFileInfo; cdecl;
    get_etag: function(stream: PGFileOutputStream): Pgchar; cdecl;
    _g_reserved1: procedure; cdecl;
    _g_reserved2: procedure; cdecl;
    _g_reserved3: procedure; cdecl;
    _g_reserved4: procedure; cdecl;
    _g_reserved5: procedure; cdecl;
  end;


  { TGFilenameCompleter }
  PPGFilenameCompleter = ^PGFilenameCompleter;
  PGFilenameCompleter = ^TGFilenameCompleter;
  TGFilenameCompleter = object(TGObject)
    function new: PGFilenameCompleter; cdecl; inline; static;
    function get_completion_suffix(initial_text: Pgchar): Pgchar; cdecl; inline;
    function get_completions(initial_text: Pgchar): PPgchar; cdecl; inline;
    procedure set_dirs_only(dirs_only: gboolean); cdecl; inline;
  end;


  { TGFilenameCompleterClass }
  PPGFilenameCompleterClass = ^PGFilenameCompleterClass;
  PGFilenameCompleterClass = ^TGFilenameCompleterClass;
  TGFilenameCompleterClass = object
    parent_class: TGObjectClass;
    got_completion_data: procedure(filename_completer: PGFilenameCompleter); cdecl;
    _g_reserved1: procedure; cdecl;
    _g_reserved2: procedure; cdecl;
    _g_reserved3: procedure; cdecl;
  end;


  { TGFilesystemPreviewType }
  PPGFilesystemPreviewType = ^PGFilesystemPreviewType;
  PGFilesystemPreviewType = ^TGFilesystemPreviewType;


  { TGIOErrorEnum }
  PPGIOErrorEnum = ^PGIOErrorEnum;
  PGIOErrorEnum = ^TGIOErrorEnum;


  { TGIOExtension }
  PPGIOExtension = ^PGIOExtension;
  PGIOExtension = ^TGIOExtension;
  TGIOExtension = object
    function get_name: Pgchar; cdecl; inline;
    function get_priority: gint; cdecl; inline;
    function get_type: TGType; cdecl; inline;
    function ref_class: PGTypeClass; cdecl; inline;
  end;


  { TGIOExtensionPoint }
  PPGIOExtensionPoint = ^PGIOExtensionPoint;
  PGIOExtensionPoint = ^TGIOExtensionPoint;
  TGIOExtensionPoint = object
    function get_extension_by_name(name: Pgchar): PGIOExtension; cdecl; inline;
    function get_extensions: PGList; cdecl; inline;
    function get_required_type: TGType; cdecl; inline;
    procedure set_required_type(type_: TGType); cdecl; inline;
    function implement(extension_point_name: Pgchar; type_: TGType; extension_name: Pgchar; priority: gint): PGIOExtension; cdecl; inline; static;
    function lookup(name: Pgchar): PGIOExtensionPoint; cdecl; inline; static;
    function register(name: Pgchar): PGIOExtensionPoint; cdecl; inline; static;
  end;


  { TGIOModule }
  PPGIOModule = ^PGIOModule;
  PGIOModule = ^TGIOModule;
  TGIOModule = object(TGTypeModule)
    function new(filename: Pgchar): PGIOModule; cdecl; inline; static;
  end;


  { TGIOModuleClass }
  PPGIOModuleClass = ^PGIOModuleClass;
  PGIOModuleClass = ^TGIOModuleClass;
  TGIOModuleClass = object
  end;


  { TGIOModuleScope }
  PPGIOModuleScope = ^PGIOModuleScope;
  PGIOModuleScope = ^TGIOModuleScope;


  { TGIOModuleScopeFlags }
  PPGIOModuleScopeFlags = ^PGIOModuleScopeFlags;
  PGIOModuleScopeFlags = ^TGIOModuleScopeFlags;
  TGIOModuleScope = object
    procedure block(basename: Pgchar); cdecl; inline;
    procedure free; cdecl; inline;
    function new(flags: TGIOModuleScopeFlags): PGIOModuleScope; cdecl; inline; static;
  end;


  { TGIOSchedulerJob }
  PPGIOSchedulerJob = ^PGIOSchedulerJob;
  PGIOSchedulerJob = ^TGIOSchedulerJob;
  TGIOSchedulerJob = object
  end;
  TGIOSchedulerJobFunc = function(job: PGIOSchedulerJob; cancellable: PGCancellable; user_data: gpointer): gboolean; cdecl;

  TGIOStreamPrivate = record
  end;




  { TGIOStreamAdapter }
  PPGIOStreamAdapter = ^PGIOStreamAdapter;
  PGIOStreamAdapter = ^TGIOStreamAdapter;

  TGIOStreamAdapter = record
  end;




  { TGIconIface }
  PPGIconIface = ^PGIconIface;
  PGIconIface = ^TGIconIface;
  TGIconIface = object
    g_iface: TGTypeInterface;
    hash: function(icon: PGIcon): guint; cdecl;
    equal: function(icon1: PGIcon; icon2: PGIcon): gboolean; cdecl;
    to_tokens: function(icon: PGIcon; tokens: Pgpointer; out_version: Pgint): gboolean; cdecl;
    from_tokens: function(tokens: PPgchar; num_tokens: gint; version: gint; error: PPGError): PGIcon; cdecl;
    serialize: function(icon: PGIcon): PGVariant; cdecl;
  end;


  { TGInetAddress }
  PPGInetAddress = ^PGInetAddress;
  PGInetAddress = ^TGInetAddress;


  { TGSocketFamily }
  PPGSocketFamily = ^PGSocketFamily;
  PGSocketFamily = ^TGSocketFamily;


  { TGInetAddressPrivate }
  PPGInetAddressPrivate = ^PGInetAddressPrivate;
  PGInetAddressPrivate = ^TGInetAddressPrivate;
  TGInetAddress = object(TGObject)
    priv: PGInetAddressPrivate;
    function new_any(family: TGSocketFamily): PGInetAddress; cdecl; inline; static;
    function new_from_bytes(bytes: Pguint8; family: TGSocketFamily): PGInetAddress; cdecl; inline; static;
    function new_from_string(string_: Pgchar): PGInetAddress; cdecl; inline; static;
    function new_loopback(family: TGSocketFamily): PGInetAddress; cdecl; inline; static;
    function equal(other_address: PGInetAddress): gboolean; cdecl; inline;
    function get_family: TGSocketFamily; cdecl; inline;
    function get_is_any: gboolean; cdecl; inline;
    function get_is_link_local: gboolean; cdecl; inline;
    function get_is_loopback: gboolean; cdecl; inline;
    function get_is_mc_global: gboolean; cdecl; inline;
    function get_is_mc_link_local: gboolean; cdecl; inline;
    function get_is_mc_node_local: gboolean; cdecl; inline;
    function get_is_mc_org_local: gboolean; cdecl; inline;
    function get_is_mc_site_local: gboolean; cdecl; inline;
    function get_is_multicast: gboolean; cdecl; inline;
    function get_is_site_local: gboolean; cdecl; inline;
    function get_native_size: gsize; cdecl; inline;
    function to_bytes: Pguint8; cdecl; inline;
    function to_string: Pgchar; cdecl; inline;
    //property bytes: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_bytes  { property is writeable but setter not declared } ;
    property family: TGSocketFamily read get_family  { property is writeable but setter not declared } ;
    property is_any: gboolean read get_is_any ;
    property is_link_local: gboolean read get_is_link_local ;
    property is_loopback: gboolean read get_is_loopback ;
    property is_mc_global: gboolean read get_is_mc_global ;
    property is_mc_link_local: gboolean read get_is_mc_link_local ;
    property is_mc_node_local: gboolean read get_is_mc_node_local ;
    property is_mc_org_local: gboolean read get_is_mc_org_local ;
    property is_mc_site_local: gboolean read get_is_mc_site_local ;
    property is_multicast: gboolean read get_is_multicast ;
    property is_site_local: gboolean read get_is_site_local ;
  end;

  TGInetAddressPrivate = record
  end;




  { TGInetAddressClass }
  PPGInetAddressClass = ^PGInetAddressClass;
  PGInetAddressClass = ^TGInetAddressClass;
  TGInetAddressClass = object
    parent_class: TGObjectClass;
    to_string: function(address: PGInetAddress): Pgchar; cdecl;
    to_bytes: function(address: PGInetAddress): Pguint8; cdecl;
  end;


  { TGInetAddressMask }
  PPGInetAddressMask = ^PGInetAddressMask;
  PGInetAddressMask = ^TGInetAddressMask;


  { TGInetAddressMaskPrivate }
  PPGInetAddressMaskPrivate = ^PGInetAddressMaskPrivate;
  PGInetAddressMaskPrivate = ^TGInetAddressMaskPrivate;
  TGInetAddressMask = object(TGObject)
    priv: PGInetAddressMaskPrivate;
    function new(addr: PGInetAddress; length: guint; error: PPGError): PGInetAddressMask; cdecl; inline; static;
    function new_from_string(mask_string: Pgchar; error: PPGError): PGInetAddressMask; cdecl; inline; static;
    function equal(mask2: PGInetAddressMask): gboolean; cdecl; inline;
    function get_address: PGInetAddress; cdecl; inline;
    function get_family: TGSocketFamily; cdecl; inline;
    function get_length: guint; cdecl; inline;
    function matches(address: PGInetAddress): gboolean; cdecl; inline;
    function to_string: Pgchar; cdecl; inline;
    property address: PGInetAddress read get_address  { property is writeable but setter not declared } ;
    property family: TGSocketFamily read get_family ;
    property length: guint read get_length  { property is writeable but setter not declared } ;
  end;

  TGInetAddressMaskPrivate = record
  end;




  { TGInetAddressMaskClass }
  PPGInetAddressMaskClass = ^PGInetAddressMaskClass;
  PGInetAddressMaskClass = ^TGInetAddressMaskClass;
  TGInetAddressMaskClass = object
    parent_class: TGObjectClass;
  end;
  TGSocketAddress = object(TGObject)
    function new_from_native(native: gpointer; len: gsize): PGSocketAddress; cdecl; inline; static;
    function get_family: TGSocketFamily; cdecl; inline;
    function get_native_size: gssize; cdecl; inline;
    function to_native(dest: gpointer; destlen: gsize; error: PPGError): gboolean; cdecl; inline;
    property family: TGSocketFamily read get_family ;
  end;


  { TGInetSocketAddress }
  PPGInetSocketAddress = ^PGInetSocketAddress;
  PGInetSocketAddress = ^TGInetSocketAddress;


  { TGInetSocketAddressPrivate }
  PPGInetSocketAddressPrivate = ^PGInetSocketAddressPrivate;
  PGInetSocketAddressPrivate = ^TGInetSocketAddressPrivate;
  TGInetSocketAddress = object(TGSocketAddress)
    priv: PGInetSocketAddressPrivate;
    function new(address: PGInetAddress; port: guint16): PGInetSocketAddress; cdecl; inline; static;
    function new_from_string(address: Pgchar; port: guint): PGInetSocketAddress; cdecl; inline; static;
    function get_address: PGInetAddress; cdecl; inline;
    function get_flowinfo: guint32; cdecl; inline;
    function get_port: guint16; cdecl; inline;
    function get_scope_id: guint32; cdecl; inline;
    property address: PGInetAddress read get_address  { property is writeable but setter not declared } ;
    property flowinfo: guint32 read get_flowinfo  { property is writeable but setter not declared } ;
    property port: guint16 read get_port  { property is writeable but setter not declared } ;
    property scope_id: guint32 read get_scope_id  { property is writeable but setter not declared } ;
  end;

  TGInetSocketAddressPrivate = record
  end;




  { TGSocketAddressClass }
  PPGSocketAddressClass = ^PGSocketAddressClass;
  PGSocketAddressClass = ^TGSocketAddressClass;
  TGSocketAddressClass = object
    parent_class: TGObjectClass;
    get_family: function(address: PGSocketAddress): TGSocketFamily; cdecl;
    get_native_size: function(address: PGSocketAddress): gssize; cdecl;
    to_native: function(address: PGSocketAddress; dest: gpointer; destlen: gsize; error: PPGError): gboolean; cdecl;
  end;


  { TGInetSocketAddressClass }
  PPGInetSocketAddressClass = ^PGInetSocketAddressClass;
  PGInetSocketAddressClass = ^TGInetSocketAddressClass;
  TGInetSocketAddressClass = object
    parent_class: TGSocketAddressClass;
  end;


  { TGInitableIface }
  PPGInitableIface = ^PGInitableIface;
  PGInitableIface = ^TGInitableIface;
  TGInitableIface = object
    g_iface: TGTypeInterface;
    init: function(initable: PGInitable; cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
  end;

  TGInputVector = record
    buffer: gpointer;
    size: gsize;
  end;




  { TGSocketControlMessagePrivate }
  PPGSocketControlMessagePrivate = ^PGSocketControlMessagePrivate;
  PGSocketControlMessagePrivate = ^TGSocketControlMessagePrivate;
  TGSocketControlMessage = object(TGObject)
    priv: PGSocketControlMessagePrivate;
    function deserialize(level: gint; type_: gint; size: gsize; data: guint8): PGSocketControlMessage; cdecl; inline; static;
    function get_level: gint; cdecl; inline;
    function get_msg_type: gint; cdecl; inline;
    function get_size: gsize; cdecl; inline;
    procedure serialize(data: gpointer); cdecl; inline;
  end;

  TGInputStreamPrivate = record
  end;




  { TGListModel }
  PPGListModel = ^PGListModel;
  PGListModel = ^TGListModel;
  TGListModel = object
    items_changed1: procedure(position: guint; removed: guint; added: guint); cdecl;
    function get_item(position: guint): gpointer; cdecl; inline;
    function get_item_type: TGType; cdecl; inline;
    function get_n_items: guint; cdecl; inline;
    function get_object(position: guint): PGObject; cdecl; inline;
    procedure items_changed(position: guint; removed: guint; added: guint); cdecl; inline;
  end;


  { TGListModelInterface }
  PPGListModelInterface = ^PGListModelInterface;
  PGListModelInterface = ^TGListModelInterface;
  TGListModelInterface = object
    g_iface: TGTypeInterface;
    get_item_type: function(list: PGListModel): TGType; cdecl;
    get_n_items: function(list: PGListModel): guint; cdecl;
    get_item: function(list: PGListModel; position: guint): PGObject; cdecl;
  end;


  { TGListStore }
  PPGListStore = ^PGListStore;
  PGListStore = ^TGListStore;
  TGListStore = object(TGObject)
    function new(item_type: TGType): PGListStore; cdecl; inline; static;
    procedure append(item: PGObject); cdecl; inline;
    function find(item: PGObject; position: Pguint): gboolean; cdecl; inline;
    function find_with_equal_func(item: PGObject; equal_func: TGEqualFunc; position: Pguint): gboolean; cdecl; inline;
    procedure insert(position: guint; item: PGObject); cdecl; inline;
    function insert_sorted(item: PGObject; compare_func: TGCompareDataFunc; user_data: gpointer): guint; cdecl; inline;
    procedure remove(position: guint); cdecl; inline;
    procedure remove_all; cdecl; inline;
    procedure sort(compare_func: TGCompareDataFunc; user_data: gpointer); cdecl; inline;
    procedure splice(position: guint; n_removals: guint; additions: PGObject; n_additions: guint); cdecl; inline;
    //property item_type: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_item_type  { property is writeable but setter not declared } ;
  end;


  { TGListStoreClass }
  PPGListStoreClass = ^PGListStoreClass;
  PGListStoreClass = ^TGListStoreClass;
  TGListStoreClass = object
    parent_class: TGObjectClass;
  end;


  { TGLoadableIconIface }
  PPGLoadableIconIface = ^PGLoadableIconIface;
  PGLoadableIconIface = ^TGLoadableIconIface;
  TGLoadableIconIface = object
    g_iface: TGTypeInterface;
    load: function(icon: PGLoadableIcon; size: gint; type_: PPgchar; cancellable: PGCancellable; error: PPGError): PGInputStream; cdecl;
    load_async: procedure(icon: PGLoadableIcon; size: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    load_finish: function(icon: PGLoadableIcon; res: PGAsyncResult; type_: PPgchar; error: PPGError): PGInputStream; cdecl;
  end;


  { TGMemoryInputStream }
  PPGMemoryInputStream = ^PGMemoryInputStream;
  PGMemoryInputStream = ^TGMemoryInputStream;


  { TGMemoryInputStreamPrivate }
  PPGMemoryInputStreamPrivate = ^PGMemoryInputStreamPrivate;
  PGMemoryInputStreamPrivate = ^TGMemoryInputStreamPrivate;
  TGMemoryInputStream = object(TGInputStream)
    priv1: PGMemoryInputStreamPrivate;
    function new: PGMemoryInputStream; cdecl; inline; static;
    function new_from_bytes(bytes: PGBytes): PGMemoryInputStream; cdecl; inline; static;
    function new_from_data(data: Pguint8; len: gssize; destroy_: TGDestroyNotify): PGMemoryInputStream; cdecl; inline; static;
    procedure add_bytes(bytes: PGBytes); cdecl; inline;
    procedure add_data(data: Pguint8; len: gssize; destroy_: TGDestroyNotify); cdecl; inline;
  end;

  TGMemoryInputStreamPrivate = record
  end;




  { TGMemoryInputStreamClass }
  PPGMemoryInputStreamClass = ^PGMemoryInputStreamClass;
  PGMemoryInputStreamClass = ^TGMemoryInputStreamClass;
  TGMemoryInputStreamClass = object
    parent_class: TGInputStreamClass;
    _g_reserved1: procedure; cdecl;
    _g_reserved2: procedure; cdecl;
    _g_reserved3: procedure; cdecl;
    _g_reserved4: procedure; cdecl;
    _g_reserved5: procedure; cdecl;
  end;


  { TGMemoryMonitor }
  PPGMemoryMonitor = ^PGMemoryMonitor;
  PGMemoryMonitor = ^TGMemoryMonitor;


  { TGMemoryMonitorWarningLevel }
  PPGMemoryMonitorWarningLevel = ^PGMemoryMonitorWarningLevel;
  PGMemoryMonitorWarningLevel = ^TGMemoryMonitorWarningLevel;
  TGMemoryMonitor = object
    low_memory_warning: procedure(level: TGMemoryMonitorWarningLevel); cdecl;
    function dup_default: PGMemoryMonitor; cdecl; inline; static;
  end;


  { TGMemoryMonitorInterface }
  PPGMemoryMonitorInterface = ^PGMemoryMonitorInterface;
  PGMemoryMonitorInterface = ^TGMemoryMonitorInterface;
  TGMemoryMonitorInterface = object
    g_iface: TGTypeInterface;
    low_memory_warning: procedure(monitor: PGMemoryMonitor; level: TGMemoryMonitorWarningLevel); cdecl;
  end;
  TGReallocFunc = function(data: gpointer; size: gsize): gpointer; cdecl;


  { TGMemoryOutputStream }
  PPGMemoryOutputStream = ^PGMemoryOutputStream;
  PGMemoryOutputStream = ^TGMemoryOutputStream;


  { TGReallocFunc }
  PPGReallocFunc = ^PGReallocFunc;
  PGReallocFunc = ^TGReallocFunc;


  { TGMemoryOutputStreamPrivate }
  PPGMemoryOutputStreamPrivate = ^PGMemoryOutputStreamPrivate;
  PGMemoryOutputStreamPrivate = ^TGMemoryOutputStreamPrivate;
  TGMemoryOutputStream = object(TGOutputStream)
    priv1: PGMemoryOutputStreamPrivate;
    function new(data: gpointer; size: gsize; realloc_function: TGReallocFunc; destroy_function: TGDestroyNotify): PGMemoryOutputStream; cdecl; inline; static;
    function new_resizable: PGMemoryOutputStream; cdecl; inline; static;
    function get_data: gpointer; cdecl; inline;
    function get_data_size: gsize; cdecl; inline;
    function get_size: gsize; cdecl; inline;
    function steal_as_bytes: PGBytes; cdecl; inline;
    function steal_data: gpointer; cdecl; inline;
    property data: gpointer read get_data  { property is writeable but setter not declared } ;
    property data_size: gsize read get_data_size ;
    //property destroy_function: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_destroy_function  { property is writeable but setter not declared } ;
    //property realloc_function: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_realloc_function  { property is writeable but setter not declared } ;
    property size: gsize read get_size  { property is writeable but setter not declared } ;
  end;

  TGMemoryOutputStreamPrivate = record
  end;




  { TGMemoryOutputStreamClass }
  PPGMemoryOutputStreamClass = ^PGMemoryOutputStreamClass;
  PGMemoryOutputStreamClass = ^TGMemoryOutputStreamClass;
  TGMemoryOutputStreamClass = object
    parent_class: TGOutputStreamClass;
    _g_reserved1: procedure; cdecl;
    _g_reserved2: procedure; cdecl;
    _g_reserved3: procedure; cdecl;
    _g_reserved4: procedure; cdecl;
    _g_reserved5: procedure; cdecl;
  end;


  { TGMenu }
  PPGMenu = ^PGMenu;
  PGMenu = ^TGMenu;


  { TGMenuItem }
  PPGMenuItem = ^PGMenuItem;
  PGMenuItem = ^TGMenuItem;
  TGMenu = object(TGMenuModel)
    function new: PGMenu; cdecl; inline; static;
    procedure append(label_: Pgchar; detailed_action: Pgchar); cdecl; inline;
    procedure append_item(item: PGMenuItem); cdecl; inline;
    procedure append_section(label_: Pgchar; section: PGMenuModel); cdecl; inline;
    procedure append_submenu(label_: Pgchar; submenu: PGMenuModel); cdecl; inline;
    procedure freeze; cdecl; inline;
    procedure insert(position: gint; label_: Pgchar; detailed_action: Pgchar); cdecl; inline;
    procedure insert_item(position: gint; item: PGMenuItem); cdecl; inline;
    procedure insert_section(position: gint; label_: Pgchar; section: PGMenuModel); cdecl; inline;
    procedure insert_submenu(position: gint; label_: Pgchar; submenu: PGMenuModel); cdecl; inline;
    procedure prepend(label_: Pgchar; detailed_action: Pgchar); cdecl; inline;
    procedure prepend_item(item: PGMenuItem); cdecl; inline;
    procedure prepend_section(label_: Pgchar; section: PGMenuModel); cdecl; inline;
    procedure prepend_submenu(label_: Pgchar; submenu: PGMenuModel); cdecl; inline;
    procedure remove(position: gint); cdecl; inline;
    procedure remove_all; cdecl; inline;
  end;
  TGMenuItem = object(TGObject)
    function new(label_: Pgchar; detailed_action: Pgchar): PGMenuItem; cdecl; inline; static;
    function new_from_model(model: PGMenuModel; item_index: gint): PGMenuItem; cdecl; inline; static;
    function new_section(label_: Pgchar; section: PGMenuModel): PGMenuItem; cdecl; inline; static;
    function new_submenu(label_: Pgchar; submenu: PGMenuModel): PGMenuItem; cdecl; inline; static;
    //function get_attribute(attribute: Pgchar; format_string: Pgchar; args: array of const): gboolean; cdecl; inline;
    function get_attribute_value(attribute: Pgchar; expected_type: PGVariantType): PGVariant; cdecl; inline;
    function get_link(link: Pgchar): PGMenuModel; cdecl; inline;
    //procedure set_action_and_target(action: Pgchar; format_string: Pgchar; args: array of const); cdecl; inline;
    procedure set_action_and_target_value(action: Pgchar; target_value: PGVariant); cdecl; inline;
    //procedure set_attribute(attribute: Pgchar; format_string: Pgchar; args: array of const); cdecl; inline;
    procedure set_attribute_value(attribute: Pgchar; value: PGVariant); cdecl; inline;
    procedure set_detailed_action(detailed_action: Pgchar); cdecl; inline;
    procedure set_icon(icon: PGIcon); cdecl; inline;
    procedure set_label(label_: Pgchar); cdecl; inline;
    procedure set_link(link: Pgchar; model: PGMenuModel); cdecl; inline;
    procedure set_section(section: PGMenuModel); cdecl; inline;
    procedure set_submenu(submenu: PGMenuModel); cdecl; inline;
  end;


  { TGMenuAttributeIterPrivate }
  PPGMenuAttributeIterPrivate = ^PGMenuAttributeIterPrivate;
  PGMenuAttributeIterPrivate = ^TGMenuAttributeIterPrivate;
  TGMenuAttributeIter = object(TGObject)
    priv: PGMenuAttributeIterPrivate;
    function get_name: Pgchar; cdecl; inline;
    function get_next(out_name: PPgchar; value: PPGVariant): gboolean; cdecl; inline;
    function get_value: PGVariant; cdecl; inline;
    function next: gboolean; cdecl; inline;
  end;

  TGMenuAttributeIterPrivate = record
  end;




  { TGMenuAttributeIterClass }
  PPGMenuAttributeIterClass = ^PGMenuAttributeIterClass;
  PGMenuAttributeIterClass = ^TGMenuAttributeIterClass;
  TGMenuAttributeIterClass = object
    parent_class: TGObjectClass;
    get_next: function(iter: PGMenuAttributeIter; out_name: PPgchar; value: PPGVariant): gboolean; cdecl;
  end;


  { TGMenuLinkIterPrivate }
  PPGMenuLinkIterPrivate = ^PGMenuLinkIterPrivate;
  PGMenuLinkIterPrivate = ^TGMenuLinkIterPrivate;
  TGMenuLinkIter = object(TGObject)
    priv: PGMenuLinkIterPrivate;
    function get_name: Pgchar; cdecl; inline;
    function get_next(out_link: PPgchar; value: PPGMenuModel): gboolean; cdecl; inline;
    function get_value: PGMenuModel; cdecl; inline;
    function next: gboolean; cdecl; inline;
  end;

  TGMenuLinkIterPrivate = record
  end;




  { TGMenuLinkIterClass }
  PPGMenuLinkIterClass = ^PGMenuLinkIterClass;
  PGMenuLinkIterClass = ^TGMenuLinkIterClass;
  TGMenuLinkIterClass = object
    parent_class: TGObjectClass;
    get_next: function(iter: PGMenuLinkIter; out_link: PPgchar; value: PPGMenuModel): gboolean; cdecl;
  end;

  TGMenuModelPrivate = record
  end;




  { TGMenuModelClass }
  PPGMenuModelClass = ^PGMenuModelClass;
  PGMenuModelClass = ^TGMenuModelClass;
  TGMenuModelClass = object
    parent_class: TGObjectClass;
    is_mutable: function(model: PGMenuModel): gboolean; cdecl;
    get_n_items: function(model: PGMenuModel): gint; cdecl;
    get_item_attributes: procedure(model: PGMenuModel; item_index: gint; attributes: PPGHashTable); cdecl;
    iterate_item_attributes: function(model: PGMenuModel; item_index: gint): PGMenuAttributeIter; cdecl;
    get_item_attribute_value: function(model: PGMenuModel; item_index: gint; attribute: Pgchar; expected_type: PGVariantType): PGVariant; cdecl;
    get_item_links: procedure(model: PGMenuModel; item_index: gint; links: PPGHashTable); cdecl;
    iterate_item_links: function(model: PGMenuModel; item_index: gint): PGMenuLinkIter; cdecl;
    get_item_link: function(model: PGMenuModel; item_index: gint; link: Pgchar): PGMenuModel; cdecl;
  end;
  TGVolume = object
    changed: procedure; cdecl;
    removed: procedure; cdecl;
    function can_eject: gboolean; cdecl; inline;
    function can_mount: gboolean; cdecl; inline;
    procedure eject_with_operation(flags: TGMountUnmountFlags; mount_operation: PGMountOperation; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function eject_with_operation_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl; inline;
    function enumerate_identifiers: PPgchar; cdecl; inline;
    function get_activation_root: PGFile; cdecl; inline;
    function get_drive: PGDrive; cdecl; inline;
    function get_icon: PGIcon; cdecl; inline;
    function get_identifier(kind: Pgchar): Pgchar; cdecl; inline;
    function get_mount: PGMount; cdecl; inline;
    function get_name: Pgchar; cdecl; inline;
    function get_sort_key: Pgchar; cdecl; inline;
    function get_symbolic_icon: PGIcon; cdecl; inline;
    function get_uuid: Pgchar; cdecl; inline;
    procedure mount(flags: TGMountMountFlags; mount_operation: PGMountOperation; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function mount_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl; inline;
    function should_automount: gboolean; cdecl; inline;
  end;


  { TGMountIface }
  PPGMountIface = ^PGMountIface;
  PGMountIface = ^TGMountIface;
  TGMountIface = object
    g_iface: TGTypeInterface;
    changed: procedure(mount: PGMount); cdecl;
    unmounted: procedure(mount: PGMount); cdecl;
    get_root: function(mount: PGMount): PGFile; cdecl;
    get_name: function(mount: PGMount): Pgchar; cdecl;
    get_icon: function(mount: PGMount): PGIcon; cdecl;
    get_uuid: function(mount: PGMount): Pgchar; cdecl;
    get_volume: function(mount: PGMount): PGVolume; cdecl;
    get_drive: function(mount: PGMount): PGDrive; cdecl;
    can_unmount: function(mount: PGMount): gboolean; cdecl;
    can_eject: function(mount: PGMount): gboolean; cdecl;
    unmount: procedure(mount: PGMount; flags: TGMountUnmountFlags; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    unmount_finish: function(mount: PGMount; result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
    eject: procedure(mount: PGMount; flags: TGMountUnmountFlags; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    eject_finish: function(mount: PGMount; result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
    remount: procedure(mount: PGMount; flags: TGMountMountFlags; mount_operation: PGMountOperation; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    remount_finish: function(mount: PGMount; result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
    guess_content_type: procedure(mount: PGMount; force_rescan: gboolean; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    guess_content_type_finish: function(mount: PGMount; result_: PGAsyncResult; error: PPGError): PPgchar; cdecl;
    guess_content_type_sync: function(mount: PGMount; force_rescan: gboolean; cancellable: PGCancellable; error: PPGError): PPgchar; cdecl;
    pre_unmount: procedure(mount: PGMount); cdecl;
    unmount_with_operation: procedure(mount: PGMount; flags: TGMountUnmountFlags; mount_operation: PGMountOperation; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    unmount_with_operation_finish: function(mount: PGMount; result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
    eject_with_operation: procedure(mount: PGMount; flags: TGMountUnmountFlags; mount_operation: PGMountOperation; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    eject_with_operation_finish: function(mount: PGMount; result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
    get_default_location: function(mount: PGMount): PGFile; cdecl;
    get_sort_key: function(mount: PGMount): Pgchar; cdecl;
    get_symbolic_icon: function(mount: PGMount): PGIcon; cdecl;
  end;

  TGMountOperationPrivate = record
  end;




  { TGMountOperationClass }
  PPGMountOperationClass = ^PGMountOperationClass;
  PGMountOperationClass = ^TGMountOperationClass;
  TGMountOperationClass = object
    parent_class: TGObjectClass;
    ask_password: procedure(op: PGMountOperation; message: Pgchar; default_user: Pgchar; default_domain: Pgchar; flags: TGAskPasswordFlags); cdecl;
    ask_question: procedure(op: PGMountOperation; message: Pgchar; choices: PPgchar); cdecl;
    reply: procedure(op: PGMountOperation; result_: TGMountOperationResult); cdecl;
    aborted: procedure(op: PGMountOperation); cdecl;
    show_processes: procedure(op: PGMountOperation; message: Pgchar; processes: PGPid; choices: PPgchar); cdecl;
    show_unmount_progress: procedure(op: PGMountOperation; message: Pgchar; time_left: gint64; bytes_left: gint64); cdecl;
    _g_reserved1: procedure; cdecl;
    _g_reserved2: procedure; cdecl;
    _g_reserved3: procedure; cdecl;
    _g_reserved4: procedure; cdecl;
    _g_reserved5: procedure; cdecl;
    _g_reserved6: procedure; cdecl;
    _g_reserved7: procedure; cdecl;
    _g_reserved8: procedure; cdecl;
    _g_reserved9: procedure; cdecl;
  end;


  { TGNativeSocketAddressPrivate }
  PPGNativeSocketAddressPrivate = ^PGNativeSocketAddressPrivate;
  PGNativeSocketAddressPrivate = ^TGNativeSocketAddressPrivate;

  TGNativeSocketAddressPrivate = record
  end;




  { TGNativeSocketAddress }
  PPGNativeSocketAddress = ^PGNativeSocketAddress;
  PGNativeSocketAddress = ^TGNativeSocketAddress;
  TGNativeSocketAddress = object(TGSocketAddress)
    priv: PGNativeSocketAddressPrivate;
    function new(native: gpointer; len: gsize): PGNativeSocketAddress; cdecl; inline; static;
  end;


  { TGNativeSocketAddressClass }
  PPGNativeSocketAddressClass = ^PGNativeSocketAddressClass;
  PGNativeSocketAddressClass = ^TGNativeSocketAddressClass;
  TGNativeSocketAddressClass = object
    parent_class: TGSocketAddressClass;
  end;


  { TGVolumeMonitor }
  PPGVolumeMonitor = ^PGVolumeMonitor;
  PGVolumeMonitor = ^TGVolumeMonitor;
  TGVolumeMonitor = object(TGObject)
    priv: gpointer;
    function get: PGVolumeMonitor; cdecl; inline; static;
    function get_connected_drives: PGList; cdecl; inline;
    function get_mount_for_uuid(uuid: Pgchar): PGMount; cdecl; inline;
    function get_mounts: PGList; cdecl; inline;
    function get_volume_for_uuid(uuid: Pgchar): PGVolume; cdecl; inline;
    function get_volumes: PGList; cdecl; inline;
  end;


  { TGNativeVolumeMonitor }
  PPGNativeVolumeMonitor = ^PGNativeVolumeMonitor;
  PGNativeVolumeMonitor = ^TGNativeVolumeMonitor;
  TGNativeVolumeMonitor = object(TGVolumeMonitor)
  end;


  { TGVolumeMonitorClass }
  PPGVolumeMonitorClass = ^PGVolumeMonitorClass;
  PGVolumeMonitorClass = ^TGVolumeMonitorClass;
  TGVolumeMonitorClass = object
    parent_class: TGObjectClass;
    volume_added: procedure(volume_monitor: PGVolumeMonitor; volume: PGVolume); cdecl;
    volume_removed: procedure(volume_monitor: PGVolumeMonitor; volume: PGVolume); cdecl;
    volume_changed: procedure(volume_monitor: PGVolumeMonitor; volume: PGVolume); cdecl;
    mount_added: procedure(volume_monitor: PGVolumeMonitor; mount: PGMount); cdecl;
    mount_removed: procedure(volume_monitor: PGVolumeMonitor; mount: PGMount); cdecl;
    mount_pre_unmount: procedure(volume_monitor: PGVolumeMonitor; mount: PGMount); cdecl;
    mount_changed: procedure(volume_monitor: PGVolumeMonitor; mount: PGMount); cdecl;
    drive_connected: procedure(volume_monitor: PGVolumeMonitor; drive: PGDrive); cdecl;
    drive_disconnected: procedure(volume_monitor: PGVolumeMonitor; drive: PGDrive); cdecl;
    drive_changed: procedure(volume_monitor: PGVolumeMonitor; drive: PGDrive); cdecl;
    is_supported: function: gboolean; cdecl;
    get_connected_drives: function(volume_monitor: PGVolumeMonitor): PGList; cdecl;
    get_volumes: function(volume_monitor: PGVolumeMonitor): PGList; cdecl;
    get_mounts: function(volume_monitor: PGVolumeMonitor): PGList; cdecl;
    get_volume_for_uuid: function(volume_monitor: PGVolumeMonitor; uuid: Pgchar): PGVolume; cdecl;
    get_mount_for_uuid: function(volume_monitor: PGVolumeMonitor; uuid: Pgchar): PGMount; cdecl;
    adopt_orphan_mount: function(mount: PGMount; volume_monitor: PGVolumeMonitor): PGVolume; cdecl;
    drive_eject_button: procedure(volume_monitor: PGVolumeMonitor; drive: PGDrive); cdecl;
    drive_stop_button: procedure(volume_monitor: PGVolumeMonitor; drive: PGDrive); cdecl;
    _g_reserved1: procedure; cdecl;
    _g_reserved2: procedure; cdecl;
    _g_reserved3: procedure; cdecl;
    _g_reserved4: procedure; cdecl;
    _g_reserved5: procedure; cdecl;
    _g_reserved6: procedure; cdecl;
  end;


  { TGNativeVolumeMonitorClass }
  PPGNativeVolumeMonitorClass = ^PGNativeVolumeMonitorClass;
  PGNativeVolumeMonitorClass = ^TGNativeVolumeMonitorClass;
  TGNativeVolumeMonitorClass = object
    parent_class: TGVolumeMonitorClass;
    get_mount_for_mount_path: function(mount_path: Pgchar; cancellable: PGCancellable): PGMount; cdecl;
  end;


  { TGNetworkAddress }
  PPGNetworkAddress = ^PGNetworkAddress;
  PGNetworkAddress = ^TGNetworkAddress;


  { TGNetworkAddressPrivate }
  PPGNetworkAddressPrivate = ^PGNetworkAddressPrivate;
  PGNetworkAddressPrivate = ^TGNetworkAddressPrivate;
  TGNetworkAddress = object(TGObject)
    priv: PGNetworkAddressPrivate;
    function new(hostname: Pgchar; port: guint16): PGNetworkAddress; cdecl; inline; static;
    function new_loopback(port: guint16): PGNetworkAddress; cdecl; inline; static;
    function parse(host_and_port: Pgchar; default_port: guint16; error: PPGError): PGNetworkAddress; cdecl; inline; static;
    function parse_uri(uri: Pgchar; default_port: guint16; error: PPGError): PGNetworkAddress; cdecl; inline; static;
    function get_hostname: Pgchar; cdecl; inline;
    function get_port: guint16; cdecl; inline;
    function get_scheme: Pgchar; cdecl; inline;
    property hostname: Pgchar read get_hostname  { property is writeable but setter not declared } ;
    property port: guint16 read get_port  { property is writeable but setter not declared } ;
    property scheme: Pgchar read get_scheme  { property is writeable but setter not declared } ;
  end;

  TGNetworkAddressPrivate = record
  end;




  { TGNetworkAddressClass }
  PPGNetworkAddressClass = ^PGNetworkAddressClass;
  PGNetworkAddressClass = ^TGNetworkAddressClass;
  TGNetworkAddressClass = object
    parent_class: TGObjectClass;
  end;


  { TGNetworkConnectivity }
  PPGNetworkConnectivity = ^PGNetworkConnectivity;
  PGNetworkConnectivity = ^TGNetworkConnectivity;


  { TGNetworkMonitor }
  PPGNetworkMonitor = ^PGNetworkMonitor;
  PGNetworkMonitor = ^TGNetworkMonitor;
  TGNetworkMonitor = object
    network_changed: procedure(network_available: gboolean); cdecl;
    function get_default: PGNetworkMonitor; cdecl; inline; static;
    function can_reach(connectable: PGSocketConnectable; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; inline;
    procedure can_reach_async(connectable: PGSocketConnectable; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function can_reach_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl; inline;
    function get_connectivity: TGNetworkConnectivity; cdecl; inline;
    function get_network_available: gboolean; cdecl; inline;
    function get_network_metered: gboolean; cdecl; inline;
    property connectivity: TGNetworkConnectivity read get_connectivity ;
    property network_available: gboolean read get_network_available ;
    property network_metered: gboolean read get_network_metered ;
  end;


  { TGNetworkMonitorInterface }
  PPGNetworkMonitorInterface = ^PGNetworkMonitorInterface;
  PGNetworkMonitorInterface = ^TGNetworkMonitorInterface;
  TGNetworkMonitorInterface = object
    g_iface: TGTypeInterface;
    network_changed: procedure(monitor: PGNetworkMonitor; network_available: gboolean); cdecl;
    can_reach: function(monitor: PGNetworkMonitor; connectable: PGSocketConnectable; cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
    can_reach_async: procedure(monitor: PGNetworkMonitor; connectable: PGSocketConnectable; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    can_reach_finish: function(monitor: PGNetworkMonitor; result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
  end;


  { TGNetworkService }
  PPGNetworkService = ^PGNetworkService;
  PGNetworkService = ^TGNetworkService;


  { TGNetworkServicePrivate }
  PPGNetworkServicePrivate = ^PGNetworkServicePrivate;
  PGNetworkServicePrivate = ^TGNetworkServicePrivate;
  TGNetworkService = object(TGObject)
    priv: PGNetworkServicePrivate;
    function new(service: Pgchar; protocol: Pgchar; domain: Pgchar): PGNetworkService; cdecl; inline; static;
    function get_domain: Pgchar; cdecl; inline;
    function get_protocol: Pgchar; cdecl; inline;
    function get_scheme: Pgchar; cdecl; inline;
    function get_service: Pgchar; cdecl; inline;
    procedure set_scheme(scheme: Pgchar); cdecl; inline;
    property domain: Pgchar read get_domain  { property is writeable but setter not declared } ;
    property protocol: Pgchar read get_protocol  { property is writeable but setter not declared } ;
    property scheme: Pgchar read get_scheme write set_scheme;
    property service: Pgchar read get_service  { property is writeable but setter not declared } ;
  end;

  TGNetworkServicePrivate = record
  end;




  { TGNetworkServiceClass }
  PPGNetworkServiceClass = ^PGNetworkServiceClass;
  PGNetworkServiceClass = ^TGNetworkServiceClass;
  TGNetworkServiceClass = object
    parent_class: TGObjectClass;
  end;

  TGOutputVector = record
    buffer: Pgpointer;
    size: gsize;
  end;



  TGOutputStreamPrivate = record
  end;




  { TGPermission }
  PPGPermission = ^PGPermission;
  PGPermission = ^TGPermission;


  { TGPermissionPrivate }
  PPGPermissionPrivate = ^PGPermissionPrivate;
  PGPermissionPrivate = ^TGPermissionPrivate;
  TGPermission = object(TGObject)
    priv: PGPermissionPrivate;
    function acquire(cancellable: PGCancellable; error: PPGError): gboolean; cdecl; inline;
    procedure acquire_async(cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function acquire_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl; inline;
    function get_allowed: gboolean; cdecl; inline;
    function get_can_acquire: gboolean; cdecl; inline;
    function get_can_release: gboolean; cdecl; inline;
    procedure impl_update(allowed: gboolean; can_acquire: gboolean; can_release: gboolean); cdecl; inline;
    function release(cancellable: PGCancellable; error: PPGError): gboolean; cdecl; inline;
    procedure release_async(cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function release_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl; inline;
    property allowed: gboolean read get_allowed ;
    property can_acquire: gboolean read get_can_acquire ;
    property can_release: gboolean read get_can_release ;
  end;

  TGPermissionPrivate = record
  end;




  { TGPermissionClass }
  PPGPermissionClass = ^PGPermissionClass;
  PGPermissionClass = ^TGPermissionClass;
  TGPermissionClass = object
    parent_class: TGObjectClass;
    acquire: function(permission: PGPermission; cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
    acquire_async: procedure(permission: PGPermission; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    acquire_finish: function(permission: PGPermission; result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
    release: function(permission: PGPermission; cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
    release_async: procedure(permission: PGPermission; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    release_finish: function(permission: PGPermission; result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
    reserved: array [0..15] of gpointer;
  end;


  { TGPollableInputStreamInterface }
  PPGPollableInputStreamInterface = ^PGPollableInputStreamInterface;
  PGPollableInputStreamInterface = ^TGPollableInputStreamInterface;
  TGPollableInputStreamInterface = object
    g_iface: TGTypeInterface;
    can_poll: function(stream: PGPollableInputStream): gboolean; cdecl;
    is_readable: function(stream: PGPollableInputStream): gboolean; cdecl;
    create_source: function(stream: PGPollableInputStream; cancellable: PGCancellable): PGSource; cdecl;
    read_nonblocking: function(stream: PGPollableInputStream; buffer: Pguint8; count: gsize; error: PPGError): gssize; cdecl;
  end;


  { TGPollableOutputStreamInterface }
  PPGPollableOutputStreamInterface = ^PGPollableOutputStreamInterface;
  PGPollableOutputStreamInterface = ^TGPollableOutputStreamInterface;
  TGPollableOutputStreamInterface = object
    g_iface: TGTypeInterface;
    can_poll: function(stream: PGPollableOutputStream): gboolean; cdecl;
    is_writable: function(stream: PGPollableOutputStream): gboolean; cdecl;
    create_source: function(stream: PGPollableOutputStream; cancellable: PGCancellable): PGSource; cdecl;
    write_nonblocking: function(stream: PGPollableOutputStream; buffer: Pguint8; count: gsize; error: PPGError): gssize; cdecl;
    writev_nonblocking: function(stream: PGPollableOutputStream; vectors: PGOutputVector; n_vectors: gsize; bytes_written: Pgsize; error: PPGError): TGPollableReturn; cdecl;
  end;
  TGPollableSourceFunc = function(pollable_stream: PGObject; user_data: gpointer): gboolean; cdecl;


  { TGPropertyAction }
  PPGPropertyAction = ^PGPropertyAction;
  PGPropertyAction = ^TGPropertyAction;
  TGPropertyAction = object(TGObject)
    function new(name: Pgchar; object_: PGObject; property_name: Pgchar): PGPropertyAction; cdecl; inline; static;
    //property enabled: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_enabled ;
    //property invert_boolean: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_invert_boolean  { property is writeable but setter not declared } ;
    //property name: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_name  { property is writeable but setter not declared } ;
    //property object_: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_object  { property is writeable but setter not declared } ;
    //property parameter_type: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_parameter_type ;
    //property property_name: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_property_name  { property is writeable but setter not declared } ;
    //property state: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_state ;
    //property state_type: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_state_type ;
  end;


  { TGProxy }
  PPGProxy = ^PGProxy;
  PGProxy = ^TGProxy;


  { TGProxyAddress }
  PPGProxyAddress = ^PGProxyAddress;
  PGProxyAddress = ^TGProxyAddress;
  TGProxy = object
    function get_default_for_protocol(protocol: Pgchar): PGProxy; cdecl; inline; static;
    function connect(connection: PGIOStream; proxy_address: PGProxyAddress; cancellable: PGCancellable; error: PPGError): PGIOStream; cdecl; inline;
    procedure connect_async(connection: PGIOStream; proxy_address: PGProxyAddress; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function connect_finish(result_: PGAsyncResult; error: PPGError): PGIOStream; cdecl; inline;
    function supports_hostname: gboolean; cdecl; inline;
  end;


  { TGProxyAddressPrivate }
  PPGProxyAddressPrivate = ^PGProxyAddressPrivate;
  PGProxyAddressPrivate = ^TGProxyAddressPrivate;
  TGProxyAddress = object(TGInetSocketAddress)
    priv1: PGProxyAddressPrivate;
    function new(inetaddr: PGInetAddress; port: guint16; protocol: Pgchar; dest_hostname: Pgchar; dest_port: guint16; username: Pgchar; password: Pgchar): PGProxyAddress; cdecl; inline; static;
    function get_destination_hostname: Pgchar; cdecl; inline;
    function get_destination_port: guint16; cdecl; inline;
    function get_destination_protocol: Pgchar; cdecl; inline;
    function get_password: Pgchar; cdecl; inline;
    function get_protocol: Pgchar; cdecl; inline;
    function get_uri: Pgchar; cdecl; inline;
    function get_username: Pgchar; cdecl; inline;
    property destination_hostname: Pgchar read get_destination_hostname  { property is writeable but setter not declared } ;
    property destination_port: guint16 read get_destination_port  { property is writeable but setter not declared } ;
    property destination_protocol: Pgchar read get_destination_protocol  { property is writeable but setter not declared } ;
    property password: Pgchar read get_password  { property is writeable but setter not declared } ;
    property protocol: Pgchar read get_protocol  { property is writeable but setter not declared } ;
    property uri: Pgchar read get_uri  { property is writeable but setter not declared } ;
    property username: Pgchar read get_username  { property is writeable but setter not declared } ;
  end;

  TGProxyAddressPrivate = record
  end;




  { TGProxyAddressClass }
  PPGProxyAddressClass = ^PGProxyAddressClass;
  PGProxyAddressClass = ^TGProxyAddressClass;
  TGProxyAddressClass = object
    parent_class: TGInetSocketAddressClass;
  end;


  { TGProxyResolver }
  PPGProxyResolver = ^PGProxyResolver;
  PGProxyResolver = ^TGProxyResolver;
  TGProxyResolver = object
    function get_default: PGProxyResolver; cdecl; inline; static;
    function is_supported: gboolean; cdecl; inline;
    function lookup(uri: Pgchar; cancellable: PGCancellable; error: PPGError): PPgchar; cdecl; inline;
    procedure lookup_async(uri: Pgchar; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function lookup_finish(result_: PGAsyncResult; error: PPGError): PPgchar; cdecl; inline;
  end;
  TGSocketAddressEnumerator = object(TGObject)
    function next(cancellable: PGCancellable; error: PPGError): PGSocketAddress; cdecl; inline;
    procedure next_async(cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function next_finish(result_: PGAsyncResult; error: PPGError): PGSocketAddress; cdecl; inline;
  end;


  { TGProxyAddressEnumeratorPrivate }
  PPGProxyAddressEnumeratorPrivate = ^PGProxyAddressEnumeratorPrivate;
  PGProxyAddressEnumeratorPrivate = ^TGProxyAddressEnumeratorPrivate;

  TGProxyAddressEnumeratorPrivate = record
  end;




  { TGProxyAddressEnumerator }
  PPGProxyAddressEnumerator = ^PGProxyAddressEnumerator;
  PGProxyAddressEnumerator = ^TGProxyAddressEnumerator;
  TGProxyAddressEnumerator = object(TGSocketAddressEnumerator)
    priv: PGProxyAddressEnumeratorPrivate;
    //property connectable: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_connectable  { property is writeable but setter not declared } ;
    //property default_port: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_default_port  { property is writeable but setter not declared } ;
    //property proxy_resolver: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_proxy_resolver  { property is writeable but setter not declared } ;
    //property uri: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_uri  { property is writeable but setter not declared } ;
  end;


  { TGSocketAddressEnumeratorClass }
  PPGSocketAddressEnumeratorClass = ^PGSocketAddressEnumeratorClass;
  PGSocketAddressEnumeratorClass = ^TGSocketAddressEnumeratorClass;
  TGSocketAddressEnumeratorClass = object
    parent_class: TGObjectClass;
    next: function(enumerator: PGSocketAddressEnumerator; cancellable: PGCancellable; error: PPGError): PGSocketAddress; cdecl;
    next_async: procedure(enumerator: PGSocketAddressEnumerator; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    next_finish: function(enumerator: PGSocketAddressEnumerator; result_: PGAsyncResult; error: PPGError): PGSocketAddress; cdecl;
  end;


  { TGProxyAddressEnumeratorClass }
  PPGProxyAddressEnumeratorClass = ^PGProxyAddressEnumeratorClass;
  PGProxyAddressEnumeratorClass = ^TGProxyAddressEnumeratorClass;
  TGProxyAddressEnumeratorClass = object
    parent_class: TGSocketAddressEnumeratorClass;
    _g_reserved1: procedure; cdecl;
    _g_reserved2: procedure; cdecl;
    _g_reserved3: procedure; cdecl;
    _g_reserved4: procedure; cdecl;
    _g_reserved5: procedure; cdecl;
    _g_reserved6: procedure; cdecl;
    _g_reserved7: procedure; cdecl;
  end;


  { TGProxyInterface }
  PPGProxyInterface = ^PGProxyInterface;
  PGProxyInterface = ^TGProxyInterface;
  TGProxyInterface = object
    g_iface: TGTypeInterface;
    connect: function(proxy: PGProxy; connection: PGIOStream; proxy_address: PGProxyAddress; cancellable: PGCancellable; error: PPGError): PGIOStream; cdecl;
    connect_async: procedure(proxy: PGProxy; connection: PGIOStream; proxy_address: PGProxyAddress; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    connect_finish: function(proxy: PGProxy; result_: PGAsyncResult; error: PPGError): PGIOStream; cdecl;
    supports_hostname: function(proxy: PGProxy): gboolean; cdecl;
  end;


  { TGProxyResolverInterface }
  PPGProxyResolverInterface = ^PGProxyResolverInterface;
  PGProxyResolverInterface = ^TGProxyResolverInterface;
  TGProxyResolverInterface = object
    g_iface: TGTypeInterface;
    is_supported: function(resolver: PGProxyResolver): gboolean; cdecl;
    lookup: function(resolver: PGProxyResolver; uri: Pgchar; cancellable: PGCancellable; error: PPGError): PPgchar; cdecl;
    lookup_async: procedure(resolver: PGProxyResolver; uri: Pgchar; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    lookup_finish: function(resolver: PGProxyResolver; result_: PGAsyncResult; error: PPGError): PPgchar; cdecl;
  end;


  { TGRemoteActionGroupInterface }
  PPGRemoteActionGroupInterface = ^PGRemoteActionGroupInterface;
  PGRemoteActionGroupInterface = ^TGRemoteActionGroupInterface;
  TGRemoteActionGroupInterface = object
    g_iface: TGTypeInterface;
    activate_action_full: procedure(remote: PGRemoteActionGroup; action_name: Pgchar; parameter: PGVariant; platform_data: PGVariant); cdecl;
    change_action_state_full: procedure(remote: PGRemoteActionGroup; action_name: Pgchar; value: PGVariant; platform_data: PGVariant); cdecl;
  end;


  { TGResolver }
  PPGResolver = ^PGResolver;
  PGResolver = ^TGResolver;


  { TGResolverNameLookupFlags }
  PPGResolverNameLookupFlags = ^PGResolverNameLookupFlags;
  PGResolverNameLookupFlags = ^TGResolverNameLookupFlags;


  { TGResolverRecordType }
  PPGResolverRecordType = ^PGResolverRecordType;
  PGResolverRecordType = ^TGResolverRecordType;


  { TGResolverPrivate }
  PPGResolverPrivate = ^PGResolverPrivate;
  PGResolverPrivate = ^TGResolverPrivate;
  TGResolver = object(TGObject)
    priv: PGResolverPrivate;
    procedure free_addresses(addresses: PGList); cdecl; inline; static;
    procedure free_targets(targets: PGList); cdecl; inline; static;
    function get_default: PGResolver; cdecl; inline; static;
    function lookup_by_address(address: PGInetAddress; cancellable: PGCancellable; error: PPGError): Pgchar; cdecl; inline;
    procedure lookup_by_address_async(address: PGInetAddress; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function lookup_by_address_finish(result_: PGAsyncResult; error: PPGError): Pgchar; cdecl; inline;
    function lookup_by_name(hostname: Pgchar; cancellable: PGCancellable; error: PPGError): PGList; cdecl; inline;
    procedure lookup_by_name_async(hostname: Pgchar; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function lookup_by_name_finish(result_: PGAsyncResult; error: PPGError): PGList; cdecl; inline;
    function lookup_by_name_with_flags(hostname: Pgchar; flags: TGResolverNameLookupFlags; cancellable: PGCancellable; error: PPGError): PGList; cdecl; inline;
    procedure lookup_by_name_with_flags_async(hostname: Pgchar; flags: TGResolverNameLookupFlags; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function lookup_by_name_with_flags_finish(result_: PGAsyncResult; error: PPGError): PGList; cdecl; inline;
    function lookup_records(rrname: Pgchar; record_type: TGResolverRecordType; cancellable: PGCancellable; error: PPGError): PGList; cdecl; inline;
    procedure lookup_records_async(rrname: Pgchar; record_type: TGResolverRecordType; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function lookup_records_finish(result_: PGAsyncResult; error: PPGError): PGList; cdecl; inline;
    function lookup_service(service: Pgchar; protocol: Pgchar; domain: Pgchar; cancellable: PGCancellable; error: PPGError): PGList; cdecl; inline;
    procedure lookup_service_async(service: Pgchar; protocol: Pgchar; domain: Pgchar; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function lookup_service_finish(result_: PGAsyncResult; error: PPGError): PGList; cdecl; inline;
    procedure set_default; cdecl; inline;
  end;

  TGResolverPrivate = record
  end;




  { TGResolverClass }
  PPGResolverClass = ^PGResolverClass;
  PGResolverClass = ^TGResolverClass;
  TGResolverClass = object
    parent_class: TGObjectClass;
    reload: procedure(resolver: PGResolver); cdecl;
    lookup_by_name: function(resolver: PGResolver; hostname: Pgchar; cancellable: PGCancellable; error: PPGError): PGList; cdecl;
    lookup_by_name_async: procedure(resolver: PGResolver; hostname: Pgchar; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    lookup_by_name_finish: function(resolver: PGResolver; result_: PGAsyncResult; error: PPGError): PGList; cdecl;
    lookup_by_address: function(resolver: PGResolver; address: PGInetAddress; cancellable: PGCancellable; error: PPGError): Pgchar; cdecl;
    lookup_by_address_async: procedure(resolver: PGResolver; address: PGInetAddress; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    lookup_by_address_finish: function(resolver: PGResolver; result_: PGAsyncResult; error: PPGError): Pgchar; cdecl;
    lookup_service: function(resolver: PGResolver; rrname: Pgchar; cancellable: PGCancellable; error: PPGError): PGList; cdecl;
    lookup_service_async: procedure(resolver: PGResolver; rrname: Pgchar; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    lookup_service_finish: function(resolver: PGResolver; result_: PGAsyncResult; error: PPGError): PGList; cdecl;
    lookup_records: function(resolver: PGResolver; rrname: Pgchar; record_type: TGResolverRecordType; cancellable: PGCancellable; error: PPGError): PGList; cdecl;
    lookup_records_async: procedure(resolver: PGResolver; rrname: Pgchar; record_type: TGResolverRecordType; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    lookup_records_finish: function(resolver: PGResolver; result_: PGAsyncResult; error: PPGError): PGList; cdecl;
    lookup_by_name_with_flags_async: procedure(resolver: PGResolver; hostname: Pgchar; flags: TGResolverNameLookupFlags; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    lookup_by_name_with_flags_finish: function(resolver: PGResolver; result_: PGAsyncResult; error: PPGError): PGList; cdecl;
    lookup_by_name_with_flags: function(resolver: PGResolver; hostname: Pgchar; flags: TGResolverNameLookupFlags; cancellable: PGCancellable; error: PPGError): PGList; cdecl;
  end;


  { TGResolverError }
  PPGResolverError = ^PGResolverError;
  PGResolverError = ^TGResolverError;


  { TGResource }
  PPGResource = ^PGResource;
  PGResource = ^TGResource;


  { TGResourceLookupFlags }
  PPGResourceLookupFlags = ^PGResourceLookupFlags;
  PGResourceLookupFlags = ^TGResourceLookupFlags;
  TGResource = object
    function new_from_data(data: PGBytes; error: PPGError): PGResource; cdecl; inline; static;
    procedure _register; cdecl; inline;
    procedure _unregister; cdecl; inline;
    function enumerate_children(path: Pgchar; lookup_flags: TGResourceLookupFlags; error: PPGError): PPgchar; cdecl; inline;
    function get_info(path: Pgchar; lookup_flags: TGResourceLookupFlags; size: Pgsize; flags: Pguint32; error: PPGError): gboolean; cdecl; inline;
    function lookup_data(path: Pgchar; lookup_flags: TGResourceLookupFlags; error: PPGError): PGBytes; cdecl; inline;
    function open_stream(path: Pgchar; lookup_flags: TGResourceLookupFlags; error: PPGError): PGInputStream; cdecl; inline;
    function ref: PGResource; cdecl; inline;
    procedure unref; cdecl; inline;
    function load(filename: Pgchar; error: PPGError): PGResource; cdecl; inline; static;
  end;


  { TGResourceError }
  PPGResourceError = ^PGResourceError;
  PGResourceError = ^TGResourceError;


  { TGResourceFlags }
  PPGResourceFlags = ^PGResourceFlags;
  PGResourceFlags = ^TGResourceFlags;


  { TGSeekableIface }
  PPGSeekableIface = ^PGSeekableIface;
  PGSeekableIface = ^TGSeekableIface;
  TGSeekableIface = object
    g_iface: TGTypeInterface;
    tell: function(seekable: PGSeekable): gint64; cdecl;
    can_seek: function(seekable: PGSeekable): gboolean; cdecl;
    seek: function(seekable: PGSeekable; offset: gint64; type_: TGSeekType; cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
    can_truncate: function(seekable: PGSeekable): gboolean; cdecl;
    truncate_fn: function(seekable: PGSeekable; offset: gint64; cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
  end;


  { TGSettings }
  PPGSettings = ^PGSettings;
  PGSettings = ^TGSettings;


  { TGSettingsSchema }
  PPGSettingsSchema = ^PGSettingsSchema;
  PGSettingsSchema = ^TGSettingsSchema;


  { TGSettingsBackend }
  PPGSettingsBackend = ^PGSettingsBackend;
  PGSettingsBackend = ^TGSettingsBackend;


  { TGSettingsBindFlags }
  PPGSettingsBindFlags = ^PGSettingsBindFlags;
  PGSettingsBindFlags = ^TGSettingsBindFlags;


  { TGSettingsBindGetMapping }
  PPGSettingsBindGetMapping = ^PGSettingsBindGetMapping;
  PGSettingsBindGetMapping = ^TGSettingsBindGetMapping;
  TGSettingsBindGetMapping = function(value: PGValue; variant: PGVariant; user_data: gpointer): gboolean; cdecl;


  { TGSettingsBindSetMapping }
  PPGSettingsBindSetMapping = ^PGSettingsBindSetMapping;
  PGSettingsBindSetMapping = ^TGSettingsBindSetMapping;
  TGSettingsBindSetMapping = function(value: PGValue; expected_type: PGVariantType; user_data: gpointer): PGVariant; cdecl;


  { TGSettingsGetMapping }
  PPGSettingsGetMapping = ^PGSettingsGetMapping;
  PGSettingsGetMapping = ^TGSettingsGetMapping;
  TGSettingsGetMapping = function(value: PGVariant; result_: Pgpointer; user_data: gpointer): gboolean; cdecl;


  { TGSettingsPrivate }
  PPGSettingsPrivate = ^PGSettingsPrivate;
  PGSettingsPrivate = ^TGSettingsPrivate;
  TGSettings = object(TGObject)
    priv: PGSettingsPrivate;
    function new(schema_id: Pgchar): PGSettings; cdecl; inline; static;
    function new_full(schema: PGSettingsSchema; backend: PGSettingsBackend; path: Pgchar): PGSettings; cdecl; inline; static;
    function new_with_backend(schema_id: Pgchar; backend: PGSettingsBackend): PGSettings; cdecl; inline; static;
    function new_with_backend_and_path(schema_id: Pgchar; backend: PGSettingsBackend; path: Pgchar): PGSettings; cdecl; inline; static;
    function new_with_path(schema_id: Pgchar; path: Pgchar): PGSettings; cdecl; inline; static;
    procedure sync; cdecl; inline; static;
    procedure unbind(object_: PGObject; property_: Pgchar); cdecl; inline; static;
    procedure apply; cdecl; inline;
    procedure bind(key: Pgchar; object_: PGObject; property_: Pgchar; flags: TGSettingsBindFlags); cdecl; inline;
    procedure bind_with_mapping(key: Pgchar; object_: PGObject; property_: Pgchar; flags: TGSettingsBindFlags; get_mapping: TGSettingsBindGetMapping; set_mapping: TGSettingsBindSetMapping; user_data: gpointer; destroy_: TGDestroyNotify); cdecl; inline;
    procedure bind_writable(key: Pgchar; object_: PGObject; property_: Pgchar; inverted: gboolean); cdecl; inline;
    function create_action(key: Pgchar): PGAction; cdecl; inline;
    procedure delay; cdecl; inline;
    //procedure get(key: Pgchar; format: Pgchar; args: array of const); cdecl; inline;
    function get_boolean(key: Pgchar): gboolean; cdecl; inline;
    function get_child(name: Pgchar): PGSettings; cdecl; inline;
    function get_default_value(key: Pgchar): PGVariant; cdecl; inline;
    function get_double(key: Pgchar): gdouble; cdecl; inline;
    function get_enum(key: Pgchar): gint; cdecl; inline;
    function get_flags(key: Pgchar): guint; cdecl; inline;
    function get_has_unapplied: gboolean; cdecl; inline;
    function get_int(key: Pgchar): gint; cdecl; inline;
    function get_int64(key: Pgchar): gint64; cdecl; inline;
    function get_mapped(key: Pgchar; mapping: TGSettingsGetMapping; user_data: gpointer): gpointer; cdecl; inline;
    function get_string(key: Pgchar): Pgchar; cdecl; inline;
    function get_strv(key: Pgchar): PPgchar; cdecl; inline;
    function get_uint(key: Pgchar): guint; cdecl; inline;
    function get_uint64(key: Pgchar): guint64; cdecl; inline;
    function get_user_value(key: Pgchar): PGVariant; cdecl; inline;
    function get_value(key: Pgchar): PGVariant; cdecl; inline;
    function is_writable(name: Pgchar): gboolean; cdecl; inline;
    function list_children: PPgchar; cdecl; inline;
    procedure reset(key: Pgchar); cdecl; inline;
    procedure revert; cdecl; inline;
    //function set_(key: Pgchar; format: Pgchar; args: array of const): gboolean; cdecl; inline;
    function set_boolean(key: Pgchar; value: gboolean): gboolean; cdecl; inline;
    function set_double(key: Pgchar; value: gdouble): gboolean; cdecl; inline;
    function set_enum(key: Pgchar; value: gint): gboolean; cdecl; inline;
    function set_flags(key: Pgchar; value: guint): gboolean; cdecl; inline;
    function set_int(key: Pgchar; value: gint): gboolean; cdecl; inline;
    function set_int64(key: Pgchar; value: gint64): gboolean; cdecl; inline;
    function set_string(key: Pgchar; value: Pgchar): gboolean; cdecl; inline;
    function set_strv(key: Pgchar; value: PPgchar): gboolean; cdecl; inline;
    function set_uint(key: Pgchar; value: guint): gboolean; cdecl; inline;
    function set_uint64(key: Pgchar; value: guint64): gboolean; cdecl; inline;
    function set_value(key: Pgchar; value: PGVariant): gboolean; cdecl; inline;
    //property backend: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_backend  { property is writeable but setter not declared } ;
    //property delay_apply: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_delay_apply ;
    property has_unapplied: gboolean read get_has_unapplied ;
    //property path: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_path  { property is writeable but setter not declared } ;
    //property schema_id: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_schema_id  { property is writeable but setter not declared } ;
    //property settings_schema: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_settings_schema  { property is writeable but setter not declared } ;
  end;


  { TGSettingsSchemaKey }
  PPGSettingsSchemaKey = ^PGSettingsSchemaKey;
  PGSettingsSchemaKey = ^TGSettingsSchemaKey;
  TGSettingsSchema = object
    function get_id: Pgchar; cdecl; inline;
    function get_key(name: Pgchar): PGSettingsSchemaKey; cdecl; inline;
    function get_path: Pgchar; cdecl; inline;
    function has_key(name: Pgchar): gboolean; cdecl; inline;
    function list_children: PPgchar; cdecl; inline;
    function list_keys: PPgchar; cdecl; inline;
    function ref: PGSettingsSchema; cdecl; inline;
    procedure unref; cdecl; inline;
  end;


  { TGSettingsBackendPrivate }
  PPGSettingsBackendPrivate = ^PGSettingsBackendPrivate;
  PGSettingsBackendPrivate = ^TGSettingsBackendPrivate;
  TGSettingsBackend = object(TGObject)
    priv: PGSettingsBackendPrivate;
    procedure flatten_tree(tree: PGTree; path: PPgchar; keys: PPPgchar; values: PPPGVariant); cdecl; inline; static;
    function get_default: PGSettingsBackend; cdecl; inline; static;
    procedure changed(key: Pgchar; origin_tag: gpointer); cdecl; inline;
    procedure changed_tree(tree: PGTree; origin_tag: gpointer); cdecl; inline;
    procedure keys_changed(path: Pgchar; items: PPgchar; origin_tag: gpointer); cdecl; inline;
    procedure path_changed(path: Pgchar; origin_tag: gpointer); cdecl; inline;
    procedure path_writable_changed(path: Pgchar); cdecl; inline;
    procedure writable_changed(key: Pgchar); cdecl; inline;
  end;

  TGSettingsPrivate = record
  end;



  TGSettingsBackendPrivate = record
  end;




  { TGSettingsBackendClass }
  PPGSettingsBackendClass = ^PGSettingsBackendClass;
  PGSettingsBackendClass = ^TGSettingsBackendClass;
  TGSettingsBackendClass = object
    parent_class: TGObjectClass;
    read: function(backend: PGSettingsBackend; key: Pgchar; expected_type: PGVariantType; default_value: gboolean): PGVariant; cdecl;
    get_writable: function(backend: PGSettingsBackend; key: Pgchar): gboolean; cdecl;
    write: function(backend: PGSettingsBackend; key: Pgchar; value: PGVariant; origin_tag: gpointer): gboolean; cdecl;
    write_tree: function(backend: PGSettingsBackend; tree: PGTree; origin_tag: gpointer): gboolean; cdecl;
    reset: procedure(backend: PGSettingsBackend; key: Pgchar; origin_tag: gpointer); cdecl;
    subscribe: procedure(backend: PGSettingsBackend; name: Pgchar); cdecl;
    unsubscribe: procedure(backend: PGSettingsBackend; name: Pgchar); cdecl;
    sync: procedure(backend: PGSettingsBackend); cdecl;
    get_permission: function(backend: PGSettingsBackend; path: Pgchar): PGPermission; cdecl;
    read_user_value: function(backend: PGSettingsBackend; key: Pgchar; expected_type: PGVariantType): PGVariant; cdecl;
    padding: array [0..22] of gpointer;
  end;


  { TGSettingsClass }
  PPGSettingsClass = ^PGSettingsClass;
  PGSettingsClass = ^TGSettingsClass;
  TGSettingsClass = object
    parent_class: TGObjectClass;
    writable_changed: procedure(settings: PGSettings; key: Pgchar); cdecl;
    changed: procedure(settings: PGSettings; key: Pgchar); cdecl;
    writable_change_event: function(settings: PGSettings; key: TGQuark): gboolean; cdecl;
    change_event: function(settings: PGSettings; keys: PGQuark; n_keys: gint): gboolean; cdecl;
    padding: array [0..19] of gpointer;
  end;
  TGSettingsSchemaKey = object
    function get_default_value: PGVariant; cdecl; inline;
    function get_description: Pgchar; cdecl; inline;
    function get_name: Pgchar; cdecl; inline;
    function get_range: PGVariant; cdecl; inline;
    function get_summary: Pgchar; cdecl; inline;
    function get_value_type: PGVariantType; cdecl; inline;
    function range_check(value: PGVariant): gboolean; cdecl; inline;
    function ref: PGSettingsSchemaKey; cdecl; inline;
    procedure unref; cdecl; inline;
  end;


  { TGSettingsSchemaSource }
  PPGSettingsSchemaSource = ^PGSettingsSchemaSource;
  PGSettingsSchemaSource = ^TGSettingsSchemaSource;
  TGSettingsSchemaSource = object
    function new_from_directory(directory: Pgchar; parent: PGSettingsSchemaSource; trusted: gboolean; error: PPGError): PGSettingsSchemaSource; cdecl; inline; static;
    procedure list_schemas(recursive: gboolean; non_relocatable: PPPgchar; relocatable: PPPgchar); cdecl; inline;
    function lookup(schema_id: Pgchar; recursive: gboolean): PGSettingsSchema; cdecl; inline;
    function ref: PGSettingsSchemaSource; cdecl; inline;
    procedure unref; cdecl; inline;
    function get_default: PGSettingsSchemaSource; cdecl; inline; static;
  end;


  { TGSimpleActionGroup }
  PPGSimpleActionGroup = ^PGSimpleActionGroup;
  PGSimpleActionGroup = ^TGSimpleActionGroup;


  { TGSimpleActionGroupPrivate }
  PPGSimpleActionGroupPrivate = ^PGSimpleActionGroupPrivate;
  PGSimpleActionGroupPrivate = ^TGSimpleActionGroupPrivate;
  TGSimpleActionGroup = object(TGObject)
    priv: PGSimpleActionGroupPrivate;
    function new: PGSimpleActionGroup; cdecl; inline; static;
  end;

  TGSimpleActionGroupPrivate = record
  end;




  { TGSimpleActionGroupClass }
  PPGSimpleActionGroupClass = ^PGSimpleActionGroupClass;
  PGSimpleActionGroupClass = ^TGSimpleActionGroupClass;
  TGSimpleActionGroupClass = object
    parent_class: TGObjectClass;
    padding: array [0..11] of gpointer;
  end;


  { TGSimpleAsyncResult }
  PPGSimpleAsyncResult = ^PGSimpleAsyncResult;
  PGSimpleAsyncResult = ^TGSimpleAsyncResult;
  TGSimpleAsyncResult = object(TGObject)
  end;
  TGSimpleAsyncThreadFunc = procedure(res: PGSimpleAsyncResult; object_: PGObject; cancellable: PGCancellable); cdecl;


  { TGSimpleAsyncResultClass }
  PPGSimpleAsyncResultClass = ^PGSimpleAsyncResultClass;
  PGSimpleAsyncResultClass = ^TGSimpleAsyncResultClass;
  TGSimpleAsyncResultClass = object
  end;


  { TGSimpleIOStream }
  PPGSimpleIOStream = ^PGSimpleIOStream;
  PGSimpleIOStream = ^TGSimpleIOStream;
  TGSimpleIOStream = object(TGIOStream)
    function new(input_stream: PGInputStream; output_stream: PGOutputStream): PGSimpleIOStream; cdecl; inline; static;
    //property input_stream1: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_input_stream  { property is writeable but setter not declared } ;
    //property output_stream1: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_output_stream  { property is writeable but setter not declared } ;
  end;


  { TGSimplePermission }
  PPGSimplePermission = ^PGSimplePermission;
  PGSimplePermission = ^TGSimplePermission;
  TGSimplePermission = object(TGPermission)
    function new(allowed: gboolean): PGSimplePermission; cdecl; inline; static;
  end;


  { TGSimpleProxyResolver }
  PPGSimpleProxyResolver = ^PGSimpleProxyResolver;
  PGSimpleProxyResolver = ^TGSimpleProxyResolver;


  { TGSimpleProxyResolverPrivate }
  PPGSimpleProxyResolverPrivate = ^PGSimpleProxyResolverPrivate;
  PGSimpleProxyResolverPrivate = ^TGSimpleProxyResolverPrivate;
  TGSimpleProxyResolver = object(TGObject)
    priv: PGSimpleProxyResolverPrivate;
    function new(default_proxy: Pgchar; ignore_hosts: PPgchar): PGProxyResolver; cdecl; inline; static;
    procedure set_default_proxy(default_proxy: Pgchar); cdecl; inline;
    procedure set_ignore_hosts(ignore_hosts: PPgchar); cdecl; inline;
    procedure set_uri_proxy(uri_scheme: Pgchar; proxy: Pgchar); cdecl; inline;
    //property default_proxy: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_default_proxy  { property is writeable but setter not declared } ;
    //property ignore_hosts: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_ignore_hosts  { property is writeable but setter not declared } ;
  end;

  TGSimpleProxyResolverPrivate = record
  end;




  { TGSimpleProxyResolverClass }
  PPGSimpleProxyResolverClass = ^PGSimpleProxyResolverClass;
  PGSimpleProxyResolverClass = ^TGSimpleProxyResolverClass;
  TGSimpleProxyResolverClass = object
    parent_class: TGObjectClass;
    _g_reserved1: procedure; cdecl;
    _g_reserved2: procedure; cdecl;
    _g_reserved3: procedure; cdecl;
    _g_reserved4: procedure; cdecl;
    _g_reserved5: procedure; cdecl;
  end;


  { TGSocket }
  PPGSocket = ^PGSocket;
  PGSocket = ^TGSocket;


  { TGSocketType }
  PPGSocketType = ^PGSocketType;
  PGSocketType = ^TGSocketType;


  { TGSocketProtocol }
  PPGSocketProtocol = ^PGSocketProtocol;
  PGSocketProtocol = ^TGSocketProtocol;


  { TGSocketConnection }
  PPGSocketConnection = ^PGSocketConnection;
  PGSocketConnection = ^TGSocketConnection;


  { TGSocketPrivate }
  PPGSocketPrivate = ^PGSocketPrivate;
  PGSocketPrivate = ^TGSocketPrivate;
  TGSocket = object(TGObject)
    priv: PGSocketPrivate;
    function new(family: TGSocketFamily; type_: TGSocketType; protocol: TGSocketProtocol; error: PPGError): PGSocket; cdecl; inline; static;
    function new_from_fd(fd: gint; error: PPGError): PGSocket; cdecl; inline; static;
    function accept(cancellable: PGCancellable; error: PPGError): PGSocket; cdecl; inline;
    function bind(address: PGSocketAddress; allow_reuse: gboolean; error: PPGError): gboolean; cdecl; inline;
    function check_connect_result(error: PPGError): gboolean; cdecl; inline;
    function close(error: PPGError): gboolean; cdecl; inline;
    function condition_check(condition: TGIOCondition): TGIOCondition; cdecl; inline;
    function condition_timed_wait(condition: TGIOCondition; timeout_us: gint64; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; inline;
    function condition_wait(condition: TGIOCondition; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; inline;
    function connect(address: PGSocketAddress; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; inline;
    function connection_factory_create_connection: PGSocketConnection; cdecl; inline;
    function create_source(condition: TGIOCondition; cancellable: PGCancellable): PGSource; cdecl; inline;
    function get_available_bytes: gssize; cdecl; inline;
    function get_blocking: gboolean; cdecl; inline;
    function get_broadcast: gboolean; cdecl; inline;
    function get_credentials(error: PPGError): PGCredentials; cdecl; inline;
    function get_family: TGSocketFamily; cdecl; inline;
    function get_fd: gint; cdecl; inline;
    function get_keepalive: gboolean; cdecl; inline;
    function get_listen_backlog: gint; cdecl; inline;
    function get_local_address(error: PPGError): PGSocketAddress; cdecl; inline;
    function get_multicast_loopback: gboolean; cdecl; inline;
    function get_multicast_ttl: guint; cdecl; inline;
    function get_option(level: gint; optname: gint; value: Pgint; error: PPGError): gboolean; cdecl; inline;
    function get_protocol: TGSocketProtocol; cdecl; inline;
    function get_remote_address(error: PPGError): PGSocketAddress; cdecl; inline;
    function get_socket_type: TGSocketType; cdecl; inline;
    function get_timeout: guint; cdecl; inline;
    function get_ttl: guint; cdecl; inline;
    function is_closed: gboolean; cdecl; inline;
    function is_connected: gboolean; cdecl; inline;
    function join_multicast_group(group: PGInetAddress; source_specific: gboolean; iface: Pgchar; error: PPGError): gboolean; cdecl; inline;
    function join_multicast_group_ssm(group: PGInetAddress; source_specific: PGInetAddress; iface: Pgchar; error: PPGError): gboolean; cdecl; inline;
    function leave_multicast_group(group: PGInetAddress; source_specific: gboolean; iface: Pgchar; error: PPGError): gboolean; cdecl; inline;
    function leave_multicast_group_ssm(group: PGInetAddress; source_specific: PGInetAddress; iface: Pgchar; error: PPGError): gboolean; cdecl; inline;
    function listen(error: PPGError): gboolean; cdecl; inline;
    function receive(buffer: Pgchar; size: Pgsize; cancellable: PGCancellable; error: PPGError): gssize; cdecl; inline;
    function receive_from(address: PPGSocketAddress; buffer: Pgchar; size: Pgsize; cancellable: PGCancellable; error: PPGError): gssize; cdecl; inline;
    function receive_message(address: PPGSocketAddress; vectors: PGInputVector; num_vectors: gint; messages: PPPGSocketControlMessage; num_messages: Pgint; flags: Pgint; cancellable: PGCancellable; error: PPGError): gssize; cdecl; inline;
    function receive_messages(messages: PGInputMessage; num_messages: guint; flags: gint; cancellable: PGCancellable; error: PPGError): gint; cdecl; inline;
    function receive_with_blocking(buffer: Pgchar; size: Pgsize; blocking: gboolean; cancellable: PGCancellable; error: PPGError): gssize; cdecl; inline;
    function send(buffer: Pgchar; size: gsize; cancellable: PGCancellable; error: PPGError): gssize; cdecl; inline;
    function send_message(address: PGSocketAddress; vectors: PGOutputVector; num_vectors: gint; messages: PPGSocketControlMessage; num_messages: gint; flags: gint; cancellable: PGCancellable; error: PPGError): gssize; cdecl; inline;
    function send_message_with_timeout(address: PGSocketAddress; vectors: PGOutputVector; num_vectors: gint; messages: PPGSocketControlMessage; num_messages: gint; flags: gint; timeout_us: gint64; bytes_written: Pgsize; cancellable: PGCancellable; error: PPGError): TGPollableReturn; cdecl; inline;
    function send_messages(messages: PGOutputMessage; num_messages: guint; flags: gint; cancellable: PGCancellable; error: PPGError): gint; cdecl; inline;
    function send_to(address: PGSocketAddress; buffer: Pgchar; size: gsize; cancellable: PGCancellable; error: PPGError): gssize; cdecl; inline;
    function send_with_blocking(buffer: Pgchar; size: gsize; blocking: gboolean; cancellable: PGCancellable; error: PPGError): gssize; cdecl; inline;
    procedure set_blocking(blocking: gboolean); cdecl; inline;
    procedure set_broadcast(broadcast: gboolean); cdecl; inline;
    procedure set_keepalive(keepalive: gboolean); cdecl; inline;
    procedure set_listen_backlog(backlog: gint); cdecl; inline;
    procedure set_multicast_loopback(loopback: gboolean); cdecl; inline;
    procedure set_multicast_ttl(ttl: guint); cdecl; inline;
    function set_option(level: gint; optname: gint; value: gint; error: PPGError): gboolean; cdecl; inline;
    procedure set_timeout(timeout: guint); cdecl; inline;
    procedure set_ttl(ttl: guint); cdecl; inline;
    function shutdown(shutdown_read: gboolean; shutdown_write: gboolean; error: PPGError): gboolean; cdecl; inline;
    function speaks_ipv4: gboolean; cdecl; inline;
    property blocking: gboolean read get_blocking write set_blocking;
    property broadcast: gboolean read get_broadcast write set_broadcast;
    property family: TGSocketFamily read get_family  { property is writeable but setter not declared } ;
    property fd: gint read get_fd  { property is writeable but setter not declared } ;
    property keepalive: gboolean read get_keepalive write set_keepalive;
    property listen_backlog: gint read get_listen_backlog write set_listen_backlog;
    //property local_address: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_local_address ;
    property multicast_loopback: gboolean read get_multicast_loopback write set_multicast_loopback;
    property multicast_ttl: guint read get_multicast_ttl write set_multicast_ttl;
    property protocol: TGSocketProtocol read get_protocol  { property is writeable but setter not declared } ;
    //property remote_address: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_remote_address ;
    property timeout: guint read get_timeout write set_timeout;
    property ttl: guint read get_ttl write set_ttl;
    //property type_: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_type  { property is writeable but setter not declared } ;
  end;


  { TGSocketConnectionPrivate }
  PPGSocketConnectionPrivate = ^PGSocketConnectionPrivate;
  PGSocketConnectionPrivate = ^TGSocketConnectionPrivate;
  TGSocketConnection = object(TGIOStream)
    priv1: PGSocketConnectionPrivate;
    function factory_lookup_type(family: TGSocketFamily; type_: TGSocketType; protocol_id: gint): TGType; cdecl; inline; static;
    procedure factory_register_type(g_type: TGType; family: TGSocketFamily; type_: TGSocketType; protocol: gint); cdecl; inline; static;
    function connect(address: PGSocketAddress; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; inline;
    procedure connect_async(address: PGSocketAddress; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function connect_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl; inline;
    function get_local_address(error: PPGError): PGSocketAddress; cdecl; inline;
    function get_remote_address(error: PPGError): PGSocketAddress; cdecl; inline;
    function get_socket: PGSocket; cdecl; inline;
    function is_connected: gboolean; cdecl; inline;
    property socket: PGSocket read get_socket  { property is writeable but setter not declared } ;
  end;

  TGSocketPrivate = record
  end;




  { TGSocketClass }
  PPGSocketClass = ^PGSocketClass;
  PGSocketClass = ^TGSocketClass;
  TGSocketClass = object
    parent_class: TGObjectClass;
    _g_reserved1: procedure; cdecl;
    _g_reserved2: procedure; cdecl;
    _g_reserved3: procedure; cdecl;
    _g_reserved4: procedure; cdecl;
    _g_reserved5: procedure; cdecl;
    _g_reserved6: procedure; cdecl;
    _g_reserved7: procedure; cdecl;
    _g_reserved8: procedure; cdecl;
    _g_reserved9: procedure; cdecl;
    _g_reserved10: procedure; cdecl;
  end;


  { TGSocketClient }
  PPGSocketClient = ^PGSocketClient;
  PGSocketClient = ^TGSocketClient;


  { TGSocketClientPrivate }
  PPGSocketClientPrivate = ^PGSocketClientPrivate;
  PGSocketClientPrivate = ^TGSocketClientPrivate;
  TGSocketClient = object(TGObject)
    priv: PGSocketClientPrivate;
    function new: PGSocketClient; cdecl; inline; static;
    procedure add_application_proxy(protocol: Pgchar); cdecl; inline;
    function connect(connectable: PGSocketConnectable; cancellable: PGCancellable; error: PPGError): PGSocketConnection; cdecl; inline;
    procedure connect_async(connectable: PGSocketConnectable; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function connect_finish(result_: PGAsyncResult; error: PPGError): PGSocketConnection; cdecl; inline;
    function connect_to_host(host_and_port: Pgchar; default_port: guint16; cancellable: PGCancellable; error: PPGError): PGSocketConnection; cdecl; inline;
    procedure connect_to_host_async(host_and_port: Pgchar; default_port: guint16; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function connect_to_host_finish(result_: PGAsyncResult; error: PPGError): PGSocketConnection; cdecl; inline;
    function connect_to_service(domain: Pgchar; service: Pgchar; cancellable: PGCancellable; error: PPGError): PGSocketConnection; cdecl; inline;
    procedure connect_to_service_async(domain: Pgchar; service: Pgchar; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function connect_to_service_finish(result_: PGAsyncResult; error: PPGError): PGSocketConnection; cdecl; inline;
    function connect_to_uri(uri: Pgchar; default_port: guint16; cancellable: PGCancellable; error: PPGError): PGSocketConnection; cdecl; inline;
    procedure connect_to_uri_async(uri: Pgchar; default_port: guint16; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function connect_to_uri_finish(result_: PGAsyncResult; error: PPGError): PGSocketConnection; cdecl; inline;
    function get_enable_proxy: gboolean; cdecl; inline;
    function get_family: TGSocketFamily; cdecl; inline;
    function get_local_address: PGSocketAddress; cdecl; inline;
    function get_protocol: TGSocketProtocol; cdecl; inline;
    function get_proxy_resolver: PGProxyResolver; cdecl; inline;
    function get_socket_type: TGSocketType; cdecl; inline;
    function get_timeout: guint; cdecl; inline;
    function get_tls: gboolean; cdecl; inline;
    function get_tls_validation_flags: TGTlsCertificateFlags; cdecl; inline; deprecated 'Do not attempt to ignore validation errors.';
    procedure set_enable_proxy(enable: gboolean); cdecl; inline;
    procedure set_family(family: TGSocketFamily); cdecl; inline;
    procedure set_local_address(address: PGSocketAddress); cdecl; inline;
    procedure set_protocol(protocol: TGSocketProtocol); cdecl; inline;
    procedure set_proxy_resolver(proxy_resolver: PGProxyResolver); cdecl; inline;
    procedure set_socket_type(type_: TGSocketType); cdecl; inline;
    procedure set_timeout(timeout: guint); cdecl; inline;
    procedure set_tls(tls: gboolean); cdecl; inline;
    procedure set_tls_validation_flags(flags: TGTlsCertificateFlags); cdecl; inline; deprecated 'Do not attempt to ignore validation errors.';
    property enable_proxy: gboolean read get_enable_proxy write set_enable_proxy;
    property family: TGSocketFamily read get_family write set_family;
    property local_address: PGSocketAddress read get_local_address write set_local_address;
    property protocol: TGSocketProtocol read get_protocol write set_protocol;
    property proxy_resolver: PGProxyResolver read get_proxy_resolver write set_proxy_resolver;
    property timeout: guint read get_timeout write set_timeout;
    property tls: gboolean read get_tls write set_tls;
    //property type_: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_type  { property is writeable but setter not declared } ;
  end;


  { TGSocketClientEvent }
  PPGSocketClientEvent = ^PGSocketClientEvent;
  PGSocketClientEvent = ^TGSocketClientEvent;

  TGSocketClientPrivate = record
  end;




  { TGSocketClientClass }
  PPGSocketClientClass = ^PGSocketClientClass;
  PGSocketClientClass = ^TGSocketClientClass;
  TGSocketClientClass = object
    parent_class: TGObjectClass;
    event: procedure(client: PGSocketClient; event: TGSocketClientEvent; connectable: PGSocketConnectable; connection: PGIOStream); cdecl;
    _g_reserved1: procedure; cdecl;
    _g_reserved2: procedure; cdecl;
    _g_reserved3: procedure; cdecl;
    _g_reserved4: procedure; cdecl;
  end;


  { TGSocketConnectableIface }
  PPGSocketConnectableIface = ^PGSocketConnectableIface;
  PGSocketConnectableIface = ^TGSocketConnectableIface;
  TGSocketConnectableIface = object
    g_iface: TGTypeInterface;
    enumerate: function(connectable: PGSocketConnectable): PGSocketAddressEnumerator; cdecl;
    proxy_enumerate: function(connectable: PGSocketConnectable): PGSocketAddressEnumerator; cdecl;
    to_string: function(connectable: PGSocketConnectable): Pgchar; cdecl;
  end;

  TGSocketConnectionPrivate = record
  end;




  { TGSocketConnectionClass }
  PPGSocketConnectionClass = ^PGSocketConnectionClass;
  PGSocketConnectionClass = ^TGSocketConnectionClass;
  TGSocketConnectionClass = object
    parent_class: TGIOStreamClass;
    _g_reserved1: procedure; cdecl;
    _g_reserved2: procedure; cdecl;
    _g_reserved3: procedure; cdecl;
    _g_reserved4: procedure; cdecl;
    _g_reserved5: procedure; cdecl;
    _g_reserved6: procedure; cdecl;
  end;

  TGSocketControlMessagePrivate = record
  end;




  { TGSocketControlMessageClass }
  PPGSocketControlMessageClass = ^PGSocketControlMessageClass;
  PGSocketControlMessageClass = ^TGSocketControlMessageClass;
  TGSocketControlMessageClass = object
    parent_class: TGObjectClass;
    get_size: function(message: PGSocketControlMessage): gsize; cdecl;
    get_level: function(message: PGSocketControlMessage): gint; cdecl;
    get_type: function(message: PGSocketControlMessage): gint; cdecl;
    serialize: procedure(message: PGSocketControlMessage; data: gpointer); cdecl;
    deserialize: function(level: gint; type_: gint; size: gsize; data: gpointer): PGSocketControlMessage; cdecl;
    _g_reserved1: procedure; cdecl;
    _g_reserved2: procedure; cdecl;
    _g_reserved3: procedure; cdecl;
    _g_reserved4: procedure; cdecl;
    _g_reserved5: procedure; cdecl;
  end;


  { TGSocketListener }
  PPGSocketListener = ^PGSocketListener;
  PGSocketListener = ^TGSocketListener;


  { TGSocketListenerPrivate }
  PPGSocketListenerPrivate = ^PGSocketListenerPrivate;
  PGSocketListenerPrivate = ^TGSocketListenerPrivate;
  TGSocketListener = object(TGObject)
    priv: PGSocketListenerPrivate;
    function new: PGSocketListener; cdecl; inline; static;
    function accept(source_object: PPGObject; cancellable: PGCancellable; error: PPGError): PGSocketConnection; cdecl; inline;
    procedure accept_async(cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function accept_finish(result_: PGAsyncResult; source_object: PPGObject; error: PPGError): PGSocketConnection; cdecl; inline;
    function accept_socket(source_object: PPGObject; cancellable: PGCancellable; error: PPGError): PGSocket; cdecl; inline;
    procedure accept_socket_async(cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function accept_socket_finish(result_: PGAsyncResult; source_object: PPGObject; error: PPGError): PGSocket; cdecl; inline;
    function add_address(address: PGSocketAddress; type_: TGSocketType; protocol: TGSocketProtocol; source_object: PGObject; effective_address: PPGSocketAddress; error: PPGError): gboolean; cdecl; inline;
    function add_any_inet_port(source_object: PGObject; error: PPGError): guint16; cdecl; inline;
    function add_inet_port(port: guint16; source_object: PGObject; error: PPGError): gboolean; cdecl; inline;
    function add_socket(socket: PGSocket; source_object: PGObject; error: PPGError): gboolean; cdecl; inline;
    procedure close; cdecl; inline;
    procedure set_backlog(listen_backlog: gint); cdecl; inline;
    //property listen_backlog: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_listen_backlog  { property is writeable but setter not declared } ;
  end;


  { TGSocketListenerEvent }
  PPGSocketListenerEvent = ^PGSocketListenerEvent;
  PGSocketListenerEvent = ^TGSocketListenerEvent;

  TGSocketListenerPrivate = record
  end;




  { TGSocketListenerClass }
  PPGSocketListenerClass = ^PGSocketListenerClass;
  PGSocketListenerClass = ^TGSocketListenerClass;
  TGSocketListenerClass = object
    parent_class: TGObjectClass;
    changed: procedure(listener: PGSocketListener); cdecl;
    event: procedure(listener: PGSocketListener; event: TGSocketListenerEvent; socket: PGSocket); cdecl;
    _g_reserved2: procedure; cdecl;
    _g_reserved3: procedure; cdecl;
    _g_reserved4: procedure; cdecl;
    _g_reserved5: procedure; cdecl;
    _g_reserved6: procedure; cdecl;
  end;


  { TGSocketMsgFlags }
  PPGSocketMsgFlags = ^PGSocketMsgFlags;
  PGSocketMsgFlags = ^TGSocketMsgFlags;


  { TGSocketService }
  PPGSocketService = ^PGSocketService;
  PGSocketService = ^TGSocketService;


  { TGSocketServicePrivate }
  PPGSocketServicePrivate = ^PGSocketServicePrivate;
  PGSocketServicePrivate = ^TGSocketServicePrivate;
  TGSocketService = object(TGSocketListener)
    priv1: PGSocketServicePrivate;
    function new: PGSocketService; cdecl; inline; static;
    function is_active: gboolean; cdecl; inline;
    procedure start; cdecl; inline;
    procedure stop; cdecl; inline;
    //property active: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_active  { property is writeable but setter not declared } ;
  end;

  TGSocketServicePrivate = record
  end;




  { TGSocketServiceClass }
  PPGSocketServiceClass = ^PGSocketServiceClass;
  PGSocketServiceClass = ^TGSocketServiceClass;
  TGSocketServiceClass = object
    parent_class: TGSocketListenerClass;
    incoming: function(service: PGSocketService; connection: PGSocketConnection; source_object: PGObject): gboolean; cdecl;
    _g_reserved1: procedure; cdecl;
    _g_reserved2: procedure; cdecl;
    _g_reserved3: procedure; cdecl;
    _g_reserved4: procedure; cdecl;
    _g_reserved5: procedure; cdecl;
    _g_reserved6: procedure; cdecl;
  end;
  TGSocketSourceFunc = function(socket: PGSocket; condition: TGIOCondition; user_data: gpointer): gboolean; cdecl;


  { TGSrvTarget }
  PPGSrvTarget = ^PGSrvTarget;
  PGSrvTarget = ^TGSrvTarget;
  TGSrvTarget = object
    function new(hostname: Pgchar; port: guint16; priority: guint16; weight: guint16): PGSrvTarget; cdecl; inline; static;
    function copy: PGSrvTarget; cdecl; inline;
    procedure free; cdecl; inline;
    function get_hostname: Pgchar; cdecl; inline;
    function get_port: guint16; cdecl; inline;
    function get_priority: guint16; cdecl; inline;
    function get_weight: guint16; cdecl; inline;
    function list_sort(targets: PGList): PGList; cdecl; inline; static;
  end;


  { TGStaticResource }
  PPGStaticResource = ^PGStaticResource;
  PGStaticResource = ^TGStaticResource;
  TGStaticResource = object
    data: Pguint8;
    data_len: gsize;
    resource: PGResource;
    next: PGStaticResource;
    padding: gpointer;
    procedure fini; cdecl; inline;
    function get_resource: PGResource; cdecl; inline;
    procedure init; cdecl; inline;
  end;


  { TGSubprocess }
  PPGSubprocess = ^PGSubprocess;
  PGSubprocess = ^TGSubprocess;


  { TGSubprocessFlags }
  PPGSubprocessFlags = ^PGSubprocessFlags;
  PGSubprocessFlags = ^TGSubprocessFlags;
  TGSubprocess = object(TGObject)
    //function new(flags: TGSubprocessFlags; error: PPGError; argv0: Pgchar; args: array of const): PGSubprocess; cdecl; inline; static;
    function newv(argv: PPgchar; flags: TGSubprocessFlags; error: PPGError): PGSubprocess; cdecl; inline; static;
    function communicate(stdin_buf: PGBytes; cancellable: PGCancellable; stdout_buf: PPGBytes; stderr_buf: PPGBytes; error: PPGError): gboolean; cdecl; inline;
    procedure communicate_async(stdin_buf: PGBytes; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function communicate_finish(result_: PGAsyncResult; stdout_buf: PPGBytes; stderr_buf: PPGBytes; error: PPGError): gboolean; cdecl; inline;
    function communicate_utf8(stdin_buf: Pgchar; cancellable: PGCancellable; stdout_buf: PPgchar; stderr_buf: PPgchar; error: PPGError): gboolean; cdecl; inline;
    procedure communicate_utf8_async(stdin_buf: Pgchar; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function communicate_utf8_finish(result_: PGAsyncResult; stdout_buf: PPgchar; stderr_buf: PPgchar; error: PPGError): gboolean; cdecl; inline;
    procedure force_exit; cdecl; inline;
    function get_exit_status: gint; cdecl; inline;
    function get_identifier: Pgchar; cdecl; inline;
    function get_if_exited: gboolean; cdecl; inline;
    function get_if_signaled: gboolean; cdecl; inline;
    function get_status: gint; cdecl; inline;
    function get_stderr_pipe: PGInputStream; cdecl; inline;
    function get_stdin_pipe: PGOutputStream; cdecl; inline;
    function get_stdout_pipe: PGInputStream; cdecl; inline;
    function get_successful: gboolean; cdecl; inline;
    function get_term_sig: gint; cdecl; inline;
    procedure send_signal(signal_num: gint); cdecl; inline;
    function wait(cancellable: PGCancellable; error: PPGError): gboolean; cdecl; inline;
    procedure wait_async(cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function wait_check(cancellable: PGCancellable; error: PPGError): gboolean; cdecl; inline;
    procedure wait_check_async(cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function wait_check_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl; inline;
    function wait_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl; inline;
    //property argv: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_argv  { property is writeable but setter not declared } ;
    //property flags: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_flags  { property is writeable but setter not declared } ;
  end;


  { TGSubprocessLauncher }
  PPGSubprocessLauncher = ^PGSubprocessLauncher;
  PGSubprocessLauncher = ^TGSubprocessLauncher;
  TGSubprocessLauncher = object(TGObject)
    function new(flags: TGSubprocessFlags): PGSubprocessLauncher; cdecl; inline; static;
    function getenv(variable: Pgchar): Pgchar; cdecl; inline;
    procedure set_child_setup(child_setup: TGSpawnChildSetupFunc; user_data: gpointer; destroy_notify: TGDestroyNotify); cdecl; inline;
    procedure set_cwd(cwd: Pgchar); cdecl; inline;
    procedure set_environ(env: PPgchar); cdecl; inline;
    procedure set_flags(flags: TGSubprocessFlags); cdecl; inline;
    procedure set_stderr_file_path(path: Pgchar); cdecl; inline;
    procedure set_stdin_file_path(path: Pgchar); cdecl; inline;
    procedure set_stdout_file_path(path: Pgchar); cdecl; inline;
    procedure setenv(variable: Pgchar; value: Pgchar; overwrite: gboolean); cdecl; inline;
    //function spawn(error: PPGError; argv0: Pgchar; args: array of const): PGSubprocess; cdecl; inline;
    function spawnv(argv: PPgchar; error: PPGError): PGSubprocess; cdecl; inline;
    procedure take_fd(source_fd: gint; target_fd: gint); cdecl; inline;
    procedure take_stderr_fd(fd: gint); cdecl; inline;
    procedure take_stdin_fd(fd: gint); cdecl; inline;
    procedure take_stdout_fd(fd: gint); cdecl; inline;
    procedure unsetenv(variable: Pgchar); cdecl; inline;
    //property flags: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_flags  { property is writeable but setter not declared } ;
  end;


  { TGTask }
  PPGTask = ^PGTask;
  PGTask = ^TGTask;


  { TGTaskThreadFunc }
  PPGTaskThreadFunc = ^PGTaskThreadFunc;
  PGTaskThreadFunc = ^TGTaskThreadFunc;
  TGTaskThreadFunc = procedure(task: PGTask; source_object: PGObject; task_data: gpointer; cancellable: PGCancellable); cdecl;
  TGTask = object(TGObject)
    function new(source_object: PGObject; cancellable: PGCancellable; callback: TGAsyncReadyCallback; callback_data: gpointer): PGTask; cdecl; inline; static;
    function is_valid(result_: PGAsyncResult; source_object: PGObject): gboolean; cdecl; inline; static;
    procedure report_error(source_object: PGObject; callback: TGAsyncReadyCallback; callback_data: gpointer; source_tag: gpointer; error: PGError); cdecl; inline; static;
    //procedure report_new_error(source_object: PGObject; callback: TGAsyncReadyCallback; callback_data: gpointer; source_tag: gpointer; domain: TGQuark; code: gint; format: Pgchar; args: array of const); cdecl; inline; static;
    procedure attach_source(source: PGSource; callback: TGSourceFunc); cdecl; inline;
    function get_cancellable: PGCancellable; cdecl; inline;
    function get_check_cancellable: gboolean; cdecl; inline;
    function get_completed: gboolean; cdecl; inline;
    function get_context: PGMainContext; cdecl; inline;
    function get_name: Pgchar; cdecl; inline;
    function get_priority: gint; cdecl; inline;
    function get_return_on_cancel: gboolean; cdecl; inline;
    function get_source_object: PGObject; cdecl; inline;
    function get_source_tag: gpointer; cdecl; inline;
    function get_task_data: gpointer; cdecl; inline;
    function had_error: gboolean; cdecl; inline;
    function propagate_boolean(error: PPGError): gboolean; cdecl; inline;
    function propagate_int(error: PPGError): gssize; cdecl; inline;
    function propagate_pointer(error: PPGError): gpointer; cdecl; inline;
    function propagate_value(value: PGValue; error: PPGError): gboolean; cdecl; inline;
    procedure return_boolean(result_: gboolean); cdecl; inline;
    procedure return_error(error: PGError); cdecl; inline;
    function return_error_if_cancelled: gboolean; cdecl; inline;
    procedure return_int(result_: gssize); cdecl; inline;
    //procedure return_new_error(domain: TGQuark; code: gint; format: Pgchar; args: array of const); cdecl; inline;
    procedure return_pointer(result_: gpointer; result_destroy: TGDestroyNotify); cdecl; inline;
    procedure return_value(result_: PGValue); cdecl; inline;
    procedure run_in_thread(task_func: TGTaskThreadFunc); cdecl; inline;
    procedure run_in_thread_sync(task_func: TGTaskThreadFunc); cdecl; inline;
    procedure set_check_cancellable(check_cancellable: gboolean); cdecl; inline;
    procedure set_name(name: Pgchar); cdecl; inline;
    procedure set_priority(priority: gint); cdecl; inline;
    function set_return_on_cancel(return_on_cancel: gboolean): gboolean; cdecl; inline;
    procedure set_source_tag(source_tag: gpointer); cdecl; inline;
    procedure set_task_data(task_data: gpointer; task_data_destroy: TGDestroyNotify); cdecl; inline;
    property completed: gboolean read get_completed ;
  end;


  { TGTaskClass }
  PPGTaskClass = ^PGTaskClass;
  PGTaskClass = ^TGTaskClass;
  TGTaskClass = object
  end;


  { TGTcpConnection }
  PPGTcpConnection = ^PGTcpConnection;
  PGTcpConnection = ^TGTcpConnection;


  { TGTcpConnectionPrivate }
  PPGTcpConnectionPrivate = ^PGTcpConnectionPrivate;
  PGTcpConnectionPrivate = ^TGTcpConnectionPrivate;
  TGTcpConnection = object(TGSocketConnection)
    priv2: PGTcpConnectionPrivate;
    function get_graceful_disconnect: gboolean; cdecl; inline;
    procedure set_graceful_disconnect(graceful_disconnect: gboolean); cdecl; inline;
    property graceful_disconnect: gboolean read get_graceful_disconnect write set_graceful_disconnect;
  end;

  TGTcpConnectionPrivate = record
  end;




  { TGTcpConnectionClass }
  PPGTcpConnectionClass = ^PGTcpConnectionClass;
  PGTcpConnectionClass = ^TGTcpConnectionClass;
  TGTcpConnectionClass = object
    parent_class: TGSocketConnectionClass;
  end;


  { TGTcpWrapperConnection }
  PPGTcpWrapperConnection = ^PGTcpWrapperConnection;
  PGTcpWrapperConnection = ^TGTcpWrapperConnection;


  { TGTcpWrapperConnectionPrivate }
  PPGTcpWrapperConnectionPrivate = ^PGTcpWrapperConnectionPrivate;
  PGTcpWrapperConnectionPrivate = ^TGTcpWrapperConnectionPrivate;
  TGTcpWrapperConnection = object(TGTcpConnection)
    priv3: PGTcpWrapperConnectionPrivate;
    function new(base_io_stream: PGIOStream; socket: PGSocket): PGTcpWrapperConnection; cdecl; inline; static;
    function get_base_io_stream: PGIOStream; cdecl; inline;
    property base_io_stream: PGIOStream read get_base_io_stream  { property is writeable but setter not declared } ;
  end;

  TGTcpWrapperConnectionPrivate = record
  end;




  { TGTcpWrapperConnectionClass }
  PPGTcpWrapperConnectionClass = ^PGTcpWrapperConnectionClass;
  PGTcpWrapperConnectionClass = ^TGTcpWrapperConnectionClass;
  TGTcpWrapperConnectionClass = object
    parent_class: TGTcpConnectionClass;
  end;


  { TGTestDBus }
  PPGTestDBus = ^PGTestDBus;
  PGTestDBus = ^TGTestDBus;


  { TGTestDBusFlags }
  PPGTestDBusFlags = ^PGTestDBusFlags;
  PGTestDBusFlags = ^TGTestDBusFlags;
  TGTestDBus = object(TGObject)
    function new(flags: TGTestDBusFlags): PGTestDBus; cdecl; inline; static;
    procedure unset; cdecl; inline; static;
    procedure add_service_dir(path: Pgchar); cdecl; inline;
    procedure down; cdecl; inline;
    function get_bus_address: Pgchar; cdecl; inline;
    function get_flags: TGTestDBusFlags; cdecl; inline;
    procedure stop; cdecl; inline;
    procedure up; cdecl; inline;
    property flags: TGTestDBusFlags read get_flags  { property is writeable but setter not declared } ;
  end;


  { TGThemedIcon }
  PPGThemedIcon = ^PGThemedIcon;
  PGThemedIcon = ^TGThemedIcon;
  TGThemedIcon = object(TGObject)
    function new(iconname: Pgchar): PGThemedIcon; cdecl; inline; static;
    function new_from_names(iconnames: PPgchar; len: gint): PGThemedIcon; cdecl; inline; static;
    function new_with_default_fallbacks(iconname: Pgchar): PGThemedIcon; cdecl; inline; static;
    procedure append_name(iconname: Pgchar); cdecl; inline;
    function get_names: PPgchar; cdecl; inline;
    procedure prepend_name(iconname: Pgchar); cdecl; inline;
    //property name: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_name  { property is writeable but setter not declared } ;
    property names: PPgchar read get_names  { property is writeable but setter not declared } ;
    //property use_default_fallbacks: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_use_default_fallbacks  { property is writeable but setter not declared } ;
  end;


  { TGThemedIconClass }
  PPGThemedIconClass = ^PGThemedIconClass;
  PGThemedIconClass = ^TGThemedIconClass;
  TGThemedIconClass = object
  end;


  { TGThreadedSocketService }
  PPGThreadedSocketService = ^PGThreadedSocketService;
  PGThreadedSocketService = ^TGThreadedSocketService;


  { TGThreadedSocketServicePrivate }
  PPGThreadedSocketServicePrivate = ^PGThreadedSocketServicePrivate;
  PGThreadedSocketServicePrivate = ^TGThreadedSocketServicePrivate;
  TGThreadedSocketService = object(TGSocketService)
    priv2: PGThreadedSocketServicePrivate;
    function new(max_threads: gint): PGThreadedSocketService; cdecl; inline; static;
    //property max_threads: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_max_threads  { property is writeable but setter not declared } ;
  end;

  TGThreadedSocketServicePrivate = record
  end;




  { TGThreadedSocketServiceClass }
  PPGThreadedSocketServiceClass = ^PGThreadedSocketServiceClass;
  PGThreadedSocketServiceClass = ^TGThreadedSocketServiceClass;
  TGThreadedSocketServiceClass = object
    parent_class: TGSocketServiceClass;
    run: function(service: PGThreadedSocketService; connection: PGSocketConnection; source_object: PGObject): gboolean; cdecl;
    _g_reserved1: procedure; cdecl;
    _g_reserved2: procedure; cdecl;
    _g_reserved3: procedure; cdecl;
    _g_reserved4: procedure; cdecl;
    _g_reserved5: procedure; cdecl;
  end;


  { TGTlsBackend }
  PPGTlsBackend = ^PGTlsBackend;
  PGTlsBackend = ^TGTlsBackend;
  TGTlsBackend = object
    function get_default: PGTlsBackend; cdecl; inline; static;
    function get_certificate_type: TGType; cdecl; inline;
    function get_client_connection_type: TGType; cdecl; inline;
    function get_default_database: PGTlsDatabase; cdecl; inline;
    function get_dtls_client_connection_type: TGType; cdecl; inline;
    function get_dtls_server_connection_type: TGType; cdecl; inline;
    function get_file_database_type: TGType; cdecl; inline;
    function get_server_connection_type: TGType; cdecl; inline;
    procedure set_default_database(database: PGTlsDatabase); cdecl; inline;
    function supports_dtls: gboolean; cdecl; inline;
    function supports_tls: gboolean; cdecl; inline;
  end;


  { TGTlsBackendInterface }
  PPGTlsBackendInterface = ^PGTlsBackendInterface;
  PGTlsBackendInterface = ^TGTlsBackendInterface;
  TGTlsBackendInterface = object
    g_iface: TGTypeInterface;
    supports_tls: function(backend: PGTlsBackend): gboolean; cdecl;
    get_certificate_type: function: TGType; cdecl;
    get_client_connection_type: function: TGType; cdecl;
    get_server_connection_type: function: TGType; cdecl;
    get_file_database_type: function: TGType; cdecl;
    get_default_database: function(backend: PGTlsBackend): PGTlsDatabase; cdecl;
    supports_dtls: function(backend: PGTlsBackend): gboolean; cdecl;
    get_dtls_client_connection_type: function: TGType; cdecl;
    get_dtls_server_connection_type: function: TGType; cdecl;
  end;

  TGTlsCertificatePrivate = record
  end;




  { TGTlsCertificateClass }
  PPGTlsCertificateClass = ^PGTlsCertificateClass;
  PGTlsCertificateClass = ^TGTlsCertificateClass;
  TGTlsCertificateClass = object
    parent_class: TGObjectClass;
    verify: function(cert: PGTlsCertificate; identity: PGSocketConnectable; trusted_ca: PGTlsCertificate): TGTlsCertificateFlags; cdecl;
    padding: array [0..7] of gpointer;
  end;


  { TGTlsChannelBindingError }
  PPGTlsChannelBindingError = ^PGTlsChannelBindingError;
  PGTlsChannelBindingError = ^TGTlsChannelBindingError;


  { TGTlsClientConnection }
  PPGTlsClientConnection = ^PGTlsClientConnection;
  PGTlsClientConnection = ^TGTlsClientConnection;
  TGTlsClientConnection = object
    function new(base_io_stream: PGIOStream; server_identity: PGSocketConnectable; error: PPGError): PGTlsClientConnection; cdecl; inline; static;
    procedure copy_session_state(source: PGTlsClientConnection); cdecl; inline;
    function get_accepted_cas: PGList; cdecl; inline;
    function get_server_identity: PGSocketConnectable; cdecl; inline;
    function get_validation_flags: TGTlsCertificateFlags; cdecl; inline; deprecated 'Do not attempt to ignore validation errors.';
    procedure set_server_identity(identity: PGSocketConnectable); cdecl; inline;
    procedure set_validation_flags(flags: TGTlsCertificateFlags); cdecl; inline; deprecated 'Do not attempt to ignore validation errors.';
    property accepted_cas: PGList read get_accepted_cas ;
    property server_identity: PGSocketConnectable read get_server_identity write set_server_identity;
  end;


  { TGTlsClientConnectionInterface }
  PPGTlsClientConnectionInterface = ^PGTlsClientConnectionInterface;
  PGTlsClientConnectionInterface = ^TGTlsClientConnectionInterface;
  TGTlsClientConnectionInterface = object
    g_iface: TGTypeInterface;
    copy_session_state: procedure(conn: PGTlsClientConnection; source: PGTlsClientConnection); cdecl;
  end;


  { TGTlsConnectionPrivate }
  PPGTlsConnectionPrivate = ^PGTlsConnectionPrivate;
  PGTlsConnectionPrivate = ^TGTlsConnectionPrivate;
  TGTlsConnection = object(TGIOStream)
    priv1: PGTlsConnectionPrivate;
    function emit_accept_certificate(peer_cert: PGTlsCertificate; errors: TGTlsCertificateFlags): gboolean; cdecl; inline;
    function get_certificate: PGTlsCertificate; cdecl; inline;
    {$IFDEF USEGTK3LATESTBINDINGS}
    function get_channel_binding_data(type_: TGTlsChannelBindingType; data: Pguint8; error: PPGError): gboolean; cdecl; inline;
    {$ENDIF}
    function get_database: PGTlsDatabase; cdecl; inline;
    function get_interaction: PGTlsInteraction; cdecl; inline;
    function get_negotiated_protocol: Pgchar; cdecl; inline;
    function get_peer_certificate: PGTlsCertificate; cdecl; inline;
    function get_peer_certificate_errors: TGTlsCertificateFlags; cdecl; inline;
    function get_require_close_notify: gboolean; cdecl; inline;
    function handshake(cancellable: PGCancellable; error: PPGError): gboolean; cdecl; inline;
    procedure handshake_async(io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function handshake_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl; inline;
    procedure set_advertised_protocols(protocols: PPgchar); cdecl; inline;
    procedure set_certificate(certificate: PGTlsCertificate); cdecl; inline;
    procedure set_database(database: PGTlsDatabase); cdecl; inline;
    procedure set_interaction(interaction: PGTlsInteraction); cdecl; inline;
    procedure set_require_close_notify(require_close_notify: gboolean); cdecl; inline;
    //property advertised_protocols: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_advertised_protocols  { property is writeable but setter not declared } ;
    //property base_io_stream: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_base_io_stream  { property is writeable but setter not declared } ;
    property certificate: PGTlsCertificate read get_certificate write set_certificate;
    property database: PGTlsDatabase read get_database write set_database;
    property interaction: PGTlsInteraction read get_interaction write set_interaction;
    property negotiated_protocol: Pgchar read get_negotiated_protocol ;
    property peer_certificate: PGTlsCertificate read get_peer_certificate ;
    property peer_certificate_errors: TGTlsCertificateFlags read get_peer_certificate_errors ;
    property require_close_notify: gboolean read get_require_close_notify write set_require_close_notify;
  end;

  TGTlsConnectionPrivate = record
  end;




  { TGTlsConnectionClass }
  PPGTlsConnectionClass = ^PGTlsConnectionClass;
  PGTlsConnectionClass = ^TGTlsConnectionClass;
  TGTlsConnectionClass = object
    parent_class: TGIOStreamClass;
    accept_certificate: function(connection: PGTlsConnection; peer_cert: PGTlsCertificate; errors: TGTlsCertificateFlags): gboolean; cdecl;
    handshake: function(conn: PGTlsConnection; cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
    handshake_async: procedure(conn: PGTlsConnection; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    handshake_finish: function(conn: PGTlsConnection; result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
    get_binding_data: function(conn: PGTlsConnection; type_: TGTlsChannelBindingType; data: Pguint8; error: PPGError): gboolean; cdecl;
    get_negotiated_protocol: function(conn: PGTlsConnection): Pgchar; cdecl;
    padding: array [0..5] of gpointer;
  end;

  TGTlsDatabasePrivate = record
  end;




  { TGTlsDatabaseClass }
  PPGTlsDatabaseClass = ^PGTlsDatabaseClass;
  PGTlsDatabaseClass = ^TGTlsDatabaseClass;
  TGTlsDatabaseClass = object
    parent_class: TGObjectClass;
    verify_chain: function(self: PGTlsDatabase; chain: PGTlsCertificate; purpose: Pgchar; identity: PGSocketConnectable; interaction: PGTlsInteraction; flags: TGTlsDatabaseVerifyFlags; cancellable: PGCancellable; error: PPGError): TGTlsCertificateFlags; cdecl;
    verify_chain_async: procedure(self: PGTlsDatabase; chain: PGTlsCertificate; purpose: Pgchar; identity: PGSocketConnectable; interaction: PGTlsInteraction; flags: TGTlsDatabaseVerifyFlags; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    verify_chain_finish: function(self: PGTlsDatabase; result_: PGAsyncResult; error: PPGError): TGTlsCertificateFlags; cdecl;
    create_certificate_handle: function(self: PGTlsDatabase; certificate: PGTlsCertificate): Pgchar; cdecl;
    lookup_certificate_for_handle: function(self: PGTlsDatabase; handle: Pgchar; interaction: PGTlsInteraction; flags: TGTlsDatabaseLookupFlags; cancellable: PGCancellable; error: PPGError): PGTlsCertificate; cdecl;
    lookup_certificate_for_handle_async: procedure(self: PGTlsDatabase; handle: Pgchar; interaction: PGTlsInteraction; flags: TGTlsDatabaseLookupFlags; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    lookup_certificate_for_handle_finish: function(self: PGTlsDatabase; result_: PGAsyncResult; error: PPGError): PGTlsCertificate; cdecl;
    lookup_certificate_issuer: function(self: PGTlsDatabase; certificate: PGTlsCertificate; interaction: PGTlsInteraction; flags: TGTlsDatabaseLookupFlags; cancellable: PGCancellable; error: PPGError): PGTlsCertificate; cdecl;
    lookup_certificate_issuer_async: procedure(self: PGTlsDatabase; certificate: PGTlsCertificate; interaction: PGTlsInteraction; flags: TGTlsDatabaseLookupFlags; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    lookup_certificate_issuer_finish: function(self: PGTlsDatabase; result_: PGAsyncResult; error: PPGError): PGTlsCertificate; cdecl;
    lookup_certificates_issued_by: function(self: PGTlsDatabase; issuer_raw_dn: Pguint8; interaction: PGTlsInteraction; flags: TGTlsDatabaseLookupFlags; cancellable: PGCancellable; error: PPGError): PGList; cdecl;
    lookup_certificates_issued_by_async: procedure(self: PGTlsDatabase; issuer_raw_dn: Pguint8; interaction: PGTlsInteraction; flags: TGTlsDatabaseLookupFlags; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    lookup_certificates_issued_by_finish: function(self: PGTlsDatabase; result_: PGAsyncResult; error: PPGError): PGList; cdecl;
    padding: array [0..15] of gpointer;
  end;


  { TGTlsError }
  PPGTlsError = ^PGTlsError;
  PGTlsError = ^TGTlsError;


  { TGTlsFileDatabase }
  PPGTlsFileDatabase = ^PGTlsFileDatabase;
  PGTlsFileDatabase = ^TGTlsFileDatabase;
  TGTlsFileDatabase = object
    function new(anchors: Pgchar; error: PPGError): PGTlsFileDatabase; cdecl; inline; static;
    //property anchors: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_anchors  { property is writeable but setter not declared } ;
  end;


  { TGTlsFileDatabaseInterface }
  PPGTlsFileDatabaseInterface = ^PGTlsFileDatabaseInterface;
  PGTlsFileDatabaseInterface = ^TGTlsFileDatabaseInterface;
  TGTlsFileDatabaseInterface = object
    g_iface: TGTypeInterface;
    padding: array [0..7] of gpointer;
  end;


  { TGTlsPasswordFlags }
  PPGTlsPasswordFlags = ^PGTlsPasswordFlags;
  PGTlsPasswordFlags = ^TGTlsPasswordFlags;


  { TGTlsPasswordPrivate }
  PPGTlsPasswordPrivate = ^PGTlsPasswordPrivate;
  PGTlsPasswordPrivate = ^TGTlsPasswordPrivate;
  TGTlsPassword = object(TGObject)
    priv: PGTlsPasswordPrivate;
    function new(flags: TGTlsPasswordFlags; description: Pgchar): PGTlsPassword; cdecl; inline; static;
    function get_description: Pgchar; cdecl; inline;
    function get_flags: TGTlsPasswordFlags; cdecl; inline;
    function get_value(length: Pgsize): Pguint8; cdecl; inline;
    function get_warning: Pgchar; cdecl; inline;
    procedure set_description(description: Pgchar); cdecl; inline;
    procedure set_flags(flags: TGTlsPasswordFlags); cdecl; inline;
    procedure set_value(value: Pguint8; length: gssize); cdecl; inline;
    procedure set_value_full(value: Pguint8; length: gssize; destroy_: TGDestroyNotify); cdecl; inline;
    procedure set_warning(warning: Pgchar); cdecl; inline;
    property description: Pgchar read get_description write set_description;
    property flags: TGTlsPasswordFlags read get_flags write set_flags;
    property warning: Pgchar read get_warning write set_warning;
  end;

  TGTlsInteractionPrivate = record
  end;




  { TGTlsInteractionClass }
  PPGTlsInteractionClass = ^PGTlsInteractionClass;
  PGTlsInteractionClass = ^TGTlsInteractionClass;
  TGTlsInteractionClass = object
    parent_class: TGObjectClass;
    ask_password: function(interaction: PGTlsInteraction; password: PGTlsPassword; cancellable: PGCancellable; error: PPGError): TGTlsInteractionResult; cdecl;
    ask_password_async: procedure(interaction: PGTlsInteraction; password: PGTlsPassword; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    ask_password_finish: function(interaction: PGTlsInteraction; result_: PGAsyncResult; error: PPGError): TGTlsInteractionResult; cdecl;
    request_certificate: function(interaction: PGTlsInteraction; connection: PGTlsConnection; flags: TGTlsCertificateRequestFlags; cancellable: PGCancellable; error: PPGError): TGTlsInteractionResult; cdecl;
    request_certificate_async: procedure(interaction: PGTlsInteraction; connection: PGTlsConnection; flags: TGTlsCertificateRequestFlags; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    request_certificate_finish: function(interaction: PGTlsInteraction; result_: PGAsyncResult; error: PPGError): TGTlsInteractionResult; cdecl;
    padding: array [0..20] of gpointer;
  end;

  TGTlsPasswordPrivate = record
  end;




  { TGTlsPasswordClass }
  PPGTlsPasswordClass = ^PGTlsPasswordClass;
  PGTlsPasswordClass = ^TGTlsPasswordClass;
  TGTlsPasswordClass = object
    parent_class: TGObjectClass;
    get_value: function(password: PGTlsPassword; length: Pgsize): Pguint8; cdecl;
    set_value: procedure(password: PGTlsPassword; value: Pguint8; length: gssize; destroy_: TGDestroyNotify); cdecl;
    get_default_warning: function(password: PGTlsPassword): Pgchar; cdecl;
    padding: array [0..3] of gpointer;
  end;


  { TGTlsServerConnection }
  PPGTlsServerConnection = ^PGTlsServerConnection;
  PGTlsServerConnection = ^TGTlsServerConnection;
  TGTlsServerConnection = object
    function new(base_io_stream: PGIOStream; certificate: PGTlsCertificate; error: PPGError): PGTlsServerConnection; cdecl; inline; static;
    //property authentication_mode: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_authentication_mode  { property is writeable but setter not declared } ;
  end;


  { TGTlsServerConnectionInterface }
  PPGTlsServerConnectionInterface = ^PGTlsServerConnectionInterface;
  PGTlsServerConnectionInterface = ^TGTlsServerConnectionInterface;
  TGTlsServerConnectionInterface = object
    g_iface: TGTypeInterface;
  end;


  { TGUnixConnection }
  PPGUnixConnection = ^PGUnixConnection;
  PGUnixConnection = ^TGUnixConnection;


  { TGUnixConnectionPrivate }
  PPGUnixConnectionPrivate = ^PGUnixConnectionPrivate;
  PGUnixConnectionPrivate = ^TGUnixConnectionPrivate;
  TGUnixConnection = object(TGSocketConnection)
    priv2: PGUnixConnectionPrivate;
    function receive_credentials(cancellable: PGCancellable; error: PPGError): PGCredentials; cdecl; inline;
    procedure receive_credentials_async(cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function receive_credentials_finish(result_: PGAsyncResult; error: PPGError): PGCredentials; cdecl; inline;
    function receive_fd(cancellable: PGCancellable; error: PPGError): gint; cdecl; inline;
    function send_credentials(cancellable: PGCancellable; error: PPGError): gboolean; cdecl; inline;
    procedure send_credentials_async(cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; inline;
    function send_credentials_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl; inline;
    function send_fd(fd: gint; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; inline;
  end;

  TGUnixConnectionPrivate = record
  end;




  { TGUnixConnectionClass }
  PPGUnixConnectionClass = ^PGUnixConnectionClass;
  PGUnixConnectionClass = ^TGUnixConnectionClass;
  TGUnixConnectionClass = object
    parent_class: TGSocketConnectionClass;
  end;


  { TGUnixCredentialsMessage }
  PPGUnixCredentialsMessage = ^PGUnixCredentialsMessage;
  PGUnixCredentialsMessage = ^TGUnixCredentialsMessage;


  { TGUnixCredentialsMessagePrivate }
  PPGUnixCredentialsMessagePrivate = ^PGUnixCredentialsMessagePrivate;
  PGUnixCredentialsMessagePrivate = ^TGUnixCredentialsMessagePrivate;
  TGUnixCredentialsMessage = object(TGSocketControlMessage)
    priv1: PGUnixCredentialsMessagePrivate;
    function new: PGUnixCredentialsMessage; cdecl; inline; static;
    function new_with_credentials(credentials: PGCredentials): PGUnixCredentialsMessage; cdecl; inline; static;
    function is_supported: gboolean; cdecl; inline; static;
    function get_credentials: PGCredentials; cdecl; inline;
    property credentials: PGCredentials read get_credentials  { property is writeable but setter not declared } ;
  end;

  TGUnixCredentialsMessagePrivate = record
  end;




  { TGUnixCredentialsMessageClass }
  PPGUnixCredentialsMessageClass = ^PGUnixCredentialsMessageClass;
  PGUnixCredentialsMessageClass = ^TGUnixCredentialsMessageClass;
  TGUnixCredentialsMessageClass = object
    parent_class: TGSocketControlMessageClass;
    _g_reserved1: procedure; cdecl;
    _g_reserved2: procedure; cdecl;
  end;

  TGUnixFDListPrivate = record
  end;




  { TGUnixFDListClass }
  PPGUnixFDListClass = ^PGUnixFDListClass;
  PGUnixFDListClass = ^TGUnixFDListClass;
  TGUnixFDListClass = object
    parent_class: TGObjectClass;
    _g_reserved1: procedure; cdecl;
    _g_reserved2: procedure; cdecl;
    _g_reserved3: procedure; cdecl;
    _g_reserved4: procedure; cdecl;
    _g_reserved5: procedure; cdecl;
  end;


  { TGUnixFDMessage }
  PPGUnixFDMessage = ^PGUnixFDMessage;
  PGUnixFDMessage = ^TGUnixFDMessage;


  { TGUnixFDMessagePrivate }
  PPGUnixFDMessagePrivate = ^PGUnixFDMessagePrivate;
  PGUnixFDMessagePrivate = ^TGUnixFDMessagePrivate;
  TGUnixFDMessage = object(TGSocketControlMessage)
    priv1: PGUnixFDMessagePrivate;
    function new: PGUnixFDMessage; cdecl; inline; static;
    function new_with_fd_list(fd_list: PGUnixFDList): PGUnixFDMessage; cdecl; inline; static;
    function append_fd(fd: gint; error: PPGError): gboolean; cdecl; inline;
    function get_fd_list: PGUnixFDList; cdecl; inline;
    function steal_fds(length: Pgint): Pgint; cdecl; inline;
    property fd_list: PGUnixFDList read get_fd_list  { property is writeable but setter not declared } ;
  end;

  TGUnixFDMessagePrivate = record
  end;




  { TGUnixFDMessageClass }
  PPGUnixFDMessageClass = ^PGUnixFDMessageClass;
  PGUnixFDMessageClass = ^TGUnixFDMessageClass;
  TGUnixFDMessageClass = object
    parent_class: TGSocketControlMessageClass;
    _g_reserved1: procedure; cdecl;
    _g_reserved2: procedure; cdecl;
  end;


  { TGUnixInputStream }
  PPGUnixInputStream = ^PGUnixInputStream;
  PGUnixInputStream = ^TGUnixInputStream;


  { TGUnixInputStreamPrivate }
  PPGUnixInputStreamPrivate = ^PGUnixInputStreamPrivate;
  PGUnixInputStreamPrivate = ^TGUnixInputStreamPrivate;
  TGUnixInputStream = object(TGInputStream)
    priv1: PGUnixInputStreamPrivate;
    function new(fd: gint; close_fd: gboolean): PGUnixInputStream; cdecl; inline; static;
    function get_close_fd: gboolean; cdecl; inline;
    function get_fd: gint; cdecl; inline;
    procedure set_close_fd(close_fd: gboolean); cdecl; inline;
    property close_fd: gboolean read get_close_fd write set_close_fd;
    property fd: gint read get_fd  { property is writeable but setter not declared } ;
  end;

  TGUnixInputStreamPrivate = record
  end;




  { TGUnixInputStreamClass }
  PPGUnixInputStreamClass = ^PGUnixInputStreamClass;
  PGUnixInputStreamClass = ^TGUnixInputStreamClass;
  TGUnixInputStreamClass = object
    parent_class: TGInputStreamClass;
    _g_reserved1: procedure; cdecl;
    _g_reserved2: procedure; cdecl;
    _g_reserved3: procedure; cdecl;
    _g_reserved4: procedure; cdecl;
    _g_reserved5: procedure; cdecl;
  end;


  { TGUnixMountEntry }
  PPGUnixMountEntry = ^PGUnixMountEntry;
  PGUnixMountEntry = ^TGUnixMountEntry;
  TGUnixMountEntry = object
  end;


  { TGUnixMountMonitor }
  PPGUnixMountMonitor = ^PGUnixMountMonitor;
  PGUnixMountMonitor = ^TGUnixMountMonitor;
  TGUnixMountMonitor = object(TGObject)
    function get: PGUnixMountMonitor; cdecl; inline; static;
  end;


  { TGUnixMountMonitorClass }
  PPGUnixMountMonitorClass = ^PGUnixMountMonitorClass;
  PGUnixMountMonitorClass = ^TGUnixMountMonitorClass;
  TGUnixMountMonitorClass = object
  end;


  { TGUnixMountPoint }
  PPGUnixMountPoint = ^PGUnixMountPoint;
  PGUnixMountPoint = ^TGUnixMountPoint;
  TGUnixMountPoint = object
    function compare(mount2: PGUnixMountPoint): gint; cdecl; inline;
    function copy: PGUnixMountPoint; cdecl; inline;
    procedure free; cdecl; inline;
    function get_device_path: Pgchar; cdecl; inline;
    function get_fs_type: Pgchar; cdecl; inline;
    function get_mount_path: Pgchar; cdecl; inline;
    function get_options: Pgchar; cdecl; inline;
    function guess_can_eject: gboolean; cdecl; inline;
    function guess_icon: PGIcon; cdecl; inline;
    function guess_name: Pgchar; cdecl; inline;
    function guess_symbolic_icon: PGIcon; cdecl; inline;
    function is_loopback: gboolean; cdecl; inline;
    function is_readonly: gboolean; cdecl; inline;
    function is_user_mountable: gboolean; cdecl; inline;
    {$IFDEF USEGTK3LATESTBINDINGS}
    function at(mount_path: Pgchar; time_read: Pguint64): PGUnixMountPoint; cdecl; inline; static;
    {$ENDIF}
  end;


  { TGUnixOutputStream }
  PPGUnixOutputStream = ^PGUnixOutputStream;
  PGUnixOutputStream = ^TGUnixOutputStream;


  { TGUnixOutputStreamPrivate }
  PPGUnixOutputStreamPrivate = ^PGUnixOutputStreamPrivate;
  PGUnixOutputStreamPrivate = ^TGUnixOutputStreamPrivate;
  TGUnixOutputStream = object(TGOutputStream)
    priv1: PGUnixOutputStreamPrivate;
    function new(fd: gint; close_fd: gboolean): PGUnixOutputStream; cdecl; inline; static;
    function get_close_fd: gboolean; cdecl; inline;
    function get_fd: gint; cdecl; inline;
    procedure set_close_fd(close_fd: gboolean); cdecl; inline;
    property close_fd: gboolean read get_close_fd write set_close_fd;
    property fd: gint read get_fd  { property is writeable but setter not declared } ;
  end;

  TGUnixOutputStreamPrivate = record
  end;




  { TGUnixOutputStreamClass }
  PPGUnixOutputStreamClass = ^PGUnixOutputStreamClass;
  PGUnixOutputStreamClass = ^TGUnixOutputStreamClass;
  TGUnixOutputStreamClass = object
    parent_class: TGOutputStreamClass;
    _g_reserved1: procedure; cdecl;
    _g_reserved2: procedure; cdecl;
    _g_reserved3: procedure; cdecl;
    _g_reserved4: procedure; cdecl;
    _g_reserved5: procedure; cdecl;
  end;


  { TGUnixSocketAddressType }
  PPGUnixSocketAddressType = ^PGUnixSocketAddressType;
  PGUnixSocketAddressType = ^TGUnixSocketAddressType;


  { TGUnixSocketAddress }
  PPGUnixSocketAddress = ^PGUnixSocketAddress;
  PGUnixSocketAddress = ^TGUnixSocketAddress;


  { TGUnixSocketAddressPrivate }
  PPGUnixSocketAddressPrivate = ^PGUnixSocketAddressPrivate;
  PGUnixSocketAddressPrivate = ^TGUnixSocketAddressPrivate;
  TGUnixSocketAddress = object(TGSocketAddress)
    priv: PGUnixSocketAddressPrivate;
    function new(path: Pgchar): PGUnixSocketAddress; cdecl; inline; static;
    function new_with_type(path: Pgchar; path_len: gint; type_: TGUnixSocketAddressType): PGUnixSocketAddress; cdecl; inline; static;
    function abstract_names_supported: gboolean; cdecl; inline; static;
    function get_address_type: TGUnixSocketAddressType; cdecl; inline;
    function get_path: Pgchar; cdecl; inline;
    function get_path_len: gsize; cdecl; inline;
    property address_type: TGUnixSocketAddressType read get_address_type  { property is writeable but setter not declared } ;
    property path: Pgchar read get_path  { property is writeable but setter not declared } ;
    //property path_as_array: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_path_as_array  { property is writeable but setter not declared } ;
  end;

  TGUnixSocketAddressPrivate = record
  end;




  { TGUnixSocketAddressClass }
  PPGUnixSocketAddressClass = ^PGUnixSocketAddressClass;
  PGUnixSocketAddressClass = ^TGUnixSocketAddressClass;
  TGUnixSocketAddressClass = object
    parent_class: TGSocketAddressClass;
  end;


  { TGVfs }
  PPGVfs = ^PGVfs;
  PGVfs = ^TGVfs;


  { TGVfsFileLookupFunc }
  PPGVfsFileLookupFunc = ^PGVfsFileLookupFunc;
  PGVfsFileLookupFunc = ^TGVfsFileLookupFunc;
  TGVfsFileLookupFunc = function(vfs: PGVfs; identifier: Pgchar; user_data: gpointer): PGFile; cdecl;
  TGVfs = object(TGObject)
    function get_default: PGVfs; cdecl; inline; static;
    function get_local: PGVfs; cdecl; inline; static;
    function get_file_for_path(path: Pgchar): PGFile; cdecl; inline;
    function get_file_for_uri(uri: Pgchar): PGFile; cdecl; inline;
    function get_supported_uri_schemes: PPgchar; cdecl; inline;
    function is_active: gboolean; cdecl; inline;
    function parse_name(parse_name: Pgchar): PGFile; cdecl; inline;
    function register_uri_scheme(scheme: Pgchar; uri_func: TGVfsFileLookupFunc; uri_data: gpointer; uri_destroy: TGDestroyNotify; parse_name_func: TGVfsFileLookupFunc; parse_name_data: gpointer; parse_name_destroy: TGDestroyNotify): gboolean; cdecl; inline;
    function unregister_uri_scheme(scheme: Pgchar): gboolean; cdecl; inline;
  end;


  { TGVfsClass }
  PPGVfsClass = ^PGVfsClass;
  PGVfsClass = ^TGVfsClass;
  TGVfsClass = object
    parent_class: TGObjectClass;
    is_active: function(vfs: PGVfs): gboolean; cdecl;
    get_file_for_path: function(vfs: PGVfs; path: Pgchar): PGFile; cdecl;
    get_file_for_uri: function(vfs: PGVfs; uri: Pgchar): PGFile; cdecl;
    get_supported_uri_schemes: function(vfs: PGVfs): PPgchar; cdecl;
    parse_name: function(vfs: PGVfs; parse_name: Pgchar): PGFile; cdecl;
    local_file_add_info: procedure(vfs: PGVfs; filename: Pgchar; device: guint64; attribute_matcher: PGFileAttributeMatcher; info: PGFileInfo; cancellable: PGCancellable; extra_data: Pgpointer; free_extra_data: PGDestroyNotify); cdecl;
    add_writable_namespaces: procedure(vfs: PGVfs; list: PGFileAttributeInfoList); cdecl;
    local_file_set_attributes: function(vfs: PGVfs; filename: Pgchar; info: PGFileInfo; flags: TGFileQueryInfoFlags; cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
    local_file_removed: procedure(vfs: PGVfs; filename: Pgchar); cdecl;
    local_file_moved: procedure(vfs: PGVfs; source: Pgchar; dest: Pgchar); cdecl;
    deserialize_icon: function(vfs: PGVfs; value: PGVariant): PGIcon; cdecl;
    _g_reserved1: procedure; cdecl;
    _g_reserved2: procedure; cdecl;
    _g_reserved3: procedure; cdecl;
    _g_reserved4: procedure; cdecl;
    _g_reserved5: procedure; cdecl;
    _g_reserved6: procedure; cdecl;
  end;


  { TGVolumeIface }
  PPGVolumeIface = ^PGVolumeIface;
  PGVolumeIface = ^TGVolumeIface;
  TGVolumeIface = object
    g_iface: TGTypeInterface;
    changed: procedure(volume: PGVolume); cdecl;
    removed: procedure(volume: PGVolume); cdecl;
    get_name: function(volume: PGVolume): Pgchar; cdecl;
    get_icon: function(volume: PGVolume): PGIcon; cdecl;
    get_uuid: function(volume: PGVolume): Pgchar; cdecl;
    get_drive: function(volume: PGVolume): PGDrive; cdecl;
    get_mount: function(volume: PGVolume): PGMount; cdecl;
    can_mount: function(volume: PGVolume): gboolean; cdecl;
    can_eject: function(volume: PGVolume): gboolean; cdecl;
    mount_fn: procedure(volume: PGVolume; flags: TGMountMountFlags; mount_operation: PGMountOperation; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    mount_finish: function(volume: PGVolume; result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
    eject: procedure(volume: PGVolume; flags: TGMountUnmountFlags; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    eject_finish: function(volume: PGVolume; result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
    get_identifier: function(volume: PGVolume; kind: Pgchar): Pgchar; cdecl;
    enumerate_identifiers: function(volume: PGVolume): PPgchar; cdecl;
    should_automount: function(volume: PGVolume): gboolean; cdecl;
    get_activation_root: function(volume: PGVolume): PGFile; cdecl;
    eject_with_operation: procedure(volume: PGVolume; flags: TGMountUnmountFlags; mount_operation: PGMountOperation; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
    eject_with_operation_finish: function(volume: PGVolume; result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
    get_sort_key: function(volume: PGVolume): Pgchar; cdecl;
    get_symbolic_icon: function(volume: PGVolume): PGIcon; cdecl;
  end;


  { TGZlibCompressor }
  PPGZlibCompressor = ^PGZlibCompressor;
  PGZlibCompressor = ^TGZlibCompressor;


  { TGZlibCompressorFormat }
  PPGZlibCompressorFormat = ^PGZlibCompressorFormat;
  PGZlibCompressorFormat = ^TGZlibCompressorFormat;
  TGZlibCompressor = object(TGObject)
    function new(format: TGZlibCompressorFormat; level: gint): PGZlibCompressor; cdecl; inline; static;
    function get_file_info: PGFileInfo; cdecl; inline;
    procedure set_file_info(file_info: PGFileInfo); cdecl; inline;
    property file_info: PGFileInfo read get_file_info write set_file_info;
    //property format: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_format  { property is writeable but setter not declared } ;
    //property level: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_level  { property is writeable but setter not declared } ;
  end;


  { TGZlibCompressorClass }
  PPGZlibCompressorClass = ^PGZlibCompressorClass;
  PGZlibCompressorClass = ^TGZlibCompressorClass;
  TGZlibCompressorClass = object
    parent_class: TGObjectClass;
  end;


  { TGZlibDecompressor }
  PPGZlibDecompressor = ^PGZlibDecompressor;
  PGZlibDecompressor = ^TGZlibDecompressor;
  TGZlibDecompressor = object(TGObject)
    function new(format: TGZlibCompressorFormat): PGZlibDecompressor; cdecl; inline; static;
    function get_file_info: PGFileInfo; cdecl; inline;
    property file_info: PGFileInfo read get_file_info ;
    //property format: UNABLE_TO_FIND_TYPE_FOR_PROPERTY read get_format  { property is writeable but setter not declared } ;
  end;


  { TGZlibDecompressorClass }
  PPGZlibDecompressorClass = ^PGZlibDecompressorClass;
  PGZlibDecompressorClass = ^TGZlibDecompressorClass;
  TGZlibDecompressorClass = object
    parent_class: TGObjectClass;
  end;

function g_action_get_enabled(action: PGAction): gboolean; cdecl; external LazGio2_library name 'g_action_get_enabled';
function g_action_get_name(action: PGAction): Pgchar; cdecl; external LazGio2_library name 'g_action_get_name';
function g_action_get_parameter_type(action: PGAction): PGVariantType; cdecl; external LazGio2_library name 'g_action_get_parameter_type';
function g_action_get_state(action: PGAction): PGVariant; cdecl; external LazGio2_library name 'g_action_get_state';
function g_action_get_state_hint(action: PGAction): PGVariant; cdecl; external LazGio2_library name 'g_action_get_state_hint';
function g_action_get_state_type(action: PGAction): PGVariantType; cdecl; external LazGio2_library name 'g_action_get_state_type';
function g_action_get_type: TGType; cdecl; external LazGio2_library name 'g_action_get_type';
function g_action_group_get_action_enabled(action_group: PGActionGroup; action_name: Pgchar): gboolean; cdecl; external LazGio2_library name 'g_action_group_get_action_enabled';
function g_action_group_get_action_parameter_type(action_group: PGActionGroup; action_name: Pgchar): PGVariantType; cdecl; external LazGio2_library name 'g_action_group_get_action_parameter_type';
function g_action_group_get_action_state(action_group: PGActionGroup; action_name: Pgchar): PGVariant; cdecl; external LazGio2_library name 'g_action_group_get_action_state';
function g_action_group_get_action_state_hint(action_group: PGActionGroup; action_name: Pgchar): PGVariant; cdecl; external LazGio2_library name 'g_action_group_get_action_state_hint';
function g_action_group_get_action_state_type(action_group: PGActionGroup; action_name: Pgchar): PGVariantType; cdecl; external LazGio2_library name 'g_action_group_get_action_state_type';
function g_action_group_get_type: TGType; cdecl; external LazGio2_library name 'g_action_group_get_type';
function g_action_group_has_action(action_group: PGActionGroup; action_name: Pgchar): gboolean; cdecl; external LazGio2_library name 'g_action_group_has_action';
function g_action_group_list_actions(action_group: PGActionGroup): PPgchar; cdecl; external LazGio2_library name 'g_action_group_list_actions';
function g_action_group_query_action(action_group: PGActionGroup; action_name: Pgchar; enabled: Pgboolean; parameter_type: PPGVariantType; state_type: PPGVariantType; state_hint: PPGVariant; state: PPGVariant): gboolean; cdecl; external LazGio2_library name 'g_action_group_query_action';
function g_action_map_get_type: TGType; cdecl; external LazGio2_library name 'g_action_map_get_type';
function g_action_map_lookup_action(action_map: PGActionMap; action_name: Pgchar): PGAction; cdecl; external LazGio2_library name 'g_action_map_lookup_action';
function g_action_name_is_valid(action_name: Pgchar): gboolean; cdecl; external LazGio2_library name 'g_action_name_is_valid';
function g_action_parse_detailed_name(detailed_name: Pgchar; action_name: PPgchar; target_value: PPGVariant; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_action_parse_detailed_name';
function g_action_print_detailed_name(action_name: Pgchar; target_value: PGVariant): Pgchar; cdecl; external LazGio2_library name 'g_action_print_detailed_name';
function g_app_info_add_supports_type(appinfo: PGAppInfo; content_type: Pgchar; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_app_info_add_supports_type';
function g_app_info_can_delete(appinfo: PGAppInfo): gboolean; cdecl; external LazGio2_library name 'g_app_info_can_delete';
function g_app_info_can_remove_supports_type(appinfo: PGAppInfo): gboolean; cdecl; external LazGio2_library name 'g_app_info_can_remove_supports_type';
function g_app_info_create_from_commandline(commandline: Pgchar; application_name: Pgchar; flags: TGAppInfoCreateFlags; error: PPGError): PGAppInfo; cdecl; external LazGio2_library name 'g_app_info_create_from_commandline';
function g_app_info_delete(appinfo: PGAppInfo): gboolean; cdecl; external LazGio2_library name 'g_app_info_delete';
function g_app_info_dup(appinfo: PGAppInfo): PGAppInfo; cdecl; external LazGio2_library name 'g_app_info_dup';
function g_app_info_equal(appinfo1: PGAppInfo; appinfo2: PGAppInfo): gboolean; cdecl; external LazGio2_library name 'g_app_info_equal';
function g_app_info_get_all: PGList; cdecl; external LazGio2_library name 'g_app_info_get_all';
function g_app_info_get_all_for_type(content_type: Pgchar): PGList; cdecl; external LazGio2_library name 'g_app_info_get_all_for_type';
function g_app_info_get_commandline(appinfo: PGAppInfo): Pgchar; cdecl; external LazGio2_library name 'g_app_info_get_commandline';
function g_app_info_get_default_for_type(content_type: Pgchar; must_support_uris: gboolean): PGAppInfo; cdecl; external LazGio2_library name 'g_app_info_get_default_for_type';
function g_app_info_get_default_for_uri_scheme(uri_scheme: Pgchar): PGAppInfo; cdecl; external LazGio2_library name 'g_app_info_get_default_for_uri_scheme';
function g_app_info_get_description(appinfo: PGAppInfo): Pgchar; cdecl; external LazGio2_library name 'g_app_info_get_description';
function g_app_info_get_display_name(appinfo: PGAppInfo): Pgchar; cdecl; external LazGio2_library name 'g_app_info_get_display_name';
function g_app_info_get_executable(appinfo: PGAppInfo): Pgchar; cdecl; external LazGio2_library name 'g_app_info_get_executable';
function g_app_info_get_fallback_for_type(content_type: Pgchar): PGList; cdecl; external LazGio2_library name 'g_app_info_get_fallback_for_type';
function g_app_info_get_icon(appinfo: PGAppInfo): PGIcon; cdecl; external LazGio2_library name 'g_app_info_get_icon';
function g_app_info_get_id(appinfo: PGAppInfo): Pgchar; cdecl; external LazGio2_library name 'g_app_info_get_id';
function g_app_info_get_name(appinfo: PGAppInfo): Pgchar; cdecl; external LazGio2_library name 'g_app_info_get_name';
function g_app_info_get_recommended_for_type(content_type: Pgchar): PGList; cdecl; external LazGio2_library name 'g_app_info_get_recommended_for_type';
function g_app_info_get_supported_types(appinfo: PGAppInfo): PPgchar; cdecl; external LazGio2_library name 'g_app_info_get_supported_types';
function g_app_info_get_type: TGType; cdecl; external LazGio2_library name 'g_app_info_get_type';
function g_app_info_launch(appinfo: PGAppInfo; files: PGList; context: PGAppLaunchContext; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_app_info_launch';
function g_app_info_launch_default_for_uri(uri: Pgchar; context: PGAppLaunchContext; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_app_info_launch_default_for_uri';
function g_app_info_launch_default_for_uri_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_app_info_launch_default_for_uri_finish';
function g_app_info_launch_uris(appinfo: PGAppInfo; uris: PGList; context: PGAppLaunchContext; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_app_info_launch_uris';
function g_app_info_launch_uris_finish(appinfo: PGAppInfo; result_: PGAsyncResult; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_app_info_launch_uris_finish';
function g_app_info_monitor_get: PGAppInfoMonitor; cdecl; external LazGio2_library name 'g_app_info_monitor_get';
function g_app_info_monitor_get_type: TGType; cdecl; external LazGio2_library name 'g_app_info_monitor_get_type';
function g_app_info_remove_supports_type(appinfo: PGAppInfo; content_type: Pgchar; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_app_info_remove_supports_type';
function g_app_info_set_as_default_for_extension(appinfo: PGAppInfo; extension: Pgchar; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_app_info_set_as_default_for_extension';
function g_app_info_set_as_default_for_type(appinfo: PGAppInfo; content_type: Pgchar; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_app_info_set_as_default_for_type';
function g_app_info_set_as_last_used_for_type(appinfo: PGAppInfo; content_type: Pgchar; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_app_info_set_as_last_used_for_type';
function g_app_info_should_show(appinfo: PGAppInfo): gboolean; cdecl; external LazGio2_library name 'g_app_info_should_show';
function g_app_info_supports_files(appinfo: PGAppInfo): gboolean; cdecl; external LazGio2_library name 'g_app_info_supports_files';
function g_app_info_supports_uris(appinfo: PGAppInfo): gboolean; cdecl; external LazGio2_library name 'g_app_info_supports_uris';
function g_app_launch_context_get_display(context: PGAppLaunchContext; info: PGAppInfo; files: PGList): Pgchar; cdecl; external LazGio2_library name 'g_app_launch_context_get_display';
function g_app_launch_context_get_environment(context: PGAppLaunchContext): PPgchar; cdecl; external LazGio2_library name 'g_app_launch_context_get_environment';
function g_app_launch_context_get_startup_notify_id(context: PGAppLaunchContext; info: PGAppInfo; files: PGList): Pgchar; cdecl; external LazGio2_library name 'g_app_launch_context_get_startup_notify_id';
function g_app_launch_context_get_type: TGType; cdecl; external LazGio2_library name 'g_app_launch_context_get_type';
function g_app_launch_context_new: PGAppLaunchContext; cdecl; external LazGio2_library name 'g_app_launch_context_new';
function g_application_command_line_create_file_for_arg(cmdline: PGApplicationCommandLine; arg: Pgchar): PGFile; cdecl; external LazGio2_library name 'g_application_command_line_create_file_for_arg';
function g_application_command_line_get_arguments(cmdline: PGApplicationCommandLine; argc: Pgint): PPgchar; cdecl; external LazGio2_library name 'g_application_command_line_get_arguments';
function g_application_command_line_get_cwd(cmdline: PGApplicationCommandLine): Pgchar; cdecl; external LazGio2_library name 'g_application_command_line_get_cwd';
function g_application_command_line_get_environ(cmdline: PGApplicationCommandLine): PPgchar; cdecl; external LazGio2_library name 'g_application_command_line_get_environ';
function g_application_command_line_get_exit_status(cmdline: PGApplicationCommandLine): gint; cdecl; external LazGio2_library name 'g_application_command_line_get_exit_status';
function g_application_command_line_get_is_remote(cmdline: PGApplicationCommandLine): gboolean; cdecl; external LazGio2_library name 'g_application_command_line_get_is_remote';
function g_application_command_line_get_options_dict(cmdline: PGApplicationCommandLine): PGVariantDict; cdecl; external LazGio2_library name 'g_application_command_line_get_options_dict';
function g_application_command_line_get_platform_data(cmdline: PGApplicationCommandLine): PGVariant; cdecl; external LazGio2_library name 'g_application_command_line_get_platform_data';
function g_application_command_line_get_stdin(cmdline: PGApplicationCommandLine): PGInputStream; cdecl; external LazGio2_library name 'g_application_command_line_get_stdin';
function g_application_command_line_get_type: TGType; cdecl; external LazGio2_library name 'g_application_command_line_get_type';
function g_application_command_line_getenv(cmdline: PGApplicationCommandLine; name: Pgchar): Pgchar; cdecl; external LazGio2_library name 'g_application_command_line_getenv';
function g_application_get_application_id(application: PGApplication): Pgchar; cdecl; external LazGio2_library name 'g_application_get_application_id';
function g_application_get_dbus_connection(application: PGApplication): PGDBusConnection; cdecl; external LazGio2_library name 'g_application_get_dbus_connection';
function g_application_get_dbus_object_path(application: PGApplication): Pgchar; cdecl; external LazGio2_library name 'g_application_get_dbus_object_path';
function g_application_get_default: PGApplication; cdecl; external LazGio2_library name 'g_application_get_default';
function g_application_get_flags(application: PGApplication): TGApplicationFlags; cdecl; external LazGio2_library name 'g_application_get_flags';
function g_application_get_inactivity_timeout(application: PGApplication): guint; cdecl; external LazGio2_library name 'g_application_get_inactivity_timeout';
function g_application_get_is_busy(application: PGApplication): gboolean; cdecl; external LazGio2_library name 'g_application_get_is_busy';
function g_application_get_is_registered(application: PGApplication): gboolean; cdecl; external LazGio2_library name 'g_application_get_is_registered';
function g_application_get_is_remote(application: PGApplication): gboolean; cdecl; external LazGio2_library name 'g_application_get_is_remote';
function g_application_get_resource_base_path(application: PGApplication): Pgchar; cdecl; external LazGio2_library name 'g_application_get_resource_base_path';
function g_application_get_type: TGType; cdecl; external LazGio2_library name 'g_application_get_type';
function g_application_id_is_valid(application_id: Pgchar): gboolean; cdecl; external LazGio2_library name 'g_application_id_is_valid';
function g_application_new(application_id: Pgchar; flags: TGApplicationFlags): PGApplication; cdecl; external LazGio2_library name 'g_application_new';
function g_application_register(application: PGApplication; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_application_register';
function g_application_run(application: PGApplication; argc: gint; argv: PPgchar): gint; cdecl; external LazGio2_library name 'g_application_run';
function g_async_initable_get_type: TGType; cdecl; external LazGio2_library name 'g_async_initable_get_type';
function g_async_initable_init_finish(initable: PGAsyncInitable; res: PGAsyncResult; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_async_initable_init_finish';
function g_async_initable_new_finish(initable: PGAsyncInitable; res: PGAsyncResult; error: PPGError): PGObject; cdecl; external LazGio2_library name 'g_async_initable_new_finish';
function g_async_result_get_source_object(res: PGAsyncResult): PGObject; cdecl; external LazGio2_library name 'g_async_result_get_source_object';
function g_async_result_get_type: TGType; cdecl; external LazGio2_library name 'g_async_result_get_type';
function g_async_result_get_user_data(res: PGAsyncResult): gpointer; cdecl; external LazGio2_library name 'g_async_result_get_user_data';
function g_async_result_is_tagged(res: PGAsyncResult; source_tag: gpointer): gboolean; cdecl; external LazGio2_library name 'g_async_result_is_tagged';
function g_async_result_legacy_propagate_error(res: PGAsyncResult; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_async_result_legacy_propagate_error';
function g_buffered_input_stream_fill(stream: PGBufferedInputStream; count: gssize; cancellable: PGCancellable; error: PPGError): gssize; cdecl; external LazGio2_library name 'g_buffered_input_stream_fill';
function g_buffered_input_stream_fill_finish(stream: PGBufferedInputStream; result_: PGAsyncResult; error: PPGError): gssize; cdecl; external LazGio2_library name 'g_buffered_input_stream_fill_finish';
function g_buffered_input_stream_get_available(stream: PGBufferedInputStream): gsize; cdecl; external LazGio2_library name 'g_buffered_input_stream_get_available';
function g_buffered_input_stream_get_buffer_size(stream: PGBufferedInputStream): gsize; cdecl; external LazGio2_library name 'g_buffered_input_stream_get_buffer_size';
function g_buffered_input_stream_get_type: TGType; cdecl; external LazGio2_library name 'g_buffered_input_stream_get_type';
function g_buffered_input_stream_new(base_stream: PGInputStream): PGBufferedInputStream; cdecl; external LazGio2_library name 'g_buffered_input_stream_new';
function g_buffered_input_stream_new_sized(base_stream: PGInputStream; size: gsize): PGBufferedInputStream; cdecl; external LazGio2_library name 'g_buffered_input_stream_new_sized';
function g_buffered_input_stream_peek(stream: PGBufferedInputStream; buffer: Pguint8; offset: gsize; count: gsize): gsize; cdecl; external LazGio2_library name 'g_buffered_input_stream_peek';
function g_buffered_input_stream_peek_buffer(stream: PGBufferedInputStream; count: Pgsize): Pguint8; cdecl; external LazGio2_library name 'g_buffered_input_stream_peek_buffer';
function g_buffered_input_stream_read_byte(stream: PGBufferedInputStream; cancellable: PGCancellable; error: PPGError): gint; cdecl; external LazGio2_library name 'g_buffered_input_stream_read_byte';
function g_buffered_output_stream_get_auto_grow(stream: PGBufferedOutputStream): gboolean; cdecl; external LazGio2_library name 'g_buffered_output_stream_get_auto_grow';
function g_buffered_output_stream_get_buffer_size(stream: PGBufferedOutputStream): gsize; cdecl; external LazGio2_library name 'g_buffered_output_stream_get_buffer_size';
function g_buffered_output_stream_get_type: TGType; cdecl; external LazGio2_library name 'g_buffered_output_stream_get_type';
function g_buffered_output_stream_new(base_stream: PGOutputStream): PGBufferedOutputStream; cdecl; external LazGio2_library name 'g_buffered_output_stream_new';
function g_buffered_output_stream_new_sized(base_stream: PGOutputStream; size: gsize): PGBufferedOutputStream; cdecl; external LazGio2_library name 'g_buffered_output_stream_new_sized';
function g_bus_get_finish(res: PGAsyncResult; error: PPGError): PGDBusConnection; cdecl; external LazGio2_library name 'g_bus_get_finish';
function g_bus_get_sync(bus_type: TGBusType; cancellable: PGCancellable; error: PPGError): PGDBusConnection; cdecl; external LazGio2_library name 'g_bus_get_sync';
function g_bus_own_name(bus_type: TGBusType; name: Pgchar; flags: TGBusNameOwnerFlags; bus_acquired_handler: TGBusAcquiredCallback; name_acquired_handler: TGBusNameAcquiredCallback; name_lost_handler: TGBusNameLostCallback; user_data: gpointer; user_data_free_func: TGDestroyNotify): guint; cdecl; external LazGio2_library name 'g_bus_own_name';
function g_bus_own_name_on_connection(connection: PGDBusConnection; name: Pgchar; flags: TGBusNameOwnerFlags; name_acquired_handler: TGBusNameAcquiredCallback; name_lost_handler: TGBusNameLostCallback; user_data: gpointer; user_data_free_func: TGDestroyNotify): guint; cdecl; external LazGio2_library name 'g_bus_own_name_on_connection';
function g_bus_own_name_on_connection_with_closures(connection: PGDBusConnection; name: Pgchar; flags: TGBusNameOwnerFlags; name_acquired_closure: PGClosure; name_lost_closure: PGClosure): guint; cdecl; external LazGio2_library name 'g_bus_own_name_on_connection_with_closures';
function g_bus_own_name_with_closures(bus_type: TGBusType; name: Pgchar; flags: TGBusNameOwnerFlags; bus_acquired_closure: PGClosure; name_acquired_closure: PGClosure; name_lost_closure: PGClosure): guint; cdecl; external LazGio2_library name 'g_bus_own_name_with_closures';
function g_bus_watch_name(bus_type: TGBusType; name: Pgchar; flags: TGBusNameWatcherFlags; name_appeared_handler: TGBusNameAppearedCallback; name_vanished_handler: TGBusNameVanishedCallback; user_data: gpointer; user_data_free_func: TGDestroyNotify): guint; cdecl; external LazGio2_library name 'g_bus_watch_name';
function g_bus_watch_name_on_connection(connection: PGDBusConnection; name: Pgchar; flags: TGBusNameWatcherFlags; name_appeared_handler: TGBusNameAppearedCallback; name_vanished_handler: TGBusNameVanishedCallback; user_data: gpointer; user_data_free_func: TGDestroyNotify): guint; cdecl; external LazGio2_library name 'g_bus_watch_name_on_connection';
function g_bus_watch_name_on_connection_with_closures(connection: PGDBusConnection; name: Pgchar; flags: TGBusNameWatcherFlags; name_appeared_closure: PGClosure; name_vanished_closure: PGClosure): guint; cdecl; external LazGio2_library name 'g_bus_watch_name_on_connection_with_closures';
function g_bus_watch_name_with_closures(bus_type: TGBusType; name: Pgchar; flags: TGBusNameWatcherFlags; name_appeared_closure: PGClosure; name_vanished_closure: PGClosure): guint; cdecl; external LazGio2_library name 'g_bus_watch_name_with_closures';
function g_bytes_icon_get_bytes(icon: PGBytesIcon): PGBytes; cdecl; external LazGio2_library name 'g_bytes_icon_get_bytes';
function g_bytes_icon_get_type: TGType; cdecl; external LazGio2_library name 'g_bytes_icon_get_type';
function g_bytes_icon_new(bytes: PGBytes): PGBytesIcon; cdecl; external LazGio2_library name 'g_bytes_icon_new';
function g_cancellable_connect(cancellable: PGCancellable; callback: TGCallback; data: gpointer; data_destroy_func: TGDestroyNotify): gulong; cdecl; external LazGio2_library name 'g_cancellable_connect';
function g_cancellable_get_current: PGCancellable; cdecl; external LazGio2_library name 'g_cancellable_get_current';
function g_cancellable_get_fd(cancellable: PGCancellable): gint; cdecl; external LazGio2_library name 'g_cancellable_get_fd';
function g_cancellable_get_type: TGType; cdecl; external LazGio2_library name 'g_cancellable_get_type';
function g_cancellable_is_cancelled(cancellable: PGCancellable): gboolean; cdecl; external LazGio2_library name 'g_cancellable_is_cancelled';
function g_cancellable_make_pollfd(cancellable: PGCancellable; pollfd: PGPollFD): gboolean; cdecl; external LazGio2_library name 'g_cancellable_make_pollfd';
function g_cancellable_new: PGCancellable; cdecl; external LazGio2_library name 'g_cancellable_new';
function g_cancellable_set_error_if_cancelled(cancellable: PGCancellable; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_cancellable_set_error_if_cancelled';
function g_cancellable_source_new(cancellable: PGCancellable): PGSource; cdecl; external LazGio2_library name 'g_cancellable_source_new';
function g_charset_converter_get_num_fallbacks(converter: PGCharsetConverter): guint; cdecl; external LazGio2_library name 'g_charset_converter_get_num_fallbacks';
function g_charset_converter_get_type: TGType; cdecl; external LazGio2_library name 'g_charset_converter_get_type';
function g_charset_converter_get_use_fallback(converter: PGCharsetConverter): gboolean; cdecl; external LazGio2_library name 'g_charset_converter_get_use_fallback';
function g_charset_converter_new(to_charset: Pgchar; from_charset: Pgchar; error: PPGError): PGCharsetConverter; cdecl; external LazGio2_library name 'g_charset_converter_new';
function g_content_type_can_be_executable(type_: Pgchar): gboolean; cdecl; external LazGio2_library name 'g_content_type_can_be_executable';
function g_content_type_equals(type1: Pgchar; type2: Pgchar): gboolean; cdecl; external LazGio2_library name 'g_content_type_equals';
function g_content_type_from_mime_type(mime_type: Pgchar): Pgchar; cdecl; external LazGio2_library name 'g_content_type_from_mime_type';
function g_content_type_get_description(type_: Pgchar): Pgchar; cdecl; external LazGio2_library name 'g_content_type_get_description';
function g_content_type_get_generic_icon_name(type_: Pgchar): Pgchar; cdecl; external LazGio2_library name 'g_content_type_get_generic_icon_name';
function g_content_type_get_icon(type_: Pgchar): PGIcon; cdecl; external LazGio2_library name 'g_content_type_get_icon';
function g_content_type_get_mime_dirs: PPgchar; cdecl; external LazGio2_library name 'g_content_type_get_mime_dirs';
function g_content_type_get_mime_type(type_: Pgchar): Pgchar; cdecl; external LazGio2_library name 'g_content_type_get_mime_type';
function g_content_type_get_symbolic_icon(type_: Pgchar): PGIcon; cdecl; external LazGio2_library name 'g_content_type_get_symbolic_icon';
function g_content_type_guess(filename: Pgchar; data: Pguint8; data_size: gsize; result_uncertain: Pgboolean): Pgchar; cdecl; external LazGio2_library name 'g_content_type_guess';
function g_content_type_guess_for_tree(root: PGFile): PPgchar; cdecl; external LazGio2_library name 'g_content_type_guess_for_tree';
function g_content_type_is_a(type_: Pgchar; supertype: Pgchar): gboolean; cdecl; external LazGio2_library name 'g_content_type_is_a';
function g_content_type_is_mime_type(type_: Pgchar; mime_type: Pgchar): gboolean; cdecl; external LazGio2_library name 'g_content_type_is_mime_type';
function g_content_type_is_unknown(type_: Pgchar): gboolean; cdecl; external LazGio2_library name 'g_content_type_is_unknown';
function g_content_types_get_registered: PGList; cdecl; external LazGio2_library name 'g_content_types_get_registered';
function g_converter_convert(converter: PGConverter; inbuf: Pguint8; inbuf_size: gsize; outbuf: Pguint8; outbuf_size: gsize; flags: TGConverterFlags; bytes_read: Pgsize; bytes_written: Pgsize; error: PPGError): TGConverterResult; cdecl; external LazGio2_library name 'g_converter_convert';
function g_converter_get_type: TGType; cdecl; external LazGio2_library name 'g_converter_get_type';
function g_converter_input_stream_get_converter(converter_stream: PGConverterInputStream): PGConverter; cdecl; external LazGio2_library name 'g_converter_input_stream_get_converter';
function g_converter_input_stream_get_type: TGType; cdecl; external LazGio2_library name 'g_converter_input_stream_get_type';
function g_converter_input_stream_new(base_stream: PGInputStream; converter: PGConverter): PGConverterInputStream; cdecl; external LazGio2_library name 'g_converter_input_stream_new';
function g_converter_output_stream_get_converter(converter_stream: PGConverterOutputStream): PGConverter; cdecl; external LazGio2_library name 'g_converter_output_stream_get_converter';
function g_converter_output_stream_get_type: TGType; cdecl; external LazGio2_library name 'g_converter_output_stream_get_type';
function g_converter_output_stream_new(base_stream: PGOutputStream; converter: PGConverter): PGConverterOutputStream; cdecl; external LazGio2_library name 'g_converter_output_stream_new';
function g_credentials_get_native(credentials: PGCredentials; native_type: TGCredentialsType): gpointer; cdecl; external LazGio2_library name 'g_credentials_get_native';
function g_credentials_get_type: TGType; cdecl; external LazGio2_library name 'g_credentials_get_type';
function g_credentials_get_unix_pid(credentials: PGCredentials; error: PPGError): gint; cdecl; external LazGio2_library name 'g_credentials_get_unix_pid';
function g_credentials_get_unix_user(credentials: PGCredentials; error: PPGError): guint; cdecl; external LazGio2_library name 'g_credentials_get_unix_user';
function g_credentials_is_same_user(credentials: PGCredentials; other_credentials: PGCredentials; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_credentials_is_same_user';
function g_credentials_new: PGCredentials; cdecl; external LazGio2_library name 'g_credentials_new';
function g_credentials_set_unix_user(credentials: PGCredentials; uid: guint; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_credentials_set_unix_user';
function g_credentials_to_string(credentials: PGCredentials): Pgchar; cdecl; external LazGio2_library name 'g_credentials_to_string';
function g_data_input_stream_get_byte_order(stream: PGDataInputStream): TGDataStreamByteOrder; cdecl; external LazGio2_library name 'g_data_input_stream_get_byte_order';
function g_data_input_stream_get_newline_type(stream: PGDataInputStream): TGDataStreamNewlineType; cdecl; external LazGio2_library name 'g_data_input_stream_get_newline_type';
function g_data_input_stream_get_type: TGType; cdecl; external LazGio2_library name 'g_data_input_stream_get_type';
function g_data_input_stream_new(base_stream: PGInputStream): PGDataInputStream; cdecl; external LazGio2_library name 'g_data_input_stream_new';
function g_data_input_stream_read_byte(stream: PGDataInputStream; cancellable: PGCancellable; error: PPGError): guint8; cdecl; external LazGio2_library name 'g_data_input_stream_read_byte';
function g_data_input_stream_read_int16(stream: PGDataInputStream; cancellable: PGCancellable; error: PPGError): gint16; cdecl; external LazGio2_library name 'g_data_input_stream_read_int16';
function g_data_input_stream_read_int32(stream: PGDataInputStream; cancellable: PGCancellable; error: PPGError): gint32; cdecl; external LazGio2_library name 'g_data_input_stream_read_int32';
function g_data_input_stream_read_int64(stream: PGDataInputStream; cancellable: PGCancellable; error: PPGError): gint64; cdecl; external LazGio2_library name 'g_data_input_stream_read_int64';
function g_data_input_stream_read_line(stream: PGDataInputStream; length: Pgsize; cancellable: PGCancellable; error: PPGError): Pgchar; cdecl; external LazGio2_library name 'g_data_input_stream_read_line';
function g_data_input_stream_read_line_finish(stream: PGDataInputStream; result_: PGAsyncResult; length: Pgsize; error: PPGError): Pgchar; cdecl; external LazGio2_library name 'g_data_input_stream_read_line_finish';
function g_data_input_stream_read_line_finish_utf8(stream: PGDataInputStream; result_: PGAsyncResult; length: Pgsize; error: PPGError): Pgchar; cdecl; external LazGio2_library name 'g_data_input_stream_read_line_finish_utf8';
function g_data_input_stream_read_line_utf8(stream: PGDataInputStream; length: Pgsize; cancellable: PGCancellable; error: PPGError): Pgchar; cdecl; external LazGio2_library name 'g_data_input_stream_read_line_utf8';
function g_data_input_stream_read_uint16(stream: PGDataInputStream; cancellable: PGCancellable; error: PPGError): guint16; cdecl; external LazGio2_library name 'g_data_input_stream_read_uint16';
function g_data_input_stream_read_uint32(stream: PGDataInputStream; cancellable: PGCancellable; error: PPGError): guint32; cdecl; external LazGio2_library name 'g_data_input_stream_read_uint32';
function g_data_input_stream_read_uint64(stream: PGDataInputStream; cancellable: PGCancellable; error: PPGError): guint64; cdecl; external LazGio2_library name 'g_data_input_stream_read_uint64';
function g_data_input_stream_read_upto(stream: PGDataInputStream; stop_chars: Pgchar; stop_chars_len: gssize; length: Pgsize; cancellable: PGCancellable; error: PPGError): Pgchar; cdecl; external LazGio2_library name 'g_data_input_stream_read_upto';
function g_data_input_stream_read_upto_finish(stream: PGDataInputStream; result_: PGAsyncResult; length: Pgsize; error: PPGError): Pgchar; cdecl; external LazGio2_library name 'g_data_input_stream_read_upto_finish';
function g_data_output_stream_get_byte_order(stream: PGDataOutputStream): TGDataStreamByteOrder; cdecl; external LazGio2_library name 'g_data_output_stream_get_byte_order';
function g_data_output_stream_get_type: TGType; cdecl; external LazGio2_library name 'g_data_output_stream_get_type';
function g_data_output_stream_new(base_stream: PGOutputStream): PGDataOutputStream; cdecl; external LazGio2_library name 'g_data_output_stream_new';
function g_data_output_stream_put_byte(stream: PGDataOutputStream; data: guint8; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_data_output_stream_put_byte';
function g_data_output_stream_put_int16(stream: PGDataOutputStream; data: gint16; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_data_output_stream_put_int16';
function g_data_output_stream_put_int32(stream: PGDataOutputStream; data: gint32; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_data_output_stream_put_int32';
function g_data_output_stream_put_int64(stream: PGDataOutputStream; data: gint64; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_data_output_stream_put_int64';
function g_data_output_stream_put_string(stream: PGDataOutputStream; str: Pgchar; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_data_output_stream_put_string';
function g_data_output_stream_put_uint16(stream: PGDataOutputStream; data: guint16; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_data_output_stream_put_uint16';
function g_data_output_stream_put_uint32(stream: PGDataOutputStream; data: guint32; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_data_output_stream_put_uint32';
function g_data_output_stream_put_uint64(stream: PGDataOutputStream; data: guint64; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_data_output_stream_put_uint64';
function g_datagram_based_condition_check(datagram_based: PGDatagramBased; condition: TGIOCondition): TGIOCondition; cdecl; external LazGio2_library name 'g_datagram_based_condition_check';
function g_datagram_based_condition_wait(datagram_based: PGDatagramBased; condition: TGIOCondition; timeout: gint64; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_datagram_based_condition_wait';
function g_datagram_based_create_source(datagram_based: PGDatagramBased; condition: TGIOCondition; cancellable: PGCancellable): PGSource; cdecl; external LazGio2_library name 'g_datagram_based_create_source';
function g_datagram_based_get_type: TGType; cdecl; external LazGio2_library name 'g_datagram_based_get_type';
function g_datagram_based_receive_messages(datagram_based: PGDatagramBased; messages: PGInputMessage; num_messages: guint; flags: gint; timeout: gint64; cancellable: PGCancellable; error: PPGError): gint; cdecl; external LazGio2_library name 'g_datagram_based_receive_messages';
function g_datagram_based_send_messages(datagram_based: PGDatagramBased; messages: PGOutputMessage; num_messages: guint; flags: gint; timeout: gint64; cancellable: PGCancellable; error: PPGError): gint; cdecl; external LazGio2_library name 'g_datagram_based_send_messages';
function g_dbus_action_group_get(connection: PGDBusConnection; bus_name: Pgchar; object_path: Pgchar): PGDBusActionGroup; cdecl; external LazGio2_library name 'g_dbus_action_group_get';
function g_dbus_action_group_get_type: TGType; cdecl; external LazGio2_library name 'g_dbus_action_group_get_type';
function g_dbus_address_escape_value(string_: Pgchar): Pgchar; cdecl; external LazGio2_library name 'g_dbus_address_escape_value';
function g_dbus_address_get_for_bus_sync(bus_type: TGBusType; cancellable: PGCancellable; error: PPGError): Pgchar; cdecl; external LazGio2_library name 'g_dbus_address_get_for_bus_sync';
function g_dbus_address_get_stream_finish(res: PGAsyncResult; out_guid: PPgchar; error: PPGError): PGIOStream; cdecl; external LazGio2_library name 'g_dbus_address_get_stream_finish';
function g_dbus_address_get_stream_sync(address: Pgchar; out_guid: PPgchar; cancellable: PGCancellable; error: PPGError): PGIOStream; cdecl; external LazGio2_library name 'g_dbus_address_get_stream_sync';
function g_dbus_annotation_info_get_type: TGType; cdecl; external LazGio2_library name 'g_dbus_annotation_info_get_type';
function g_dbus_annotation_info_lookup(annotations: PPGDBusAnnotationInfo; name: Pgchar): Pgchar; cdecl; external LazGio2_library name 'g_dbus_annotation_info_lookup';
function g_dbus_annotation_info_ref(info: PGDBusAnnotationInfo): PGDBusAnnotationInfo; cdecl; external LazGio2_library name 'g_dbus_annotation_info_ref';
function g_dbus_arg_info_get_type: TGType; cdecl; external LazGio2_library name 'g_dbus_arg_info_get_type';
function g_dbus_arg_info_ref(info: PGDBusArgInfo): PGDBusArgInfo; cdecl; external LazGio2_library name 'g_dbus_arg_info_ref';
function g_dbus_auth_observer_allow_mechanism(observer: PGDBusAuthObserver; mechanism: Pgchar): gboolean; cdecl; external LazGio2_library name 'g_dbus_auth_observer_allow_mechanism';
function g_dbus_auth_observer_authorize_authenticated_peer(observer: PGDBusAuthObserver; stream: PGIOStream; credentials: PGCredentials): gboolean; cdecl; external LazGio2_library name 'g_dbus_auth_observer_authorize_authenticated_peer';
function g_dbus_auth_observer_get_type: TGType; cdecl; external LazGio2_library name 'g_dbus_auth_observer_get_type';
function g_dbus_auth_observer_new: PGDBusAuthObserver; cdecl; external LazGio2_library name 'g_dbus_auth_observer_new';
function g_dbus_connection_add_filter(connection: PGDBusConnection; filter_function: TGDBusMessageFilterFunction; user_data: gpointer; user_data_free_func: TGDestroyNotify): guint; cdecl; external LazGio2_library name 'g_dbus_connection_add_filter';
function g_dbus_connection_call_finish(connection: PGDBusConnection; res: PGAsyncResult; error: PPGError): PGVariant; cdecl; external LazGio2_library name 'g_dbus_connection_call_finish';
function g_dbus_connection_call_sync(connection: PGDBusConnection; bus_name: Pgchar; object_path: Pgchar; interface_name: Pgchar; method_name: Pgchar; parameters: PGVariant; reply_type: PGVariantType; flags: TGDBusCallFlags; timeout_msec: gint; cancellable: PGCancellable; error: PPGError): PGVariant; cdecl; external LazGio2_library name 'g_dbus_connection_call_sync';
function g_dbus_connection_call_with_unix_fd_list_finish(connection: PGDBusConnection; out_fd_list: PPGUnixFDList; res: PGAsyncResult; error: PPGError): PGVariant; cdecl; external LazGio2_library name 'g_dbus_connection_call_with_unix_fd_list_finish';
function g_dbus_connection_call_with_unix_fd_list_sync(connection: PGDBusConnection; bus_name: Pgchar; object_path: Pgchar; interface_name: Pgchar; method_name: Pgchar; parameters: PGVariant; reply_type: PGVariantType; flags: TGDBusCallFlags; timeout_msec: gint; fd_list: PGUnixFDList; out_fd_list: PPGUnixFDList; cancellable: PGCancellable; error: PPGError): PGVariant; cdecl; external LazGio2_library name 'g_dbus_connection_call_with_unix_fd_list_sync';
function g_dbus_connection_close_finish(connection: PGDBusConnection; res: PGAsyncResult; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_dbus_connection_close_finish';
function g_dbus_connection_close_sync(connection: PGDBusConnection; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_dbus_connection_close_sync';
function g_dbus_connection_emit_signal(connection: PGDBusConnection; destination_bus_name: Pgchar; object_path: Pgchar; interface_name: Pgchar; signal_name: Pgchar; parameters: PGVariant; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_dbus_connection_emit_signal';
function g_dbus_connection_export_action_group(connection: PGDBusConnection; object_path: Pgchar; action_group: PGActionGroup; error: PPGError): guint; cdecl; external LazGio2_library name 'g_dbus_connection_export_action_group';
function g_dbus_connection_export_menu_model(connection: PGDBusConnection; object_path: Pgchar; menu: PGMenuModel; error: PPGError): guint; cdecl; external LazGio2_library name 'g_dbus_connection_export_menu_model';
function g_dbus_connection_flush_finish(connection: PGDBusConnection; res: PGAsyncResult; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_dbus_connection_flush_finish';
function g_dbus_connection_flush_sync(connection: PGDBusConnection; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_dbus_connection_flush_sync';
function g_dbus_connection_get_capabilities(connection: PGDBusConnection): TGDBusCapabilityFlags; cdecl; external LazGio2_library name 'g_dbus_connection_get_capabilities';
function g_dbus_connection_get_exit_on_close(connection: PGDBusConnection): gboolean; cdecl; external LazGio2_library name 'g_dbus_connection_get_exit_on_close';
function g_dbus_connection_get_flags(connection: PGDBusConnection): TGDBusConnectionFlags; cdecl; external LazGio2_library name 'g_dbus_connection_get_flags';
function g_dbus_connection_get_guid(connection: PGDBusConnection): Pgchar; cdecl; external LazGio2_library name 'g_dbus_connection_get_guid';
function g_dbus_connection_get_last_serial(connection: PGDBusConnection): guint32; cdecl; external LazGio2_library name 'g_dbus_connection_get_last_serial';
function g_dbus_connection_get_peer_credentials(connection: PGDBusConnection): PGCredentials; cdecl; external LazGio2_library name 'g_dbus_connection_get_peer_credentials';
function g_dbus_connection_get_stream(connection: PGDBusConnection): PGIOStream; cdecl; external LazGio2_library name 'g_dbus_connection_get_stream';
function g_dbus_connection_get_type: TGType; cdecl; external LazGio2_library name 'g_dbus_connection_get_type';
function g_dbus_connection_get_unique_name(connection: PGDBusConnection): Pgchar; cdecl; external LazGio2_library name 'g_dbus_connection_get_unique_name';
function g_dbus_connection_is_closed(connection: PGDBusConnection): gboolean; cdecl; external LazGio2_library name 'g_dbus_connection_is_closed';
function g_dbus_connection_new_finish(res: PGAsyncResult; error: PPGError): PGDBusConnection; cdecl; external LazGio2_library name 'g_dbus_connection_new_finish';
function g_dbus_connection_new_for_address_finish(res: PGAsyncResult; error: PPGError): PGDBusConnection; cdecl; external LazGio2_library name 'g_dbus_connection_new_for_address_finish';
function g_dbus_connection_new_for_address_sync(address: Pgchar; flags: TGDBusConnectionFlags; observer: PGDBusAuthObserver; cancellable: PGCancellable; error: PPGError): PGDBusConnection; cdecl; external LazGio2_library name 'g_dbus_connection_new_for_address_sync';
function g_dbus_connection_new_sync(stream: PGIOStream; guid: Pgchar; flags: TGDBusConnectionFlags; observer: PGDBusAuthObserver; cancellable: PGCancellable; error: PPGError): PGDBusConnection; cdecl; external LazGio2_library name 'g_dbus_connection_new_sync';
function g_dbus_connection_register_object(connection: PGDBusConnection; object_path: Pgchar; interface_info: PGDBusInterfaceInfo; vtable: PGDBusInterfaceVTable; user_data: gpointer; user_data_free_func: TGDestroyNotify; error: PPGError): guint; cdecl; external LazGio2_library name 'g_dbus_connection_register_object';
function g_dbus_connection_register_object_with_closures(connection: PGDBusConnection; object_path: Pgchar; interface_info: PGDBusInterfaceInfo; method_call_closure: PGClosure; get_property_closure: PGClosure; set_property_closure: PGClosure; error: PPGError): guint; cdecl; external LazGio2_library name 'g_dbus_connection_register_object_with_closures';
function g_dbus_connection_register_subtree(connection: PGDBusConnection; object_path: Pgchar; vtable: PGDBusSubtreeVTable; flags: TGDBusSubtreeFlags; user_data: gpointer; user_data_free_func: TGDestroyNotify; error: PPGError): guint; cdecl; external LazGio2_library name 'g_dbus_connection_register_subtree';
function g_dbus_connection_send_message(connection: PGDBusConnection; message: PGDBusMessage; flags: TGDBusSendMessageFlags; out_serial: Pguint32; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_dbus_connection_send_message';
function g_dbus_connection_send_message_with_reply_finish(connection: PGDBusConnection; res: PGAsyncResult; error: PPGError): PGDBusMessage; cdecl; external LazGio2_library name 'g_dbus_connection_send_message_with_reply_finish';
function g_dbus_connection_send_message_with_reply_sync(connection: PGDBusConnection; message: PGDBusMessage; flags: TGDBusSendMessageFlags; timeout_msec: gint; out_serial: Pguint32; cancellable: PGCancellable; error: PPGError): PGDBusMessage; cdecl; external LazGio2_library name 'g_dbus_connection_send_message_with_reply_sync';
function g_dbus_connection_signal_subscribe(connection: PGDBusConnection; sender: Pgchar; interface_name: Pgchar; member: Pgchar; object_path: Pgchar; arg0: Pgchar; flags: TGDBusSignalFlags; callback: TGDBusSignalCallback; user_data: gpointer; user_data_free_func: TGDestroyNotify): guint; cdecl; external LazGio2_library name 'g_dbus_connection_signal_subscribe';
function g_dbus_connection_unregister_object(connection: PGDBusConnection; registration_id: guint): gboolean; cdecl; external LazGio2_library name 'g_dbus_connection_unregister_object';
function g_dbus_connection_unregister_subtree(connection: PGDBusConnection; registration_id: guint): gboolean; cdecl; external LazGio2_library name 'g_dbus_connection_unregister_subtree';
function g_dbus_error_encode_gerror(error: PGError): Pgchar; cdecl; external LazGio2_library name 'g_dbus_error_encode_gerror';
function g_dbus_error_get_remote_error(error: PGError): Pgchar; cdecl; external LazGio2_library name 'g_dbus_error_get_remote_error';
function g_dbus_error_is_remote_error(error: PGError): gboolean; cdecl; external LazGio2_library name 'g_dbus_error_is_remote_error';
function g_dbus_error_new_for_dbus_error(dbus_error_name: Pgchar; dbus_error_message: Pgchar): PGError; cdecl; external LazGio2_library name 'g_dbus_error_new_for_dbus_error';
function g_dbus_error_quark: TGQuark; cdecl; external LazGio2_library name 'g_dbus_error_quark';
function g_dbus_error_register_error(error_domain: TGQuark; error_code: gint; dbus_error_name: Pgchar): gboolean; cdecl; external LazGio2_library name 'g_dbus_error_register_error';
function g_dbus_error_strip_remote_error(error: PGError): gboolean; cdecl; external LazGio2_library name 'g_dbus_error_strip_remote_error';
function g_dbus_error_unregister_error(error_domain: TGQuark; error_code: gint; dbus_error_name: Pgchar): gboolean; cdecl; external LazGio2_library name 'g_dbus_error_unregister_error';
function g_dbus_generate_guid: Pgchar; cdecl; external LazGio2_library name 'g_dbus_generate_guid';
function g_dbus_gvalue_to_gvariant(gvalue: PGValue; type_: PGVariantType): PGVariant; cdecl; external LazGio2_library name 'g_dbus_gvalue_to_gvariant';
function g_dbus_interface_dup_object(interface_: PGDBusInterface): PGDBusObject; cdecl; external LazGio2_library name 'g_dbus_interface_dup_object';
function g_dbus_interface_get_info(interface_: PGDBusInterface): PGDBusInterfaceInfo; cdecl; external LazGio2_library name 'g_dbus_interface_get_info';
function g_dbus_interface_get_object(interface_: PGDBusInterface): PGDBusObject; cdecl; external LazGio2_library name 'g_dbus_interface_get_object';
function g_dbus_interface_get_type: TGType; cdecl; external LazGio2_library name 'g_dbus_interface_get_type';
function g_dbus_interface_info_get_type: TGType; cdecl; external LazGio2_library name 'g_dbus_interface_info_get_type';
function g_dbus_interface_info_lookup_method(info: PGDBusInterfaceInfo; name: Pgchar): PGDBusMethodInfo; cdecl; external LazGio2_library name 'g_dbus_interface_info_lookup_method';
function g_dbus_interface_info_lookup_property(info: PGDBusInterfaceInfo; name: Pgchar): PGDBusPropertyInfo; cdecl; external LazGio2_library name 'g_dbus_interface_info_lookup_property';
function g_dbus_interface_info_lookup_signal(info: PGDBusInterfaceInfo; name: Pgchar): PGDBusSignalInfo; cdecl; external LazGio2_library name 'g_dbus_interface_info_lookup_signal';
function g_dbus_interface_info_ref(info: PGDBusInterfaceInfo): PGDBusInterfaceInfo; cdecl; external LazGio2_library name 'g_dbus_interface_info_ref';
function g_dbus_interface_skeleton_export(interface_: PGDBusInterfaceSkeleton; connection: PGDBusConnection; object_path: Pgchar; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_dbus_interface_skeleton_export';
function g_dbus_interface_skeleton_get_connection(interface_: PGDBusInterfaceSkeleton): PGDBusConnection; cdecl; external LazGio2_library name 'g_dbus_interface_skeleton_get_connection';
function g_dbus_interface_skeleton_get_connections(interface_: PGDBusInterfaceSkeleton): PGList; cdecl; external LazGio2_library name 'g_dbus_interface_skeleton_get_connections';
function g_dbus_interface_skeleton_get_flags(interface_: PGDBusInterfaceSkeleton): TGDBusInterfaceSkeletonFlags; cdecl; external LazGio2_library name 'g_dbus_interface_skeleton_get_flags';
function g_dbus_interface_skeleton_get_info(interface_: PGDBusInterfaceSkeleton): PGDBusInterfaceInfo; cdecl; external LazGio2_library name 'g_dbus_interface_skeleton_get_info';
function g_dbus_interface_skeleton_get_object_path(interface_: PGDBusInterfaceSkeleton): Pgchar; cdecl; external LazGio2_library name 'g_dbus_interface_skeleton_get_object_path';
function g_dbus_interface_skeleton_get_properties(interface_: PGDBusInterfaceSkeleton): PGVariant; cdecl; external LazGio2_library name 'g_dbus_interface_skeleton_get_properties';
function g_dbus_interface_skeleton_get_type: TGType; cdecl; external LazGio2_library name 'g_dbus_interface_skeleton_get_type';
function g_dbus_interface_skeleton_get_vtable(interface_: PGDBusInterfaceSkeleton): PGDBusInterfaceVTable; cdecl; external LazGio2_library name 'g_dbus_interface_skeleton_get_vtable';
function g_dbus_interface_skeleton_has_connection(interface_: PGDBusInterfaceSkeleton; connection: PGDBusConnection): gboolean; cdecl; external LazGio2_library name 'g_dbus_interface_skeleton_has_connection';
function g_dbus_is_address(string_: Pgchar): gboolean; cdecl; external LazGio2_library name 'g_dbus_is_address';
function g_dbus_is_guid(string_: Pgchar): gboolean; cdecl; external LazGio2_library name 'g_dbus_is_guid';
function g_dbus_is_interface_name(string_: Pgchar): gboolean; cdecl; external LazGio2_library name 'g_dbus_is_interface_name';
function g_dbus_is_member_name(string_: Pgchar): gboolean; cdecl; external LazGio2_library name 'g_dbus_is_member_name';
function g_dbus_is_name(string_: Pgchar): gboolean; cdecl; external LazGio2_library name 'g_dbus_is_name';
function g_dbus_is_supported_address(string_: Pgchar; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_dbus_is_supported_address';
function g_dbus_is_unique_name(string_: Pgchar): gboolean; cdecl; external LazGio2_library name 'g_dbus_is_unique_name';
function g_dbus_menu_model_get(connection: PGDBusConnection; bus_name: Pgchar; object_path: Pgchar): PGDBusMenuModel; cdecl; external LazGio2_library name 'g_dbus_menu_model_get';
function g_dbus_menu_model_get_type: TGType; cdecl; external LazGio2_library name 'g_dbus_menu_model_get_type';
function g_dbus_message_bytes_needed(blob: Pguint8; blob_len: gsize; error: PPGError): gssize; cdecl; external LazGio2_library name 'g_dbus_message_bytes_needed';
function g_dbus_message_copy(message: PGDBusMessage; error: PPGError): PGDBusMessage; cdecl; external LazGio2_library name 'g_dbus_message_copy';
function g_dbus_message_get_arg0(message: PGDBusMessage): Pgchar; cdecl; external LazGio2_library name 'g_dbus_message_get_arg0';
function g_dbus_message_get_body(message: PGDBusMessage): PGVariant; cdecl; external LazGio2_library name 'g_dbus_message_get_body';
function g_dbus_message_get_byte_order(message: PGDBusMessage): TGDBusMessageByteOrder; cdecl; external LazGio2_library name 'g_dbus_message_get_byte_order';
function g_dbus_message_get_destination(message: PGDBusMessage): Pgchar; cdecl; external LazGio2_library name 'g_dbus_message_get_destination';
function g_dbus_message_get_error_name(message: PGDBusMessage): Pgchar; cdecl; external LazGio2_library name 'g_dbus_message_get_error_name';
function g_dbus_message_get_flags(message: PGDBusMessage): TGDBusMessageFlags; cdecl; external LazGio2_library name 'g_dbus_message_get_flags';
function g_dbus_message_get_header(message: PGDBusMessage; header_field: TGDBusMessageHeaderField): PGVariant; cdecl; external LazGio2_library name 'g_dbus_message_get_header';
function g_dbus_message_get_header_fields(message: PGDBusMessage): Pguint8; cdecl; external LazGio2_library name 'g_dbus_message_get_header_fields';
function g_dbus_message_get_interface(message: PGDBusMessage): Pgchar; cdecl; external LazGio2_library name 'g_dbus_message_get_interface';
function g_dbus_message_get_locked(message: PGDBusMessage): gboolean; cdecl; external LazGio2_library name 'g_dbus_message_get_locked';
function g_dbus_message_get_member(message: PGDBusMessage): Pgchar; cdecl; external LazGio2_library name 'g_dbus_message_get_member';
function g_dbus_message_get_message_type(message: PGDBusMessage): TGDBusMessageType; cdecl; external LazGio2_library name 'g_dbus_message_get_message_type';
function g_dbus_message_get_num_unix_fds(message: PGDBusMessage): guint32; cdecl; external LazGio2_library name 'g_dbus_message_get_num_unix_fds';
function g_dbus_message_get_path(message: PGDBusMessage): Pgchar; cdecl; external LazGio2_library name 'g_dbus_message_get_path';
function g_dbus_message_get_reply_serial(message: PGDBusMessage): guint32; cdecl; external LazGio2_library name 'g_dbus_message_get_reply_serial';
function g_dbus_message_get_sender(message: PGDBusMessage): Pgchar; cdecl; external LazGio2_library name 'g_dbus_message_get_sender';
function g_dbus_message_get_serial(message: PGDBusMessage): guint32; cdecl; external LazGio2_library name 'g_dbus_message_get_serial';
function g_dbus_message_get_signature(message: PGDBusMessage): Pgchar; cdecl; external LazGio2_library name 'g_dbus_message_get_signature';
function g_dbus_message_get_type: TGType; cdecl; external LazGio2_library name 'g_dbus_message_get_type';
function g_dbus_message_get_unix_fd_list(message: PGDBusMessage): PGUnixFDList; cdecl; external LazGio2_library name 'g_dbus_message_get_unix_fd_list';
function g_dbus_message_new: PGDBusMessage; cdecl; external LazGio2_library name 'g_dbus_message_new';
function g_dbus_message_new_from_blob(blob: Pguint8; blob_len: gsize; capabilities: TGDBusCapabilityFlags; error: PPGError): PGDBusMessage; cdecl; external LazGio2_library name 'g_dbus_message_new_from_blob';
function g_dbus_message_new_method_call(name: Pgchar; path: Pgchar; interface_: Pgchar; method: Pgchar): PGDBusMessage; cdecl; external LazGio2_library name 'g_dbus_message_new_method_call';
function g_dbus_message_new_method_error(method_call_message: PGDBusMessage; error_name: Pgchar; error_message_format: Pgchar; args: array of const): PGDBusMessage; cdecl; external LazGio2_library name 'g_dbus_message_new_method_error';
function g_dbus_message_new_method_error_literal(method_call_message: PGDBusMessage; error_name: Pgchar; error_message: Pgchar): PGDBusMessage; cdecl; external LazGio2_library name 'g_dbus_message_new_method_error_literal';
function g_dbus_message_new_method_error_valist(method_call_message: PGDBusMessage; error_name: Pgchar; error_message_format: Pgchar; var_args: Tva_list): PGDBusMessage; cdecl; external LazGio2_library name 'g_dbus_message_new_method_error_valist';
function g_dbus_message_new_method_reply(method_call_message: PGDBusMessage): PGDBusMessage; cdecl; external LazGio2_library name 'g_dbus_message_new_method_reply';
function g_dbus_message_new_signal(path: Pgchar; interface_: Pgchar; signal: Pgchar): PGDBusMessage; cdecl; external LazGio2_library name 'g_dbus_message_new_signal';
function g_dbus_message_print(message: PGDBusMessage; indent: guint): Pgchar; cdecl; external LazGio2_library name 'g_dbus_message_print';
function g_dbus_message_to_blob(message: PGDBusMessage; out_size: Pgsize; capabilities: TGDBusCapabilityFlags; error: PPGError): Pguint8; cdecl; external LazGio2_library name 'g_dbus_message_to_blob';
function g_dbus_message_to_gerror(message: PGDBusMessage; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_dbus_message_to_gerror';
function g_dbus_method_info_get_type: TGType; cdecl; external LazGio2_library name 'g_dbus_method_info_get_type';
function g_dbus_method_info_ref(info: PGDBusMethodInfo): PGDBusMethodInfo; cdecl; external LazGio2_library name 'g_dbus_method_info_ref';
function g_dbus_method_invocation_get_connection(invocation: PGDBusMethodInvocation): PGDBusConnection; cdecl; external LazGio2_library name 'g_dbus_method_invocation_get_connection';
function g_dbus_method_invocation_get_interface_name(invocation: PGDBusMethodInvocation): Pgchar; cdecl; external LazGio2_library name 'g_dbus_method_invocation_get_interface_name';
function g_dbus_method_invocation_get_message(invocation: PGDBusMethodInvocation): PGDBusMessage; cdecl; external LazGio2_library name 'g_dbus_method_invocation_get_message';
function g_dbus_method_invocation_get_method_info(invocation: PGDBusMethodInvocation): PGDBusMethodInfo; cdecl; external LazGio2_library name 'g_dbus_method_invocation_get_method_info';
function g_dbus_method_invocation_get_method_name(invocation: PGDBusMethodInvocation): Pgchar; cdecl; external LazGio2_library name 'g_dbus_method_invocation_get_method_name';
function g_dbus_method_invocation_get_object_path(invocation: PGDBusMethodInvocation): Pgchar; cdecl; external LazGio2_library name 'g_dbus_method_invocation_get_object_path';
function g_dbus_method_invocation_get_parameters(invocation: PGDBusMethodInvocation): PGVariant; cdecl; external LazGio2_library name 'g_dbus_method_invocation_get_parameters';
function g_dbus_method_invocation_get_property_info(invocation: PGDBusMethodInvocation): PGDBusPropertyInfo; cdecl; external LazGio2_library name 'g_dbus_method_invocation_get_property_info';
function g_dbus_method_invocation_get_sender(invocation: PGDBusMethodInvocation): Pgchar; cdecl; external LazGio2_library name 'g_dbus_method_invocation_get_sender';
function g_dbus_method_invocation_get_type: TGType; cdecl; external LazGio2_library name 'g_dbus_method_invocation_get_type';
function g_dbus_method_invocation_get_user_data(invocation: PGDBusMethodInvocation): gpointer; cdecl; external LazGio2_library name 'g_dbus_method_invocation_get_user_data';
function g_dbus_node_info_get_type: TGType; cdecl; external LazGio2_library name 'g_dbus_node_info_get_type';
function g_dbus_node_info_lookup_interface(info: PGDBusNodeInfo; name: Pgchar): PGDBusInterfaceInfo; cdecl; external LazGio2_library name 'g_dbus_node_info_lookup_interface';
function g_dbus_node_info_new_for_xml(xml_data: Pgchar; error: PPGError): PGDBusNodeInfo; cdecl; external LazGio2_library name 'g_dbus_node_info_new_for_xml';
function g_dbus_node_info_ref(info: PGDBusNodeInfo): PGDBusNodeInfo; cdecl; external LazGio2_library name 'g_dbus_node_info_ref';
function g_dbus_object_get_interface(object_: PGDBusObject; interface_name: Pgchar): PGDBusInterface; cdecl; external LazGio2_library name 'g_dbus_object_get_interface';
function g_dbus_object_get_interfaces(object_: PGDBusObject): PGList; cdecl; external LazGio2_library name 'g_dbus_object_get_interfaces';
function g_dbus_object_get_object_path(object_: PGDBusObject): Pgchar; cdecl; external LazGio2_library name 'g_dbus_object_get_object_path';
function g_dbus_object_get_type: TGType; cdecl; external LazGio2_library name 'g_dbus_object_get_type';
function g_dbus_object_manager_client_get_connection(manager: PGDBusObjectManagerClient): PGDBusConnection; cdecl; external LazGio2_library name 'g_dbus_object_manager_client_get_connection';
function g_dbus_object_manager_client_get_flags(manager: PGDBusObjectManagerClient): TGDBusObjectManagerClientFlags; cdecl; external LazGio2_library name 'g_dbus_object_manager_client_get_flags';
function g_dbus_object_manager_client_get_name(manager: PGDBusObjectManagerClient): Pgchar; cdecl; external LazGio2_library name 'g_dbus_object_manager_client_get_name';
function g_dbus_object_manager_client_get_name_owner(manager: PGDBusObjectManagerClient): Pgchar; cdecl; external LazGio2_library name 'g_dbus_object_manager_client_get_name_owner';
function g_dbus_object_manager_client_get_type: TGType; cdecl; external LazGio2_library name 'g_dbus_object_manager_client_get_type';
function g_dbus_object_manager_client_new_finish(res: PGAsyncResult; error: PPGError): PGDBusObjectManagerClient; cdecl; external LazGio2_library name 'g_dbus_object_manager_client_new_finish';
function g_dbus_object_manager_client_new_for_bus_finish(res: PGAsyncResult; error: PPGError): PGDBusObjectManagerClient; cdecl; external LazGio2_library name 'g_dbus_object_manager_client_new_for_bus_finish';
function g_dbus_object_manager_client_new_for_bus_sync(bus_type: TGBusType; flags: TGDBusObjectManagerClientFlags; name: Pgchar; object_path: Pgchar; get_proxy_type_func: TGDBusProxyTypeFunc; get_proxy_type_user_data: gpointer; get_proxy_type_destroy_notify: TGDestroyNotify; cancellable: PGCancellable; error: PPGError): PGDBusObjectManagerClient; cdecl; external LazGio2_library name 'g_dbus_object_manager_client_new_for_bus_sync';
function g_dbus_object_manager_client_new_sync(connection: PGDBusConnection; flags: TGDBusObjectManagerClientFlags; name: Pgchar; object_path: Pgchar; get_proxy_type_func: TGDBusProxyTypeFunc; get_proxy_type_user_data: gpointer; get_proxy_type_destroy_notify: TGDestroyNotify; cancellable: PGCancellable; error: PPGError): PGDBusObjectManagerClient; cdecl; external LazGio2_library name 'g_dbus_object_manager_client_new_sync';
function g_dbus_object_manager_get_interface(manager: PGDBusObjectManager; object_path: Pgchar; interface_name: Pgchar): PGDBusInterface; cdecl; external LazGio2_library name 'g_dbus_object_manager_get_interface';
function g_dbus_object_manager_get_object(manager: PGDBusObjectManager; object_path: Pgchar): PGDBusObject; cdecl; external LazGio2_library name 'g_dbus_object_manager_get_object';
function g_dbus_object_manager_get_object_path(manager: PGDBusObjectManager): Pgchar; cdecl; external LazGio2_library name 'g_dbus_object_manager_get_object_path';
function g_dbus_object_manager_get_objects(manager: PGDBusObjectManager): PGList; cdecl; external LazGio2_library name 'g_dbus_object_manager_get_objects';
function g_dbus_object_manager_get_type: TGType; cdecl; external LazGio2_library name 'g_dbus_object_manager_get_type';
function g_dbus_object_manager_server_get_connection(manager: PGDBusObjectManagerServer): PGDBusConnection; cdecl; external LazGio2_library name 'g_dbus_object_manager_server_get_connection';
function g_dbus_object_manager_server_get_type: TGType; cdecl; external LazGio2_library name 'g_dbus_object_manager_server_get_type';
function g_dbus_object_manager_server_is_exported(manager: PGDBusObjectManagerServer; object_: PGDBusObjectSkeleton): gboolean; cdecl; external LazGio2_library name 'g_dbus_object_manager_server_is_exported';
function g_dbus_object_manager_server_new(object_path: Pgchar): PGDBusObjectManagerServer; cdecl; external LazGio2_library name 'g_dbus_object_manager_server_new';
function g_dbus_object_manager_server_unexport(manager: PGDBusObjectManagerServer; object_path: Pgchar): gboolean; cdecl; external LazGio2_library name 'g_dbus_object_manager_server_unexport';
function g_dbus_object_proxy_get_connection(proxy: PGDBusObjectProxy): PGDBusConnection; cdecl; external LazGio2_library name 'g_dbus_object_proxy_get_connection';
function g_dbus_object_proxy_get_type: TGType; cdecl; external LazGio2_library name 'g_dbus_object_proxy_get_type';
function g_dbus_object_proxy_new(connection: PGDBusConnection; object_path: Pgchar): PGDBusObjectProxy; cdecl; external LazGio2_library name 'g_dbus_object_proxy_new';
function g_dbus_object_skeleton_get_type: TGType; cdecl; external LazGio2_library name 'g_dbus_object_skeleton_get_type';
function g_dbus_object_skeleton_new(object_path: Pgchar): PGDBusObjectSkeleton; cdecl; external LazGio2_library name 'g_dbus_object_skeleton_new';
function g_dbus_property_info_get_type: TGType; cdecl; external LazGio2_library name 'g_dbus_property_info_get_type';
function g_dbus_property_info_ref(info: PGDBusPropertyInfo): PGDBusPropertyInfo; cdecl; external LazGio2_library name 'g_dbus_property_info_ref';
function g_dbus_proxy_call_finish(proxy: PGDBusProxy; res: PGAsyncResult; error: PPGError): PGVariant; cdecl; external LazGio2_library name 'g_dbus_proxy_call_finish';
function g_dbus_proxy_call_sync(proxy: PGDBusProxy; method_name: Pgchar; parameters: PGVariant; flags: TGDBusCallFlags; timeout_msec: gint; cancellable: PGCancellable; error: PPGError): PGVariant; cdecl; external LazGio2_library name 'g_dbus_proxy_call_sync';
function g_dbus_proxy_call_with_unix_fd_list_finish(proxy: PGDBusProxy; out_fd_list: PPGUnixFDList; res: PGAsyncResult; error: PPGError): PGVariant; cdecl; external LazGio2_library name 'g_dbus_proxy_call_with_unix_fd_list_finish';
function g_dbus_proxy_call_with_unix_fd_list_sync(proxy: PGDBusProxy; method_name: Pgchar; parameters: PGVariant; flags: TGDBusCallFlags; timeout_msec: gint; fd_list: PGUnixFDList; out_fd_list: PPGUnixFDList; cancellable: PGCancellable; error: PPGError): PGVariant; cdecl; external LazGio2_library name 'g_dbus_proxy_call_with_unix_fd_list_sync';
function g_dbus_proxy_get_cached_property(proxy: PGDBusProxy; property_name: Pgchar): PGVariant; cdecl; external LazGio2_library name 'g_dbus_proxy_get_cached_property';
function g_dbus_proxy_get_cached_property_names(proxy: PGDBusProxy): PPgchar; cdecl; external LazGio2_library name 'g_dbus_proxy_get_cached_property_names';
function g_dbus_proxy_get_connection(proxy: PGDBusProxy): PGDBusConnection; cdecl; external LazGio2_library name 'g_dbus_proxy_get_connection';
function g_dbus_proxy_get_default_timeout(proxy: PGDBusProxy): gint; cdecl; external LazGio2_library name 'g_dbus_proxy_get_default_timeout';
function g_dbus_proxy_get_flags(proxy: PGDBusProxy): TGDBusProxyFlags; cdecl; external LazGio2_library name 'g_dbus_proxy_get_flags';
function g_dbus_proxy_get_interface_info(proxy: PGDBusProxy): PGDBusInterfaceInfo; cdecl; external LazGio2_library name 'g_dbus_proxy_get_interface_info';
function g_dbus_proxy_get_interface_name(proxy: PGDBusProxy): Pgchar; cdecl; external LazGio2_library name 'g_dbus_proxy_get_interface_name';
function g_dbus_proxy_get_name(proxy: PGDBusProxy): Pgchar; cdecl; external LazGio2_library name 'g_dbus_proxy_get_name';
function g_dbus_proxy_get_name_owner(proxy: PGDBusProxy): Pgchar; cdecl; external LazGio2_library name 'g_dbus_proxy_get_name_owner';
function g_dbus_proxy_get_object_path(proxy: PGDBusProxy): Pgchar; cdecl; external LazGio2_library name 'g_dbus_proxy_get_object_path';
function g_dbus_proxy_get_type: TGType; cdecl; external LazGio2_library name 'g_dbus_proxy_get_type';
function g_dbus_proxy_new_finish(res: PGAsyncResult; error: PPGError): PGDBusProxy; cdecl; external LazGio2_library name 'g_dbus_proxy_new_finish';
function g_dbus_proxy_new_for_bus_finish(res: PGAsyncResult; error: PPGError): PGDBusProxy; cdecl; external LazGio2_library name 'g_dbus_proxy_new_for_bus_finish';
function g_dbus_proxy_new_for_bus_sync(bus_type: TGBusType; flags: TGDBusProxyFlags; info: PGDBusInterfaceInfo; name: Pgchar; object_path: Pgchar; interface_name: Pgchar; cancellable: PGCancellable; error: PPGError): PGDBusProxy; cdecl; external LazGio2_library name 'g_dbus_proxy_new_for_bus_sync';
function g_dbus_proxy_new_sync(connection: PGDBusConnection; flags: TGDBusProxyFlags; info: PGDBusInterfaceInfo; name: Pgchar; object_path: Pgchar; interface_name: Pgchar; cancellable: PGCancellable; error: PPGError): PGDBusProxy; cdecl; external LazGio2_library name 'g_dbus_proxy_new_sync';
function g_dbus_server_get_client_address(server: PGDBusServer): Pgchar; cdecl; external LazGio2_library name 'g_dbus_server_get_client_address';
function g_dbus_server_get_flags(server: PGDBusServer): TGDBusServerFlags; cdecl; external LazGio2_library name 'g_dbus_server_get_flags';
function g_dbus_server_get_guid(server: PGDBusServer): Pgchar; cdecl; external LazGio2_library name 'g_dbus_server_get_guid';
function g_dbus_server_get_type: TGType; cdecl; external LazGio2_library name 'g_dbus_server_get_type';
function g_dbus_server_is_active(server: PGDBusServer): gboolean; cdecl; external LazGio2_library name 'g_dbus_server_is_active';
function g_dbus_server_new_sync(address: Pgchar; flags: TGDBusServerFlags; guid: Pgchar; observer: PGDBusAuthObserver; cancellable: PGCancellable; error: PPGError): PGDBusServer; cdecl; external LazGio2_library name 'g_dbus_server_new_sync';
function g_dbus_signal_info_get_type: TGType; cdecl; external LazGio2_library name 'g_dbus_signal_info_get_type';
function g_dbus_signal_info_ref(info: PGDBusSignalInfo): PGDBusSignalInfo; cdecl; external LazGio2_library name 'g_dbus_signal_info_ref';
function g_desktop_app_info_get_action_name(info: PGDesktopAppInfo; action_name: Pgchar): Pgchar; cdecl; external LazGio2_library name 'g_desktop_app_info_get_action_name';
function g_desktop_app_info_get_boolean(info: PGDesktopAppInfo; key: Pgchar): gboolean; cdecl; external LazGio2_library name 'g_desktop_app_info_get_boolean';
function g_desktop_app_info_get_categories(info: PGDesktopAppInfo): Pgchar; cdecl; external LazGio2_library name 'g_desktop_app_info_get_categories';
function g_desktop_app_info_get_filename(info: PGDesktopAppInfo): Pgchar; cdecl; external LazGio2_library name 'g_desktop_app_info_get_filename';
function g_desktop_app_info_get_generic_name(info: PGDesktopAppInfo): Pgchar; cdecl; external LazGio2_library name 'g_desktop_app_info_get_generic_name';
function g_desktop_app_info_get_implementations(interface_: Pgchar): PGList; cdecl; external LazGio2_library name 'g_desktop_app_info_get_implementations';
function g_desktop_app_info_get_is_hidden(info: PGDesktopAppInfo): gboolean; cdecl; external LazGio2_library name 'g_desktop_app_info_get_is_hidden';
function g_desktop_app_info_get_keywords(info: PGDesktopAppInfo): PPgchar; cdecl; external LazGio2_library name 'g_desktop_app_info_get_keywords';
function g_desktop_app_info_get_locale_string(info: PGDesktopAppInfo; key: Pgchar): Pgchar; cdecl; external LazGio2_library name 'g_desktop_app_info_get_locale_string';
function g_desktop_app_info_get_nodisplay(info: PGDesktopAppInfo): gboolean; cdecl; external LazGio2_library name 'g_desktop_app_info_get_nodisplay';
function g_desktop_app_info_get_show_in(info: PGDesktopAppInfo; desktop_env: Pgchar): gboolean; cdecl; external LazGio2_library name 'g_desktop_app_info_get_show_in';
function g_desktop_app_info_get_startup_wm_class(info: PGDesktopAppInfo): Pgchar; cdecl; external LazGio2_library name 'g_desktop_app_info_get_startup_wm_class';
function g_desktop_app_info_get_string(info: PGDesktopAppInfo; key: Pgchar): Pgchar; cdecl; external LazGio2_library name 'g_desktop_app_info_get_string';
function g_desktop_app_info_get_string_list(info: PGDesktopAppInfo; key: Pgchar; length: Pgsize): PPgchar; cdecl; external LazGio2_library name 'g_desktop_app_info_get_string_list';
function g_desktop_app_info_get_type: TGType; cdecl; external LazGio2_library name 'g_desktop_app_info_get_type';
function g_desktop_app_info_has_key(info: PGDesktopAppInfo; key: Pgchar): gboolean; cdecl; external LazGio2_library name 'g_desktop_app_info_has_key';
function g_desktop_app_info_launch_uris_as_manager(appinfo: PGDesktopAppInfo; uris: PGList; launch_context: PGAppLaunchContext; spawn_flags: TGSpawnFlags; user_setup: TGSpawnChildSetupFunc; user_setup_data: gpointer; pid_callback: TGDesktopAppLaunchCallback; pid_callback_data: gpointer; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_desktop_app_info_launch_uris_as_manager';
function g_desktop_app_info_launch_uris_as_manager_with_fds(appinfo: PGDesktopAppInfo; uris: PGList; launch_context: PGAppLaunchContext; spawn_flags: TGSpawnFlags; user_setup: TGSpawnChildSetupFunc; user_setup_data: gpointer; pid_callback: TGDesktopAppLaunchCallback; pid_callback_data: gpointer; stdin_fd: gint; stdout_fd: gint; stderr_fd: gint; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_desktop_app_info_launch_uris_as_manager_with_fds';
function g_desktop_app_info_list_actions(info: PGDesktopAppInfo): PPgchar; cdecl; external LazGio2_library name 'g_desktop_app_info_list_actions';
function g_desktop_app_info_lookup_get_type: TGType; cdecl; external LazGio2_library name 'g_desktop_app_info_lookup_get_type';
function g_desktop_app_info_new(desktop_id: Pgchar): PGDesktopAppInfo; cdecl; external LazGio2_library name 'g_desktop_app_info_new';
function g_desktop_app_info_new_from_filename(filename: Pgchar): PGDesktopAppInfo; cdecl; external LazGio2_library name 'g_desktop_app_info_new_from_filename';
function g_desktop_app_info_new_from_keyfile(key_file: PGKeyFile): PGDesktopAppInfo; cdecl; external LazGio2_library name 'g_desktop_app_info_new_from_keyfile';
function g_desktop_app_info_search(search_string: Pgchar): PPPgchar; cdecl; external LazGio2_library name 'g_desktop_app_info_search';
function g_drive_can_eject(drive: PGDrive): gboolean; cdecl; external LazGio2_library name 'g_drive_can_eject';
function g_drive_can_poll_for_media(drive: PGDrive): gboolean; cdecl; external LazGio2_library name 'g_drive_can_poll_for_media';
function g_drive_can_start(drive: PGDrive): gboolean; cdecl; external LazGio2_library name 'g_drive_can_start';
function g_drive_can_start_degraded(drive: PGDrive): gboolean; cdecl; external LazGio2_library name 'g_drive_can_start_degraded';
function g_drive_can_stop(drive: PGDrive): gboolean; cdecl; external LazGio2_library name 'g_drive_can_stop';
function g_drive_eject_with_operation_finish(drive: PGDrive; result_: PGAsyncResult; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_drive_eject_with_operation_finish';
function g_drive_enumerate_identifiers(drive: PGDrive): PPgchar; cdecl; external LazGio2_library name 'g_drive_enumerate_identifiers';
function g_drive_get_icon(drive: PGDrive): PGIcon; cdecl; external LazGio2_library name 'g_drive_get_icon';
function g_drive_get_identifier(drive: PGDrive; kind: Pgchar): Pgchar; cdecl; external LazGio2_library name 'g_drive_get_identifier';
function g_drive_get_name(drive: PGDrive): Pgchar; cdecl; external LazGio2_library name 'g_drive_get_name';
function g_drive_get_sort_key(drive: PGDrive): Pgchar; cdecl; external LazGio2_library name 'g_drive_get_sort_key';
function g_drive_get_start_stop_type(drive: PGDrive): TGDriveStartStopType; cdecl; external LazGio2_library name 'g_drive_get_start_stop_type';
function g_drive_get_symbolic_icon(drive: PGDrive): PGIcon; cdecl; external LazGio2_library name 'g_drive_get_symbolic_icon';
function g_drive_get_type: TGType; cdecl; external LazGio2_library name 'g_drive_get_type';
function g_drive_get_volumes(drive: PGDrive): PGList; cdecl; external LazGio2_library name 'g_drive_get_volumes';
function g_drive_has_media(drive: PGDrive): gboolean; cdecl; external LazGio2_library name 'g_drive_has_media';
function g_drive_has_volumes(drive: PGDrive): gboolean; cdecl; external LazGio2_library name 'g_drive_has_volumes';
function g_drive_is_media_check_automatic(drive: PGDrive): gboolean; cdecl; external LazGio2_library name 'g_drive_is_media_check_automatic';
function g_drive_is_media_removable(drive: PGDrive): gboolean; cdecl; external LazGio2_library name 'g_drive_is_media_removable';
function g_drive_is_removable(drive: PGDrive): gboolean; cdecl; external LazGio2_library name 'g_drive_is_removable';
function g_drive_poll_for_media_finish(drive: PGDrive; result_: PGAsyncResult; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_drive_poll_for_media_finish';
function g_drive_start_finish(drive: PGDrive; result_: PGAsyncResult; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_drive_start_finish';
function g_drive_stop_finish(drive: PGDrive; result_: PGAsyncResult; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_drive_stop_finish';
function g_dtls_client_connection_get_accepted_cas(conn: PGDtlsClientConnection): PGList; cdecl; external LazGio2_library name 'g_dtls_client_connection_get_accepted_cas';
function g_dtls_client_connection_get_server_identity(conn: PGDtlsClientConnection): PGSocketConnectable; cdecl; external LazGio2_library name 'g_dtls_client_connection_get_server_identity';
function g_dtls_client_connection_get_type: TGType; cdecl; external LazGio2_library name 'g_dtls_client_connection_get_type';
function g_dtls_client_connection_get_validation_flags(conn: PGDtlsClientConnection): TGTlsCertificateFlags; cdecl; external LazGio2_library name 'g_dtls_client_connection_get_validation_flags'; deprecated 'Do not attempt to ignore validation errors.';
function g_dtls_client_connection_new(base_socket: PGDatagramBased; server_identity: PGSocketConnectable; error: PPGError): PGDtlsClientConnection; cdecl; external LazGio2_library name 'g_dtls_client_connection_new';
function g_dtls_connection_close(conn: PGDtlsConnection; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_dtls_connection_close';
function g_dtls_connection_close_finish(conn: PGDtlsConnection; result_: PGAsyncResult; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_dtls_connection_close_finish';
function g_dtls_connection_emit_accept_certificate(conn: PGDtlsConnection; peer_cert: PGTlsCertificate; errors: TGTlsCertificateFlags): gboolean; cdecl; external LazGio2_library name 'g_dtls_connection_emit_accept_certificate';
function g_dtls_connection_get_certificate(conn: PGDtlsConnection): PGTlsCertificate; cdecl; external LazGio2_library name 'g_dtls_connection_get_certificate';
{$IFDEF USEGTK3LATESTBINDINGS}
function g_dtls_connection_get_channel_binding_data(conn: PGDtlsConnection; type_: TGTlsChannelBindingType; data: Pguint8; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_dtls_connection_get_channel_binding_data';
{$ENDIF}
function g_dtls_connection_get_database(conn: PGDtlsConnection): PGTlsDatabase; cdecl; external LazGio2_library name 'g_dtls_connection_get_database';
function g_dtls_connection_get_interaction(conn: PGDtlsConnection): PGTlsInteraction; cdecl; external LazGio2_library name 'g_dtls_connection_get_interaction';
function g_dtls_connection_get_negotiated_protocol(conn: PGDtlsConnection): Pgchar; cdecl; external LazGio2_library name 'g_dtls_connection_get_negotiated_protocol';
function g_dtls_connection_get_peer_certificate(conn: PGDtlsConnection): PGTlsCertificate; cdecl; external LazGio2_library name 'g_dtls_connection_get_peer_certificate';
function g_dtls_connection_get_peer_certificate_errors(conn: PGDtlsConnection): TGTlsCertificateFlags; cdecl; external LazGio2_library name 'g_dtls_connection_get_peer_certificate_errors';
function g_dtls_connection_get_require_close_notify(conn: PGDtlsConnection): gboolean; cdecl; external LazGio2_library name 'g_dtls_connection_get_require_close_notify';
function g_dtls_connection_get_type: TGType; cdecl; external LazGio2_library name 'g_dtls_connection_get_type';
function g_dtls_connection_handshake(conn: PGDtlsConnection; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_dtls_connection_handshake';
function g_dtls_connection_handshake_finish(conn: PGDtlsConnection; result_: PGAsyncResult; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_dtls_connection_handshake_finish';
function g_dtls_connection_shutdown(conn: PGDtlsConnection; shutdown_read: gboolean; shutdown_write: gboolean; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_dtls_connection_shutdown';
function g_dtls_connection_shutdown_finish(conn: PGDtlsConnection; result_: PGAsyncResult; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_dtls_connection_shutdown_finish';
function g_dtls_server_connection_get_type: TGType; cdecl; external LazGio2_library name 'g_dtls_server_connection_get_type';
function g_dtls_server_connection_new(base_socket: PGDatagramBased; certificate: PGTlsCertificate; error: PPGError): PGDtlsServerConnection; cdecl; external LazGio2_library name 'g_dtls_server_connection_new';
function g_emblem_get_icon(emblem: PGEmblem): PGIcon; cdecl; external LazGio2_library name 'g_emblem_get_icon';
function g_emblem_get_origin(emblem: PGEmblem): TGEmblemOrigin; cdecl; external LazGio2_library name 'g_emblem_get_origin';
function g_emblem_get_type: TGType; cdecl; external LazGio2_library name 'g_emblem_get_type';
function g_emblem_new(icon: PGIcon): PGEmblem; cdecl; external LazGio2_library name 'g_emblem_new';
function g_emblem_new_with_origin(icon: PGIcon; origin: TGEmblemOrigin): PGEmblem; cdecl; external LazGio2_library name 'g_emblem_new_with_origin';
function g_emblemed_icon_get_emblems(emblemed: PGEmblemedIcon): PGList; cdecl; external LazGio2_library name 'g_emblemed_icon_get_emblems';
function g_emblemed_icon_get_icon(emblemed: PGEmblemedIcon): PGIcon; cdecl; external LazGio2_library name 'g_emblemed_icon_get_icon';
function g_emblemed_icon_get_type: TGType; cdecl; external LazGio2_library name 'g_emblemed_icon_get_type';
function g_emblemed_icon_new(icon: PGIcon; emblem: PGEmblem): PGEmblemedIcon; cdecl; external LazGio2_library name 'g_emblemed_icon_new';
function g_file_append_to(file_: PGFile; flags: TGFileCreateFlags; cancellable: PGCancellable; error: PPGError): PGFileOutputStream; cdecl; external LazGio2_library name 'g_file_append_to';
function g_file_append_to_finish(file_: PGFile; res: PGAsyncResult; error: PPGError): PGFileOutputStream; cdecl; external LazGio2_library name 'g_file_append_to_finish';
function g_file_attribute_info_list_dup(list: PGFileAttributeInfoList): PGFileAttributeInfoList; cdecl; external LazGio2_library name 'g_file_attribute_info_list_dup';
function g_file_attribute_info_list_get_type: TGType; cdecl; external LazGio2_library name 'g_file_attribute_info_list_get_type';
function g_file_attribute_info_list_lookup(list: PGFileAttributeInfoList; name: Pgchar): PGFileAttributeInfo; cdecl; external LazGio2_library name 'g_file_attribute_info_list_lookup';
function g_file_attribute_info_list_new: PGFileAttributeInfoList; cdecl; external LazGio2_library name 'g_file_attribute_info_list_new';
function g_file_attribute_info_list_ref(list: PGFileAttributeInfoList): PGFileAttributeInfoList; cdecl; external LazGio2_library name 'g_file_attribute_info_list_ref';
function g_file_attribute_matcher_enumerate_namespace(matcher: PGFileAttributeMatcher; ns: Pgchar): gboolean; cdecl; external LazGio2_library name 'g_file_attribute_matcher_enumerate_namespace';
function g_file_attribute_matcher_enumerate_next(matcher: PGFileAttributeMatcher): Pgchar; cdecl; external LazGio2_library name 'g_file_attribute_matcher_enumerate_next';
function g_file_attribute_matcher_get_type: TGType; cdecl; external LazGio2_library name 'g_file_attribute_matcher_get_type';
function g_file_attribute_matcher_matches(matcher: PGFileAttributeMatcher; attribute: Pgchar): gboolean; cdecl; external LazGio2_library name 'g_file_attribute_matcher_matches';
function g_file_attribute_matcher_matches_only(matcher: PGFileAttributeMatcher; attribute: Pgchar): gboolean; cdecl; external LazGio2_library name 'g_file_attribute_matcher_matches_only';
function g_file_attribute_matcher_new(attributes: Pgchar): PGFileAttributeMatcher; cdecl; external LazGio2_library name 'g_file_attribute_matcher_new';
function g_file_attribute_matcher_ref(matcher: PGFileAttributeMatcher): PGFileAttributeMatcher; cdecl; external LazGio2_library name 'g_file_attribute_matcher_ref';
function g_file_attribute_matcher_subtract(matcher: PGFileAttributeMatcher; subtract: PGFileAttributeMatcher): PGFileAttributeMatcher; cdecl; external LazGio2_library name 'g_file_attribute_matcher_subtract';
function g_file_attribute_matcher_to_string(matcher: PGFileAttributeMatcher): Pgchar; cdecl; external LazGio2_library name 'g_file_attribute_matcher_to_string';
function g_file_copy(source: PGFile; destination: PGFile; flags: TGFileCopyFlags; cancellable: PGCancellable; progress_callback: TGFileProgressCallback; progress_callback_data: gpointer; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_file_copy';
function g_file_copy_attributes(source: PGFile; destination: PGFile; flags: TGFileCopyFlags; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_file_copy_attributes';
function g_file_copy_finish(file_: PGFile; res: PGAsyncResult; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_file_copy_finish';
function g_file_create(file_: PGFile; flags: TGFileCreateFlags; cancellable: PGCancellable; error: PPGError): PGFileOutputStream; cdecl; external LazGio2_library name 'g_file_create';
function g_file_create_finish(file_: PGFile; res: PGAsyncResult; error: PPGError): PGFileOutputStream; cdecl; external LazGio2_library name 'g_file_create_finish';
function g_file_create_readwrite(file_: PGFile; flags: TGFileCreateFlags; cancellable: PGCancellable; error: PPGError): PGFileIOStream; cdecl; external LazGio2_library name 'g_file_create_readwrite';
function g_file_create_readwrite_finish(file_: PGFile; res: PGAsyncResult; error: PPGError): PGFileIOStream; cdecl; external LazGio2_library name 'g_file_create_readwrite_finish';
function g_file_delete(file_: PGFile; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_file_delete';
function g_file_delete_finish(file_: PGFile; result_: PGAsyncResult; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_file_delete_finish';
function g_file_descriptor_based_get_fd(fd_based: PGFileDescriptorBased): gint; cdecl; external LazGio2_library name 'g_file_descriptor_based_get_fd';
function g_file_descriptor_based_get_type: TGType; cdecl; external LazGio2_library name 'g_file_descriptor_based_get_type';
function g_file_dup(file_: PGFile): PGFile; cdecl; external LazGio2_library name 'g_file_dup';
function g_file_eject_mountable_with_operation_finish(file_: PGFile; result_: PGAsyncResult; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_file_eject_mountable_with_operation_finish';
function g_file_enumerate_children(file_: PGFile; attributes: Pgchar; flags: TGFileQueryInfoFlags; cancellable: PGCancellable; error: PPGError): PGFileEnumerator; cdecl; external LazGio2_library name 'g_file_enumerate_children';
function g_file_enumerate_children_finish(file_: PGFile; res: PGAsyncResult; error: PPGError): PGFileEnumerator; cdecl; external LazGio2_library name 'g_file_enumerate_children_finish';
function g_file_enumerator_close(enumerator: PGFileEnumerator; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_file_enumerator_close';
function g_file_enumerator_close_finish(enumerator: PGFileEnumerator; result_: PGAsyncResult; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_file_enumerator_close_finish';
function g_file_enumerator_get_child(enumerator: PGFileEnumerator; info: PGFileInfo): PGFile; cdecl; external LazGio2_library name 'g_file_enumerator_get_child';
function g_file_enumerator_get_container(enumerator: PGFileEnumerator): PGFile; cdecl; external LazGio2_library name 'g_file_enumerator_get_container';
function g_file_enumerator_get_type: TGType; cdecl; external LazGio2_library name 'g_file_enumerator_get_type';
function g_file_enumerator_has_pending(enumerator: PGFileEnumerator): gboolean; cdecl; external LazGio2_library name 'g_file_enumerator_has_pending';
function g_file_enumerator_is_closed(enumerator: PGFileEnumerator): gboolean; cdecl; external LazGio2_library name 'g_file_enumerator_is_closed';
function g_file_enumerator_iterate(direnum: PGFileEnumerator; out_info: PPGFileInfo; out_child: PPGFile; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_file_enumerator_iterate';
function g_file_enumerator_next_file(enumerator: PGFileEnumerator; cancellable: PGCancellable; error: PPGError): PGFileInfo; cdecl; external LazGio2_library name 'g_file_enumerator_next_file';
function g_file_enumerator_next_files_finish(enumerator: PGFileEnumerator; result_: PGAsyncResult; error: PPGError): PGList; cdecl; external LazGio2_library name 'g_file_enumerator_next_files_finish';
function g_file_equal(file1: PGFile; file2: PGFile): gboolean; cdecl; external LazGio2_library name 'g_file_equal';
function g_file_find_enclosing_mount(file_: PGFile; cancellable: PGCancellable; error: PPGError): PGMount; cdecl; external LazGio2_library name 'g_file_find_enclosing_mount';
function g_file_find_enclosing_mount_finish(file_: PGFile; res: PGAsyncResult; error: PPGError): PGMount; cdecl; external LazGio2_library name 'g_file_find_enclosing_mount_finish';
function g_file_get_basename(file_: PGFile): Pgchar; cdecl; external LazGio2_library name 'g_file_get_basename';
function g_file_get_child(file_: PGFile; name: Pgchar): PGFile; cdecl; external LazGio2_library name 'g_file_get_child';
function g_file_get_child_for_display_name(file_: PGFile; display_name: Pgchar; error: PPGError): PGFile; cdecl; external LazGio2_library name 'g_file_get_child_for_display_name';
function g_file_get_parent(file_: PGFile): PGFile; cdecl; external LazGio2_library name 'g_file_get_parent';
function g_file_get_parse_name(file_: PGFile): Pgchar; cdecl; external LazGio2_library name 'g_file_get_parse_name';
function g_file_get_path(file_: PGFile): Pgchar; cdecl; external LazGio2_library name 'g_file_get_path';
function g_file_get_relative_path(parent: PGFile; descendant: PGFile): Pgchar; cdecl; external LazGio2_library name 'g_file_get_relative_path';
function g_file_get_type: TGType; cdecl; external LazGio2_library name 'g_file_get_type';
function g_file_get_uri(file_: PGFile): Pgchar; cdecl; external LazGio2_library name 'g_file_get_uri';
function g_file_get_uri_scheme(file_: PGFile): Pgchar; cdecl; external LazGio2_library name 'g_file_get_uri_scheme';
function g_file_has_parent(file_: PGFile; parent: PGFile): gboolean; cdecl; external LazGio2_library name 'g_file_has_parent';
function g_file_has_prefix(file_: PGFile; prefix: PGFile): gboolean; cdecl; external LazGio2_library name 'g_file_has_prefix';
function g_file_has_uri_scheme(file_: PGFile; uri_scheme: Pgchar): gboolean; cdecl; external LazGio2_library name 'g_file_has_uri_scheme';
function g_file_hash(file_: PGFile): guint; cdecl; external LazGio2_library name 'g_file_hash';
function g_file_icon_get_file(icon: PGFileIcon): PGFile; cdecl; external LazGio2_library name 'g_file_icon_get_file';
function g_file_icon_get_type: TGType; cdecl; external LazGio2_library name 'g_file_icon_get_type';
function g_file_icon_new(file_: PGFile): PGFileIcon; cdecl; external LazGio2_library name 'g_file_icon_new';
function g_file_info_dup(other: PGFileInfo): PGFileInfo; cdecl; external LazGio2_library name 'g_file_info_dup';
function g_file_info_get_attribute_as_string(info: PGFileInfo; attribute: Pgchar): Pgchar; cdecl; external LazGio2_library name 'g_file_info_get_attribute_as_string';
function g_file_info_get_attribute_boolean(info: PGFileInfo; attribute: Pgchar): gboolean; cdecl; external LazGio2_library name 'g_file_info_get_attribute_boolean';
function g_file_info_get_attribute_byte_string(info: PGFileInfo; attribute: Pgchar): Pgchar; cdecl; external LazGio2_library name 'g_file_info_get_attribute_byte_string';
function g_file_info_get_attribute_data(info: PGFileInfo; attribute: Pgchar; type_: PGFileAttributeType; value_pp: Pgpointer; status: PGFileAttributeStatus): gboolean; cdecl; external LazGio2_library name 'g_file_info_get_attribute_data';
function g_file_info_get_attribute_int32(info: PGFileInfo; attribute: Pgchar): gint32; cdecl; external LazGio2_library name 'g_file_info_get_attribute_int32';
function g_file_info_get_attribute_int64(info: PGFileInfo; attribute: Pgchar): gint64; cdecl; external LazGio2_library name 'g_file_info_get_attribute_int64';
function g_file_info_get_attribute_object(info: PGFileInfo; attribute: Pgchar): PGObject; cdecl; external LazGio2_library name 'g_file_info_get_attribute_object';
function g_file_info_get_attribute_status(info: PGFileInfo; attribute: Pgchar): TGFileAttributeStatus; cdecl; external LazGio2_library name 'g_file_info_get_attribute_status';
function g_file_info_get_attribute_string(info: PGFileInfo; attribute: Pgchar): Pgchar; cdecl; external LazGio2_library name 'g_file_info_get_attribute_string';
function g_file_info_get_attribute_stringv(info: PGFileInfo; attribute: Pgchar): PPgchar; cdecl; external LazGio2_library name 'g_file_info_get_attribute_stringv';
function g_file_info_get_attribute_type(info: PGFileInfo; attribute: Pgchar): TGFileAttributeType; cdecl; external LazGio2_library name 'g_file_info_get_attribute_type';
function g_file_info_get_attribute_uint32(info: PGFileInfo; attribute: Pgchar): guint32; cdecl; external LazGio2_library name 'g_file_info_get_attribute_uint32';
function g_file_info_get_attribute_uint64(info: PGFileInfo; attribute: Pgchar): guint64; cdecl; external LazGio2_library name 'g_file_info_get_attribute_uint64';
function g_file_info_get_content_type(info: PGFileInfo): Pgchar; cdecl; external LazGio2_library name 'g_file_info_get_content_type';
function g_file_info_get_deletion_date(info: PGFileInfo): PGDateTime; cdecl; external LazGio2_library name 'g_file_info_get_deletion_date';
function g_file_info_get_display_name(info: PGFileInfo): Pgchar; cdecl; external LazGio2_library name 'g_file_info_get_display_name';
function g_file_info_get_edit_name(info: PGFileInfo): Pgchar; cdecl; external LazGio2_library name 'g_file_info_get_edit_name';
function g_file_info_get_etag(info: PGFileInfo): Pgchar; cdecl; external LazGio2_library name 'g_file_info_get_etag';
function g_file_info_get_file_type(info: PGFileInfo): TGFileType; cdecl; external LazGio2_library name 'g_file_info_get_file_type';
function g_file_info_get_icon(info: PGFileInfo): PGIcon; cdecl; external LazGio2_library name 'g_file_info_get_icon';
function g_file_info_get_is_backup(info: PGFileInfo): gboolean; cdecl; external LazGio2_library name 'g_file_info_get_is_backup';
function g_file_info_get_is_hidden(info: PGFileInfo): gboolean; cdecl; external LazGio2_library name 'g_file_info_get_is_hidden';
function g_file_info_get_is_symlink(info: PGFileInfo): gboolean; cdecl; external LazGio2_library name 'g_file_info_get_is_symlink';
function g_file_info_get_modification_date_time(info: PGFileInfo): PGDateTime; cdecl; external LazGio2_library name 'g_file_info_get_modification_date_time';
function g_file_info_get_name(info: PGFileInfo): Pgchar; cdecl; external LazGio2_library name 'g_file_info_get_name';
function g_file_info_get_size(info: PGFileInfo): gint64; cdecl; external LazGio2_library name 'g_file_info_get_size';
function g_file_info_get_sort_order(info: PGFileInfo): gint32; cdecl; external LazGio2_library name 'g_file_info_get_sort_order';
function g_file_info_get_symbolic_icon(info: PGFileInfo): PGIcon; cdecl; external LazGio2_library name 'g_file_info_get_symbolic_icon';
function g_file_info_get_symlink_target(info: PGFileInfo): Pgchar; cdecl; external LazGio2_library name 'g_file_info_get_symlink_target';
function g_file_info_get_type: TGType; cdecl; external LazGio2_library name 'g_file_info_get_type';
function g_file_info_has_attribute(info: PGFileInfo; attribute: Pgchar): gboolean; cdecl; external LazGio2_library name 'g_file_info_has_attribute';
function g_file_info_has_namespace(info: PGFileInfo; name_space: Pgchar): gboolean; cdecl; external LazGio2_library name 'g_file_info_has_namespace';
function g_file_info_list_attributes(info: PGFileInfo; name_space: Pgchar): PPgchar; cdecl; external LazGio2_library name 'g_file_info_list_attributes';
function g_file_info_new: PGFileInfo; cdecl; external LazGio2_library name 'g_file_info_new';
function g_file_info_set_attribute_status(info: PGFileInfo; attribute: Pgchar; status: TGFileAttributeStatus): gboolean; cdecl; external LazGio2_library name 'g_file_info_set_attribute_status';
function g_file_input_stream_get_type: TGType; cdecl; external LazGio2_library name 'g_file_input_stream_get_type';
function g_file_input_stream_query_info(stream: PGFileInputStream; attributes: Pgchar; cancellable: PGCancellable; error: PPGError): PGFileInfo; cdecl; external LazGio2_library name 'g_file_input_stream_query_info';
function g_file_input_stream_query_info_finish(stream: PGFileInputStream; result_: PGAsyncResult; error: PPGError): PGFileInfo; cdecl; external LazGio2_library name 'g_file_input_stream_query_info_finish';
function g_file_io_stream_get_etag(stream: PGFileIOStream): Pgchar; cdecl; external LazGio2_library name 'g_file_io_stream_get_etag';
function g_file_io_stream_get_type: TGType; cdecl; external LazGio2_library name 'g_file_io_stream_get_type';
function g_file_io_stream_query_info(stream: PGFileIOStream; attributes: Pgchar; cancellable: PGCancellable; error: PPGError): PGFileInfo; cdecl; external LazGio2_library name 'g_file_io_stream_query_info';
function g_file_io_stream_query_info_finish(stream: PGFileIOStream; result_: PGAsyncResult; error: PPGError): PGFileInfo; cdecl; external LazGio2_library name 'g_file_io_stream_query_info_finish';
function g_file_is_native(file_: PGFile): gboolean; cdecl; external LazGio2_library name 'g_file_is_native';
function g_file_load_bytes(file_: PGFile; cancellable: PGCancellable; etag_out: PPgchar; error: PPGError): PGBytes; cdecl; external LazGio2_library name 'g_file_load_bytes';
function g_file_load_bytes_finish(file_: PGFile; result_: PGAsyncResult; etag_out: PPgchar; error: PPGError): PGBytes; cdecl; external LazGio2_library name 'g_file_load_bytes_finish';
function g_file_load_contents(file_: PGFile; cancellable: PGCancellable; contents: PPgchar; length: Pgsize; etag_out: PPgchar; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_file_load_contents';
function g_file_load_contents_finish(file_: PGFile; res: PGAsyncResult; contents: PPgchar; length: Pgsize; etag_out: PPgchar; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_file_load_contents_finish';
function g_file_load_partial_contents_finish(file_: PGFile; res: PGAsyncResult; contents: PPgchar; length: Pgsize; etag_out: PPgchar; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_file_load_partial_contents_finish';
function g_file_make_directory(file_: PGFile; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_file_make_directory';
function g_file_make_directory_finish(file_: PGFile; result_: PGAsyncResult; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_file_make_directory_finish';
function g_file_make_directory_with_parents(file_: PGFile; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_file_make_directory_with_parents';
function g_file_make_symbolic_link(file_: PGFile; symlink_value: Pgchar; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_file_make_symbolic_link';
function g_file_measure_disk_usage(file_: PGFile; flags: TGFileMeasureFlags; cancellable: PGCancellable; progress_callback: TGFileMeasureProgressCallback; progress_data: gpointer; disk_usage: Pguint64; num_dirs: Pguint64; num_files: Pguint64; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_file_measure_disk_usage';
function g_file_measure_disk_usage_finish(file_: PGFile; result_: PGAsyncResult; disk_usage: Pguint64; num_dirs: Pguint64; num_files: Pguint64; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_file_measure_disk_usage_finish';
function g_file_monitor(file_: PGFile; flags: TGFileMonitorFlags; cancellable: PGCancellable; error: PPGError): PGFileMonitor; cdecl; external LazGio2_library name 'g_file_monitor';
function g_file_monitor_cancel(monitor: PGFileMonitor): gboolean; cdecl; external LazGio2_library name 'g_file_monitor_cancel';
function g_file_monitor_directory(file_: PGFile; flags: TGFileMonitorFlags; cancellable: PGCancellable; error: PPGError): PGFileMonitor; cdecl; external LazGio2_library name 'g_file_monitor_directory';
function g_file_monitor_file(file_: PGFile; flags: TGFileMonitorFlags; cancellable: PGCancellable; error: PPGError): PGFileMonitor; cdecl; external LazGio2_library name 'g_file_monitor_file';
function g_file_monitor_get_type: TGType; cdecl; external LazGio2_library name 'g_file_monitor_get_type';
function g_file_monitor_is_cancelled(monitor: PGFileMonitor): gboolean; cdecl; external LazGio2_library name 'g_file_monitor_is_cancelled';
function g_file_mount_enclosing_volume_finish(location: PGFile; result_: PGAsyncResult; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_file_mount_enclosing_volume_finish';
function g_file_mount_mountable_finish(file_: PGFile; result_: PGAsyncResult; error: PPGError): PGFile; cdecl; external LazGio2_library name 'g_file_mount_mountable_finish';
function g_file_move(source: PGFile; destination: PGFile; flags: TGFileCopyFlags; cancellable: PGCancellable; progress_callback: TGFileProgressCallback; progress_callback_data: gpointer; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_file_move';
function g_file_new_build_filename(first_element: Pgchar; args: array of const): PGFile; cdecl; external LazGio2_library name 'g_file_new_build_filename';
function g_file_new_for_commandline_arg(arg: Pgchar): PGFile; cdecl; external LazGio2_library name 'g_file_new_for_commandline_arg';
function g_file_new_for_commandline_arg_and_cwd(arg: Pgchar; cwd: Pgchar): PGFile; cdecl; external LazGio2_library name 'g_file_new_for_commandline_arg_and_cwd';
function g_file_new_for_path(path: Pgchar): PGFile; cdecl; external LazGio2_library name 'g_file_new_for_path';
function g_file_new_for_uri(uri: Pgchar): PGFile; cdecl; external LazGio2_library name 'g_file_new_for_uri';
function g_file_new_tmp(tmpl: Pgchar; iostream: PPGFileIOStream; error: PPGError): PGFile; cdecl; external LazGio2_library name 'g_file_new_tmp';
function g_file_open_readwrite(file_: PGFile; cancellable: PGCancellable; error: PPGError): PGFileIOStream; cdecl; external LazGio2_library name 'g_file_open_readwrite';
function g_file_open_readwrite_finish(file_: PGFile; res: PGAsyncResult; error: PPGError): PGFileIOStream; cdecl; external LazGio2_library name 'g_file_open_readwrite_finish';
function g_file_output_stream_get_etag(stream: PGFileOutputStream): Pgchar; cdecl; external LazGio2_library name 'g_file_output_stream_get_etag';
function g_file_output_stream_get_type: TGType; cdecl; external LazGio2_library name 'g_file_output_stream_get_type';
function g_file_output_stream_query_info(stream: PGFileOutputStream; attributes: Pgchar; cancellable: PGCancellable; error: PPGError): PGFileInfo; cdecl; external LazGio2_library name 'g_file_output_stream_query_info';
function g_file_output_stream_query_info_finish(stream: PGFileOutputStream; result_: PGAsyncResult; error: PPGError): PGFileInfo; cdecl; external LazGio2_library name 'g_file_output_stream_query_info_finish';
function g_file_parse_name(parse_name: Pgchar): PGFile; cdecl; external LazGio2_library name 'g_file_parse_name';
function g_file_peek_path(file_: PGFile): Pgchar; cdecl; external LazGio2_library name 'g_file_peek_path';
function g_file_poll_mountable_finish(file_: PGFile; result_: PGAsyncResult; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_file_poll_mountable_finish';
function g_file_query_default_handler(file_: PGFile; cancellable: PGCancellable; error: PPGError): PGAppInfo; cdecl; external LazGio2_library name 'g_file_query_default_handler';
function g_file_query_default_handler_finish(file_: PGFile; result_: PGAsyncResult; error: PPGError): PGAppInfo; cdecl; external LazGio2_library name 'g_file_query_default_handler_finish';
function g_file_query_exists(file_: PGFile; cancellable: PGCancellable): gboolean; cdecl; external LazGio2_library name 'g_file_query_exists';
function g_file_query_file_type(file_: PGFile; flags: TGFileQueryInfoFlags; cancellable: PGCancellable): TGFileType; cdecl; external LazGio2_library name 'g_file_query_file_type';
function g_file_query_filesystem_info(file_: PGFile; attributes: Pgchar; cancellable: PGCancellable; error: PPGError): PGFileInfo; cdecl; external LazGio2_library name 'g_file_query_filesystem_info';
function g_file_query_filesystem_info_finish(file_: PGFile; res: PGAsyncResult; error: PPGError): PGFileInfo; cdecl; external LazGio2_library name 'g_file_query_filesystem_info_finish';
function g_file_query_info(file_: PGFile; attributes: Pgchar; flags: TGFileQueryInfoFlags; cancellable: PGCancellable; error: PPGError): PGFileInfo; cdecl; external LazGio2_library name 'g_file_query_info';
function g_file_query_info_finish(file_: PGFile; res: PGAsyncResult; error: PPGError): PGFileInfo; cdecl; external LazGio2_library name 'g_file_query_info_finish';
function g_file_query_settable_attributes(file_: PGFile; cancellable: PGCancellable; error: PPGError): PGFileAttributeInfoList; cdecl; external LazGio2_library name 'g_file_query_settable_attributes';
function g_file_query_writable_namespaces(file_: PGFile; cancellable: PGCancellable; error: PPGError): PGFileAttributeInfoList; cdecl; external LazGio2_library name 'g_file_query_writable_namespaces';
function g_file_read(file_: PGFile; cancellable: PGCancellable; error: PPGError): PGFileInputStream; cdecl; external LazGio2_library name 'g_file_read';
function g_file_read_finish(file_: PGFile; res: PGAsyncResult; error: PPGError): PGFileInputStream; cdecl; external LazGio2_library name 'g_file_read_finish';
function g_file_replace(file_: PGFile; etag: Pgchar; make_backup: gboolean; flags: TGFileCreateFlags; cancellable: PGCancellable; error: PPGError): PGFileOutputStream; cdecl; external LazGio2_library name 'g_file_replace';
function g_file_replace_contents(file_: PGFile; contents: Pgchar; length: gsize; etag: Pgchar; make_backup: gboolean; flags: TGFileCreateFlags; new_etag: PPgchar; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_file_replace_contents';
function g_file_replace_contents_finish(file_: PGFile; res: PGAsyncResult; new_etag: PPgchar; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_file_replace_contents_finish';
function g_file_replace_finish(file_: PGFile; res: PGAsyncResult; error: PPGError): PGFileOutputStream; cdecl; external LazGio2_library name 'g_file_replace_finish';
function g_file_replace_readwrite(file_: PGFile; etag: Pgchar; make_backup: gboolean; flags: TGFileCreateFlags; cancellable: PGCancellable; error: PPGError): PGFileIOStream; cdecl; external LazGio2_library name 'g_file_replace_readwrite';
function g_file_replace_readwrite_finish(file_: PGFile; res: PGAsyncResult; error: PPGError): PGFileIOStream; cdecl; external LazGio2_library name 'g_file_replace_readwrite_finish';
function g_file_resolve_relative_path(file_: PGFile; relative_path: Pgchar): PGFile; cdecl; external LazGio2_library name 'g_file_resolve_relative_path';
function g_file_set_attribute(file_: PGFile; attribute: Pgchar; type_: TGFileAttributeType; value_p: gpointer; flags: TGFileQueryInfoFlags; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_file_set_attribute';
function g_file_set_attribute_byte_string(file_: PGFile; attribute: Pgchar; value: Pgchar; flags: TGFileQueryInfoFlags; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_file_set_attribute_byte_string';
function g_file_set_attribute_int32(file_: PGFile; attribute: Pgchar; value: gint32; flags: TGFileQueryInfoFlags; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_file_set_attribute_int32';
function g_file_set_attribute_int64(file_: PGFile; attribute: Pgchar; value: gint64; flags: TGFileQueryInfoFlags; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_file_set_attribute_int64';
function g_file_set_attribute_string(file_: PGFile; attribute: Pgchar; value: Pgchar; flags: TGFileQueryInfoFlags; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_file_set_attribute_string';
function g_file_set_attribute_uint32(file_: PGFile; attribute: Pgchar; value: guint32; flags: TGFileQueryInfoFlags; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_file_set_attribute_uint32';
function g_file_set_attribute_uint64(file_: PGFile; attribute: Pgchar; value: guint64; flags: TGFileQueryInfoFlags; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_file_set_attribute_uint64';
function g_file_set_attributes_finish(file_: PGFile; result_: PGAsyncResult; info: PPGFileInfo; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_file_set_attributes_finish';
function g_file_set_attributes_from_info(file_: PGFile; info: PGFileInfo; flags: TGFileQueryInfoFlags; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_file_set_attributes_from_info';
function g_file_set_display_name(file_: PGFile; display_name: Pgchar; cancellable: PGCancellable; error: PPGError): PGFile; cdecl; external LazGio2_library name 'g_file_set_display_name';
function g_file_set_display_name_finish(file_: PGFile; res: PGAsyncResult; error: PPGError): PGFile; cdecl; external LazGio2_library name 'g_file_set_display_name_finish';
function g_file_start_mountable_finish(file_: PGFile; result_: PGAsyncResult; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_file_start_mountable_finish';
function g_file_stop_mountable_finish(file_: PGFile; result_: PGAsyncResult; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_file_stop_mountable_finish';
function g_file_supports_thread_contexts(file_: PGFile): gboolean; cdecl; external LazGio2_library name 'g_file_supports_thread_contexts';
function g_file_trash(file_: PGFile; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_file_trash';
function g_file_trash_finish(file_: PGFile; result_: PGAsyncResult; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_file_trash_finish';
function g_file_unmount_mountable_with_operation_finish(file_: PGFile; result_: PGAsyncResult; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_file_unmount_mountable_with_operation_finish';
function g_filename_completer_get_completion_suffix(completer: PGFilenameCompleter; initial_text: Pgchar): Pgchar; cdecl; external LazGio2_library name 'g_filename_completer_get_completion_suffix';
function g_filename_completer_get_completions(completer: PGFilenameCompleter; initial_text: Pgchar): PPgchar; cdecl; external LazGio2_library name 'g_filename_completer_get_completions';
function g_filename_completer_get_type: TGType; cdecl; external LazGio2_library name 'g_filename_completer_get_type';
function g_filename_completer_new: PGFilenameCompleter; cdecl; external LazGio2_library name 'g_filename_completer_new';
function g_filter_input_stream_get_base_stream(stream: PGFilterInputStream): PGInputStream; cdecl; external LazGio2_library name 'g_filter_input_stream_get_base_stream';
function g_filter_input_stream_get_close_base_stream(stream: PGFilterInputStream): gboolean; cdecl; external LazGio2_library name 'g_filter_input_stream_get_close_base_stream';
function g_filter_input_stream_get_type: TGType; cdecl; external LazGio2_library name 'g_filter_input_stream_get_type';
function g_filter_output_stream_get_base_stream(stream: PGFilterOutputStream): PGOutputStream; cdecl; external LazGio2_library name 'g_filter_output_stream_get_base_stream';
function g_filter_output_stream_get_close_base_stream(stream: PGFilterOutputStream): gboolean; cdecl; external LazGio2_library name 'g_filter_output_stream_get_close_base_stream';
function g_filter_output_stream_get_type: TGType; cdecl; external LazGio2_library name 'g_filter_output_stream_get_type';
function g_icon_deserialize(value: PGVariant): PGIcon; cdecl; external LazGio2_library name 'g_icon_deserialize';
function g_icon_equal(icon1: PGIcon; icon2: PGIcon): gboolean; cdecl; external LazGio2_library name 'g_icon_equal';
function g_icon_get_type: TGType; cdecl; external LazGio2_library name 'g_icon_get_type';
function g_icon_hash(icon: Pgpointer): guint; cdecl; external LazGio2_library name 'g_icon_hash';
function g_icon_new_for_string(str: Pgchar; error: PPGError): PGIcon; cdecl; external LazGio2_library name 'g_icon_new_for_string';
function g_icon_serialize(icon: PGIcon): PGVariant; cdecl; external LazGio2_library name 'g_icon_serialize';
function g_icon_to_string(icon: PGIcon): Pgchar; cdecl; external LazGio2_library name 'g_icon_to_string';
function g_inet_address_equal(address: PGInetAddress; other_address: PGInetAddress): gboolean; cdecl; external LazGio2_library name 'g_inet_address_equal';
function g_inet_address_get_family(address: PGInetAddress): TGSocketFamily; cdecl; external LazGio2_library name 'g_inet_address_get_family';
function g_inet_address_get_is_any(address: PGInetAddress): gboolean; cdecl; external LazGio2_library name 'g_inet_address_get_is_any';
function g_inet_address_get_is_link_local(address: PGInetAddress): gboolean; cdecl; external LazGio2_library name 'g_inet_address_get_is_link_local';
function g_inet_address_get_is_loopback(address: PGInetAddress): gboolean; cdecl; external LazGio2_library name 'g_inet_address_get_is_loopback';
function g_inet_address_get_is_mc_global(address: PGInetAddress): gboolean; cdecl; external LazGio2_library name 'g_inet_address_get_is_mc_global';
function g_inet_address_get_is_mc_link_local(address: PGInetAddress): gboolean; cdecl; external LazGio2_library name 'g_inet_address_get_is_mc_link_local';
function g_inet_address_get_is_mc_node_local(address: PGInetAddress): gboolean; cdecl; external LazGio2_library name 'g_inet_address_get_is_mc_node_local';
function g_inet_address_get_is_mc_org_local(address: PGInetAddress): gboolean; cdecl; external LazGio2_library name 'g_inet_address_get_is_mc_org_local';
function g_inet_address_get_is_mc_site_local(address: PGInetAddress): gboolean; cdecl; external LazGio2_library name 'g_inet_address_get_is_mc_site_local';
function g_inet_address_get_is_multicast(address: PGInetAddress): gboolean; cdecl; external LazGio2_library name 'g_inet_address_get_is_multicast';
function g_inet_address_get_is_site_local(address: PGInetAddress): gboolean; cdecl; external LazGio2_library name 'g_inet_address_get_is_site_local';
function g_inet_address_get_native_size(address: PGInetAddress): gsize; cdecl; external LazGio2_library name 'g_inet_address_get_native_size';
function g_inet_address_get_type: TGType; cdecl; external LazGio2_library name 'g_inet_address_get_type';
function g_inet_address_mask_equal(mask: PGInetAddressMask; mask2: PGInetAddressMask): gboolean; cdecl; external LazGio2_library name 'g_inet_address_mask_equal';
function g_inet_address_mask_get_address(mask: PGInetAddressMask): PGInetAddress; cdecl; external LazGio2_library name 'g_inet_address_mask_get_address';
function g_inet_address_mask_get_family(mask: PGInetAddressMask): TGSocketFamily; cdecl; external LazGio2_library name 'g_inet_address_mask_get_family';
function g_inet_address_mask_get_length(mask: PGInetAddressMask): guint; cdecl; external LazGio2_library name 'g_inet_address_mask_get_length';
function g_inet_address_mask_get_type: TGType; cdecl; external LazGio2_library name 'g_inet_address_mask_get_type';
function g_inet_address_mask_matches(mask: PGInetAddressMask; address: PGInetAddress): gboolean; cdecl; external LazGio2_library name 'g_inet_address_mask_matches';
function g_inet_address_mask_new(addr: PGInetAddress; length: guint; error: PPGError): PGInetAddressMask; cdecl; external LazGio2_library name 'g_inet_address_mask_new';
function g_inet_address_mask_new_from_string(mask_string: Pgchar; error: PPGError): PGInetAddressMask; cdecl; external LazGio2_library name 'g_inet_address_mask_new_from_string';
function g_inet_address_mask_to_string(mask: PGInetAddressMask): Pgchar; cdecl; external LazGio2_library name 'g_inet_address_mask_to_string';
function g_inet_address_new_any(family: TGSocketFamily): PGInetAddress; cdecl; external LazGio2_library name 'g_inet_address_new_any';
function g_inet_address_new_from_bytes(bytes: Pguint8; family: TGSocketFamily): PGInetAddress; cdecl; external LazGio2_library name 'g_inet_address_new_from_bytes';
function g_inet_address_new_from_string(string_: Pgchar): PGInetAddress; cdecl; external LazGio2_library name 'g_inet_address_new_from_string';
function g_inet_address_new_loopback(family: TGSocketFamily): PGInetAddress; cdecl; external LazGio2_library name 'g_inet_address_new_loopback';
function g_inet_address_to_bytes(address: PGInetAddress): Pguint8; cdecl; external LazGio2_library name 'g_inet_address_to_bytes';
function g_inet_address_to_string(address: PGInetAddress): Pgchar; cdecl; external LazGio2_library name 'g_inet_address_to_string';
function g_inet_socket_address_get_address(address: PGInetSocketAddress): PGInetAddress; cdecl; external LazGio2_library name 'g_inet_socket_address_get_address';
function g_inet_socket_address_get_flowinfo(address: PGInetSocketAddress): guint32; cdecl; external LazGio2_library name 'g_inet_socket_address_get_flowinfo';
function g_inet_socket_address_get_port(address: PGInetSocketAddress): guint16; cdecl; external LazGio2_library name 'g_inet_socket_address_get_port';
function g_inet_socket_address_get_scope_id(address: PGInetSocketAddress): guint32; cdecl; external LazGio2_library name 'g_inet_socket_address_get_scope_id';
function g_inet_socket_address_get_type: TGType; cdecl; external LazGio2_library name 'g_inet_socket_address_get_type';
function g_inet_socket_address_new(address: PGInetAddress; port: guint16): PGInetSocketAddress; cdecl; external LazGio2_library name 'g_inet_socket_address_new';
function g_inet_socket_address_new_from_string(address: Pgchar; port: guint): PGInetSocketAddress; cdecl; external LazGio2_library name 'g_inet_socket_address_new_from_string';
function g_initable_get_type: TGType; cdecl; external LazGio2_library name 'g_initable_get_type';
function g_initable_init(initable: PGInitable; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_initable_init';
function g_initable_new(object_type: TGType; cancellable: PGCancellable; error: PPGError; first_property_name: Pgchar; args: array of const): PGObject; cdecl; external LazGio2_library name 'g_initable_new';
function g_initable_new_valist(object_type: TGType; first_property_name: Pgchar; var_args: Tva_list; cancellable: PGCancellable; error: PPGError): PGObject; cdecl; external LazGio2_library name 'g_initable_new_valist';
function g_input_stream_close(stream: PGInputStream; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_input_stream_close';
function g_input_stream_close_finish(stream: PGInputStream; result_: PGAsyncResult; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_input_stream_close_finish';
function g_input_stream_get_type: TGType; cdecl; external LazGio2_library name 'g_input_stream_get_type';
function g_input_stream_has_pending(stream: PGInputStream): gboolean; cdecl; external LazGio2_library name 'g_input_stream_has_pending';
function g_input_stream_is_closed(stream: PGInputStream): gboolean; cdecl; external LazGio2_library name 'g_input_stream_is_closed';
function g_input_stream_read(stream: PGInputStream; buffer: Pguint8; count: gsize; cancellable: PGCancellable; error: PPGError): gssize; cdecl; external LazGio2_library name 'g_input_stream_read';
function g_input_stream_read_all(stream: PGInputStream; buffer: Pguint8; count: gsize; bytes_read: Pgsize; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_input_stream_read_all';
function g_input_stream_read_all_finish(stream: PGInputStream; result_: PGAsyncResult; bytes_read: Pgsize; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_input_stream_read_all_finish';
function g_input_stream_read_bytes(stream: PGInputStream; count: gsize; cancellable: PGCancellable; error: PPGError): PGBytes; cdecl; external LazGio2_library name 'g_input_stream_read_bytes';
function g_input_stream_read_bytes_finish(stream: PGInputStream; result_: PGAsyncResult; error: PPGError): PGBytes; cdecl; external LazGio2_library name 'g_input_stream_read_bytes_finish';
function g_input_stream_read_finish(stream: PGInputStream; result_: PGAsyncResult; error: PPGError): gssize; cdecl; external LazGio2_library name 'g_input_stream_read_finish';
function g_input_stream_set_pending(stream: PGInputStream; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_input_stream_set_pending';
function g_input_stream_skip(stream: PGInputStream; count: gsize; cancellable: PGCancellable; error: PPGError): gssize; cdecl; external LazGio2_library name 'g_input_stream_skip';
function g_input_stream_skip_finish(stream: PGInputStream; result_: PGAsyncResult; error: PPGError): gssize; cdecl; external LazGio2_library name 'g_input_stream_skip_finish';
function g_io_error_from_errno(err_no: gint): TGIOErrorEnum; cdecl; external LazGio2_library name 'g_io_error_from_errno';
function g_io_error_quark: TGQuark; cdecl; external LazGio2_library name 'g_io_error_quark';
function g_io_extension_get_name(extension: PGIOExtension): Pgchar; cdecl; external LazGio2_library name 'g_io_extension_get_name';
function g_io_extension_get_priority(extension: PGIOExtension): gint; cdecl; external LazGio2_library name 'g_io_extension_get_priority';
function g_io_extension_get_type(extension: PGIOExtension): TGType; cdecl; external LazGio2_library name 'g_io_extension_get_type';
function g_io_extension_point_get_extension_by_name(extension_point: PGIOExtensionPoint; name: Pgchar): PGIOExtension; cdecl; external LazGio2_library name 'g_io_extension_point_get_extension_by_name';
function g_io_extension_point_get_extensions(extension_point: PGIOExtensionPoint): PGList; cdecl; external LazGio2_library name 'g_io_extension_point_get_extensions';
function g_io_extension_point_get_required_type(extension_point: PGIOExtensionPoint): TGType; cdecl; external LazGio2_library name 'g_io_extension_point_get_required_type';
function g_io_extension_point_implement(extension_point_name: Pgchar; type_: TGType; extension_name: Pgchar; priority: gint): PGIOExtension; cdecl; external LazGio2_library name 'g_io_extension_point_implement';
function g_io_extension_point_lookup(name: Pgchar): PGIOExtensionPoint; cdecl; external LazGio2_library name 'g_io_extension_point_lookup';
function g_io_extension_point_register(name: Pgchar): PGIOExtensionPoint; cdecl; external LazGio2_library name 'g_io_extension_point_register';
function g_io_extension_ref_class(extension: PGIOExtension): PGTypeClass; cdecl; external LazGio2_library name 'g_io_extension_ref_class';
function g_io_module_get_type: TGType; cdecl; external LazGio2_library name 'g_io_module_get_type';
function g_io_module_new(filename: Pgchar): PGIOModule; cdecl; external LazGio2_library name 'g_io_module_new';
function g_io_module_scope_new(flags: TGIOModuleScopeFlags): PGIOModuleScope; cdecl; external LazGio2_library name 'g_io_module_scope_new';
function g_io_modules_load_all_in_directory(dirname: Pgchar): PGList; cdecl; external LazGio2_library name 'g_io_modules_load_all_in_directory';
function g_io_modules_load_all_in_directory_with_scope(dirname: Pgchar; scope: PGIOModuleScope): PGList; cdecl; external LazGio2_library name 'g_io_modules_load_all_in_directory_with_scope';
function g_io_stream_close(stream: PGIOStream; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_io_stream_close';
function g_io_stream_close_finish(stream: PGIOStream; result_: PGAsyncResult; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_io_stream_close_finish';
function g_io_stream_get_input_stream(stream: PGIOStream): PGInputStream; cdecl; external LazGio2_library name 'g_io_stream_get_input_stream';
function g_io_stream_get_output_stream(stream: PGIOStream): PGOutputStream; cdecl; external LazGio2_library name 'g_io_stream_get_output_stream';
function g_io_stream_get_type: TGType; cdecl; external LazGio2_library name 'g_io_stream_get_type';
function g_io_stream_has_pending(stream: PGIOStream): gboolean; cdecl; external LazGio2_library name 'g_io_stream_has_pending';
function g_io_stream_is_closed(stream: PGIOStream): gboolean; cdecl; external LazGio2_library name 'g_io_stream_is_closed';
function g_io_stream_set_pending(stream: PGIOStream; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_io_stream_set_pending';
function g_io_stream_splice_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_io_stream_splice_finish';
function g_keyfile_settings_backend_new(filename: Pgchar; root_path: Pgchar; root_group: Pgchar): PGSettingsBackend; cdecl; external LazGio2_library name 'g_keyfile_settings_backend_new';
function g_list_model_get_item(list: PGListModel; position: guint): gpointer; cdecl; external LazGio2_library name 'g_list_model_get_item';
function g_list_model_get_item_type(list: PGListModel): TGType; cdecl; external LazGio2_library name 'g_list_model_get_item_type';
function g_list_model_get_n_items(list: PGListModel): guint; cdecl; external LazGio2_library name 'g_list_model_get_n_items';
function g_list_model_get_object(list: PGListModel; position: guint): PGObject; cdecl; external LazGio2_library name 'g_list_model_get_object';
function g_list_model_get_type: TGType; cdecl; external LazGio2_library name 'g_list_model_get_type';
function g_list_store_find(store: PGListStore; item: PGObject; position: Pguint): gboolean; cdecl; external LazGio2_library name 'g_list_store_find';
function g_list_store_find_with_equal_func(store: PGListStore; item: PGObject; equal_func: TGEqualFunc; position: Pguint): gboolean; cdecl; external LazGio2_library name 'g_list_store_find_with_equal_func';
function g_list_store_get_type: TGType; cdecl; external LazGio2_library name 'g_list_store_get_type';
function g_list_store_insert_sorted(store: PGListStore; item: PGObject; compare_func: TGCompareDataFunc; user_data: gpointer): guint; cdecl; external LazGio2_library name 'g_list_store_insert_sorted';
function g_list_store_new(item_type: TGType): PGListStore; cdecl; external LazGio2_library name 'g_list_store_new';
function g_loadable_icon_get_type: TGType; cdecl; external LazGio2_library name 'g_loadable_icon_get_type';
function g_loadable_icon_load(icon: PGLoadableIcon; size: gint; type_: PPgchar; cancellable: PGCancellable; error: PPGError): PGInputStream; cdecl; external LazGio2_library name 'g_loadable_icon_load';
function g_loadable_icon_load_finish(icon: PGLoadableIcon; res: PGAsyncResult; type_: PPgchar; error: PPGError): PGInputStream; cdecl; external LazGio2_library name 'g_loadable_icon_load_finish';
function g_memory_input_stream_get_type: TGType; cdecl; external LazGio2_library name 'g_memory_input_stream_get_type';
function g_memory_input_stream_new: PGMemoryInputStream; cdecl; external LazGio2_library name 'g_memory_input_stream_new';
function g_memory_input_stream_new_from_bytes(bytes: PGBytes): PGMemoryInputStream; cdecl; external LazGio2_library name 'g_memory_input_stream_new_from_bytes';
function g_memory_input_stream_new_from_data(data: Pguint8; len: gssize; destroy_: TGDestroyNotify): PGMemoryInputStream; cdecl; external LazGio2_library name 'g_memory_input_stream_new_from_data';
function g_memory_monitor_dup_default: PGMemoryMonitor; cdecl; external LazGio2_library name 'g_memory_monitor_dup_default';
function g_memory_monitor_get_type: TGType; cdecl; external LazGio2_library name 'g_memory_monitor_get_type';
function g_memory_output_stream_get_data(ostream: PGMemoryOutputStream): gpointer; cdecl; external LazGio2_library name 'g_memory_output_stream_get_data';
function g_memory_output_stream_get_data_size(ostream: PGMemoryOutputStream): gsize; cdecl; external LazGio2_library name 'g_memory_output_stream_get_data_size';
function g_memory_output_stream_get_size(ostream: PGMemoryOutputStream): gsize; cdecl; external LazGio2_library name 'g_memory_output_stream_get_size';
function g_memory_output_stream_get_type: TGType; cdecl; external LazGio2_library name 'g_memory_output_stream_get_type';
function g_memory_output_stream_new(data: gpointer; size: gsize; realloc_function: TGReallocFunc; destroy_function: TGDestroyNotify): PGMemoryOutputStream; cdecl; external LazGio2_library name 'g_memory_output_stream_new';
function g_memory_output_stream_new_resizable: PGMemoryOutputStream; cdecl; external LazGio2_library name 'g_memory_output_stream_new_resizable';
function g_memory_output_stream_steal_as_bytes(ostream: PGMemoryOutputStream): PGBytes; cdecl; external LazGio2_library name 'g_memory_output_stream_steal_as_bytes';
function g_memory_output_stream_steal_data(ostream: PGMemoryOutputStream): gpointer; cdecl; external LazGio2_library name 'g_memory_output_stream_steal_data';
function g_memory_settings_backend_new: PGSettingsBackend; cdecl; external LazGio2_library name 'g_memory_settings_backend_new';
function g_menu_attribute_iter_get_name(iter: PGMenuAttributeIter): Pgchar; cdecl; external LazGio2_library name 'g_menu_attribute_iter_get_name';
function g_menu_attribute_iter_get_next(iter: PGMenuAttributeIter; out_name: PPgchar; value: PPGVariant): gboolean; cdecl; external LazGio2_library name 'g_menu_attribute_iter_get_next';
function g_menu_attribute_iter_get_type: TGType; cdecl; external LazGio2_library name 'g_menu_attribute_iter_get_type';
function g_menu_attribute_iter_get_value(iter: PGMenuAttributeIter): PGVariant; cdecl; external LazGio2_library name 'g_menu_attribute_iter_get_value';
function g_menu_attribute_iter_next(iter: PGMenuAttributeIter): gboolean; cdecl; external LazGio2_library name 'g_menu_attribute_iter_next';
function g_menu_get_type: TGType; cdecl; external LazGio2_library name 'g_menu_get_type';
function g_menu_item_get_attribute(menu_item: PGMenuItem; attribute: Pgchar; format_string: Pgchar; args: array of const): gboolean; cdecl; external LazGio2_library name 'g_menu_item_get_attribute';
function g_menu_item_get_attribute_value(menu_item: PGMenuItem; attribute: Pgchar; expected_type: PGVariantType): PGVariant; cdecl; external LazGio2_library name 'g_menu_item_get_attribute_value';
function g_menu_item_get_link(menu_item: PGMenuItem; link: Pgchar): PGMenuModel; cdecl; external LazGio2_library name 'g_menu_item_get_link';
function g_menu_item_get_type: TGType; cdecl; external LazGio2_library name 'g_menu_item_get_type';
function g_menu_item_new(label_: Pgchar; detailed_action: Pgchar): PGMenuItem; cdecl; external LazGio2_library name 'g_menu_item_new';
function g_menu_item_new_from_model(model: PGMenuModel; item_index: gint): PGMenuItem; cdecl; external LazGio2_library name 'g_menu_item_new_from_model';
function g_menu_item_new_section(label_: Pgchar; section: PGMenuModel): PGMenuItem; cdecl; external LazGio2_library name 'g_menu_item_new_section';
function g_menu_item_new_submenu(label_: Pgchar; submenu: PGMenuModel): PGMenuItem; cdecl; external LazGio2_library name 'g_menu_item_new_submenu';
function g_menu_link_iter_get_name(iter: PGMenuLinkIter): Pgchar; cdecl; external LazGio2_library name 'g_menu_link_iter_get_name';
function g_menu_link_iter_get_next(iter: PGMenuLinkIter; out_link: PPgchar; value: PPGMenuModel): gboolean; cdecl; external LazGio2_library name 'g_menu_link_iter_get_next';
function g_menu_link_iter_get_type: TGType; cdecl; external LazGio2_library name 'g_menu_link_iter_get_type';
function g_menu_link_iter_get_value(iter: PGMenuLinkIter): PGMenuModel; cdecl; external LazGio2_library name 'g_menu_link_iter_get_value';
function g_menu_link_iter_next(iter: PGMenuLinkIter): gboolean; cdecl; external LazGio2_library name 'g_menu_link_iter_next';
function g_menu_model_get_item_attribute(model: PGMenuModel; item_index: gint; attribute: Pgchar; format_string: Pgchar; args: array of const): gboolean; cdecl; external LazGio2_library name 'g_menu_model_get_item_attribute';
function g_menu_model_get_item_attribute_value(model: PGMenuModel; item_index: gint; attribute: Pgchar; expected_type: PGVariantType): PGVariant; cdecl; external LazGio2_library name 'g_menu_model_get_item_attribute_value';
function g_menu_model_get_item_link(model: PGMenuModel; item_index: gint; link: Pgchar): PGMenuModel; cdecl; external LazGio2_library name 'g_menu_model_get_item_link';
function g_menu_model_get_n_items(model: PGMenuModel): gint; cdecl; external LazGio2_library name 'g_menu_model_get_n_items';
function g_menu_model_get_type: TGType; cdecl; external LazGio2_library name 'g_menu_model_get_type';
function g_menu_model_is_mutable(model: PGMenuModel): gboolean; cdecl; external LazGio2_library name 'g_menu_model_is_mutable';
function g_menu_model_iterate_item_attributes(model: PGMenuModel; item_index: gint): PGMenuAttributeIter; cdecl; external LazGio2_library name 'g_menu_model_iterate_item_attributes';
function g_menu_model_iterate_item_links(model: PGMenuModel; item_index: gint): PGMenuLinkIter; cdecl; external LazGio2_library name 'g_menu_model_iterate_item_links';
function g_menu_new: PGMenu; cdecl; external LazGio2_library name 'g_menu_new';
function g_mount_can_eject(mount: PGMount): gboolean; cdecl; external LazGio2_library name 'g_mount_can_eject';
function g_mount_can_unmount(mount: PGMount): gboolean; cdecl; external LazGio2_library name 'g_mount_can_unmount';
function g_mount_eject_with_operation_finish(mount: PGMount; result_: PGAsyncResult; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_mount_eject_with_operation_finish';
function g_mount_get_default_location(mount: PGMount): PGFile; cdecl; external LazGio2_library name 'g_mount_get_default_location';
function g_mount_get_drive(mount: PGMount): PGDrive; cdecl; external LazGio2_library name 'g_mount_get_drive';
function g_mount_get_icon(mount: PGMount): PGIcon; cdecl; external LazGio2_library name 'g_mount_get_icon';
function g_mount_get_name(mount: PGMount): Pgchar; cdecl; external LazGio2_library name 'g_mount_get_name';
function g_mount_get_root(mount: PGMount): PGFile; cdecl; external LazGio2_library name 'g_mount_get_root';
function g_mount_get_sort_key(mount: PGMount): Pgchar; cdecl; external LazGio2_library name 'g_mount_get_sort_key';
function g_mount_get_symbolic_icon(mount: PGMount): PGIcon; cdecl; external LazGio2_library name 'g_mount_get_symbolic_icon';
function g_mount_get_type: TGType; cdecl; external LazGio2_library name 'g_mount_get_type';
function g_mount_get_uuid(mount: PGMount): Pgchar; cdecl; external LazGio2_library name 'g_mount_get_uuid';
function g_mount_get_volume(mount: PGMount): PGVolume; cdecl; external LazGio2_library name 'g_mount_get_volume';
function g_mount_guess_content_type_finish(mount: PGMount; result_: PGAsyncResult; error: PPGError): PPgchar; cdecl; external LazGio2_library name 'g_mount_guess_content_type_finish';
function g_mount_guess_content_type_sync(mount: PGMount; force_rescan: gboolean; cancellable: PGCancellable; error: PPGError): PPgchar; cdecl; external LazGio2_library name 'g_mount_guess_content_type_sync';
function g_mount_is_shadowed(mount: PGMount): gboolean; cdecl; external LazGio2_library name 'g_mount_is_shadowed';
function g_mount_operation_get_anonymous(op: PGMountOperation): gboolean; cdecl; external LazGio2_library name 'g_mount_operation_get_anonymous';
function g_mount_operation_get_choice(op: PGMountOperation): gint; cdecl; external LazGio2_library name 'g_mount_operation_get_choice';
function g_mount_operation_get_domain(op: PGMountOperation): Pgchar; cdecl; external LazGio2_library name 'g_mount_operation_get_domain';
function g_mount_operation_get_is_tcrypt_hidden_volume(op: PGMountOperation): gboolean; cdecl; external LazGio2_library name 'g_mount_operation_get_is_tcrypt_hidden_volume';
function g_mount_operation_get_is_tcrypt_system_volume(op: PGMountOperation): gboolean; cdecl; external LazGio2_library name 'g_mount_operation_get_is_tcrypt_system_volume';
function g_mount_operation_get_password(op: PGMountOperation): Pgchar; cdecl; external LazGio2_library name 'g_mount_operation_get_password';
function g_mount_operation_get_password_save(op: PGMountOperation): TGPasswordSave; cdecl; external LazGio2_library name 'g_mount_operation_get_password_save';
function g_mount_operation_get_pim(op: PGMountOperation): guint; cdecl; external LazGio2_library name 'g_mount_operation_get_pim';
function g_mount_operation_get_type: TGType; cdecl; external LazGio2_library name 'g_mount_operation_get_type';
function g_mount_operation_get_username(op: PGMountOperation): Pgchar; cdecl; external LazGio2_library name 'g_mount_operation_get_username';
function g_mount_operation_new: PGMountOperation; cdecl; external LazGio2_library name 'g_mount_operation_new';
function g_mount_remount_finish(mount: PGMount; result_: PGAsyncResult; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_mount_remount_finish';
function g_mount_unmount_with_operation_finish(mount: PGMount; result_: PGAsyncResult; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_mount_unmount_with_operation_finish';
function g_native_socket_address_get_type: TGType; cdecl; external LazGio2_library name 'g_native_socket_address_get_type';
function g_native_socket_address_new(native: gpointer; len: gsize): PGNativeSocketAddress; cdecl; external LazGio2_library name 'g_native_socket_address_new';
function g_native_volume_monitor_get_type: TGType; cdecl; external LazGio2_library name 'g_native_volume_monitor_get_type';
function g_network_address_get_hostname(addr: PGNetworkAddress): Pgchar; cdecl; external LazGio2_library name 'g_network_address_get_hostname';
function g_network_address_get_port(addr: PGNetworkAddress): guint16; cdecl; external LazGio2_library name 'g_network_address_get_port';
function g_network_address_get_scheme(addr: PGNetworkAddress): Pgchar; cdecl; external LazGio2_library name 'g_network_address_get_scheme';
function g_network_address_get_type: TGType; cdecl; external LazGio2_library name 'g_network_address_get_type';
function g_network_address_new(hostname: Pgchar; port: guint16): PGNetworkAddress; cdecl; external LazGio2_library name 'g_network_address_new';
function g_network_address_new_loopback(port: guint16): PGNetworkAddress; cdecl; external LazGio2_library name 'g_network_address_new_loopback';
function g_network_address_parse(host_and_port: Pgchar; default_port: guint16; error: PPGError): PGNetworkAddress; cdecl; external LazGio2_library name 'g_network_address_parse';
function g_network_address_parse_uri(uri: Pgchar; default_port: guint16; error: PPGError): PGNetworkAddress; cdecl; external LazGio2_library name 'g_network_address_parse_uri';
function g_network_monitor_can_reach(monitor: PGNetworkMonitor; connectable: PGSocketConnectable; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_network_monitor_can_reach';
function g_network_monitor_can_reach_finish(monitor: PGNetworkMonitor; result_: PGAsyncResult; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_network_monitor_can_reach_finish';
function g_network_monitor_get_connectivity(monitor: PGNetworkMonitor): TGNetworkConnectivity; cdecl; external LazGio2_library name 'g_network_monitor_get_connectivity';
function g_network_monitor_get_default: PGNetworkMonitor; cdecl; external LazGio2_library name 'g_network_monitor_get_default';
function g_network_monitor_get_network_available(monitor: PGNetworkMonitor): gboolean; cdecl; external LazGio2_library name 'g_network_monitor_get_network_available';
function g_network_monitor_get_network_metered(monitor: PGNetworkMonitor): gboolean; cdecl; external LazGio2_library name 'g_network_monitor_get_network_metered';
function g_network_monitor_get_type: TGType; cdecl; external LazGio2_library name 'g_network_monitor_get_type';
function g_network_service_get_domain(srv: PGNetworkService): Pgchar; cdecl; external LazGio2_library name 'g_network_service_get_domain';
function g_network_service_get_protocol(srv: PGNetworkService): Pgchar; cdecl; external LazGio2_library name 'g_network_service_get_protocol';
function g_network_service_get_scheme(srv: PGNetworkService): Pgchar; cdecl; external LazGio2_library name 'g_network_service_get_scheme';
function g_network_service_get_service(srv: PGNetworkService): Pgchar; cdecl; external LazGio2_library name 'g_network_service_get_service';
function g_network_service_get_type: TGType; cdecl; external LazGio2_library name 'g_network_service_get_type';
function g_network_service_new(service: Pgchar; protocol: Pgchar; domain: Pgchar): PGNetworkService; cdecl; external LazGio2_library name 'g_network_service_new';
function g_notification_get_type: TGType; cdecl; external LazGio2_library name 'g_notification_get_type';
function g_notification_new(title: Pgchar): PGNotification; cdecl; external LazGio2_library name 'g_notification_new';
function g_null_settings_backend_new: PGSettingsBackend; cdecl; external LazGio2_library name 'g_null_settings_backend_new';
function g_output_stream_close(stream: PGOutputStream; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_output_stream_close';
function g_output_stream_close_finish(stream: PGOutputStream; result_: PGAsyncResult; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_output_stream_close_finish';
function g_output_stream_flush(stream: PGOutputStream; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_output_stream_flush';
function g_output_stream_flush_finish(stream: PGOutputStream; result_: PGAsyncResult; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_output_stream_flush_finish';
function g_output_stream_get_type: TGType; cdecl; external LazGio2_library name 'g_output_stream_get_type';
function g_output_stream_has_pending(stream: PGOutputStream): gboolean; cdecl; external LazGio2_library name 'g_output_stream_has_pending';
function g_output_stream_is_closed(stream: PGOutputStream): gboolean; cdecl; external LazGio2_library name 'g_output_stream_is_closed';
function g_output_stream_is_closing(stream: PGOutputStream): gboolean; cdecl; external LazGio2_library name 'g_output_stream_is_closing';
function g_output_stream_printf(stream: PGOutputStream; bytes_written: Pgsize; cancellable: PGCancellable; error: PPGError; format: Pgchar; args: array of const): gboolean; cdecl; external LazGio2_library name 'g_output_stream_printf';
function g_output_stream_set_pending(stream: PGOutputStream; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_output_stream_set_pending';
function g_output_stream_splice(stream: PGOutputStream; source: PGInputStream; flags: TGOutputStreamSpliceFlags; cancellable: PGCancellable; error: PPGError): gssize; cdecl; external LazGio2_library name 'g_output_stream_splice';
function g_output_stream_splice_finish(stream: PGOutputStream; result_: PGAsyncResult; error: PPGError): gssize; cdecl; external LazGio2_library name 'g_output_stream_splice_finish';
function g_output_stream_vprintf(stream: PGOutputStream; bytes_written: Pgsize; cancellable: PGCancellable; error: PPGError; format: Pgchar; args: Tva_list): gboolean; cdecl; external LazGio2_library name 'g_output_stream_vprintf';
function g_output_stream_write(stream: PGOutputStream; buffer: Pguint8; count: gsize; cancellable: PGCancellable; error: PPGError): gssize; cdecl; external LazGio2_library name 'g_output_stream_write';
function g_output_stream_write_all(stream: PGOutputStream; buffer: Pguint8; count: gsize; bytes_written: Pgsize; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_output_stream_write_all';
function g_output_stream_write_all_finish(stream: PGOutputStream; result_: PGAsyncResult; bytes_written: Pgsize; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_output_stream_write_all_finish';
function g_output_stream_write_bytes(stream: PGOutputStream; bytes: PGBytes; cancellable: PGCancellable; error: PPGError): gssize; cdecl; external LazGio2_library name 'g_output_stream_write_bytes';
function g_output_stream_write_bytes_finish(stream: PGOutputStream; result_: PGAsyncResult; error: PPGError): gssize; cdecl; external LazGio2_library name 'g_output_stream_write_bytes_finish';
function g_output_stream_write_finish(stream: PGOutputStream; result_: PGAsyncResult; error: PPGError): gssize; cdecl; external LazGio2_library name 'g_output_stream_write_finish';
function g_output_stream_writev(stream: PGOutputStream; vectors: PGOutputVector; n_vectors: gsize; bytes_written: Pgsize; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_output_stream_writev';
function g_output_stream_writev_all(stream: PGOutputStream; vectors: PGOutputVector; n_vectors: gsize; bytes_written: Pgsize; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_output_stream_writev_all';
function g_output_stream_writev_all_finish(stream: PGOutputStream; result_: PGAsyncResult; bytes_written: Pgsize; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_output_stream_writev_all_finish';
function g_output_stream_writev_finish(stream: PGOutputStream; result_: PGAsyncResult; bytes_written: Pgsize; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_output_stream_writev_finish';
function g_permission_acquire(permission: PGPermission; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_permission_acquire';
function g_permission_acquire_finish(permission: PGPermission; result_: PGAsyncResult; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_permission_acquire_finish';
function g_permission_get_allowed(permission: PGPermission): gboolean; cdecl; external LazGio2_library name 'g_permission_get_allowed';
function g_permission_get_can_acquire(permission: PGPermission): gboolean; cdecl; external LazGio2_library name 'g_permission_get_can_acquire';
function g_permission_get_can_release(permission: PGPermission): gboolean; cdecl; external LazGio2_library name 'g_permission_get_can_release';
function g_permission_get_type: TGType; cdecl; external LazGio2_library name 'g_permission_get_type';
function g_permission_release(permission: PGPermission; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_permission_release';
function g_permission_release_finish(permission: PGPermission; result_: PGAsyncResult; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_permission_release_finish';
function g_pollable_input_stream_can_poll(stream: PGPollableInputStream): gboolean; cdecl; external LazGio2_library name 'g_pollable_input_stream_can_poll';
function g_pollable_input_stream_create_source(stream: PGPollableInputStream; cancellable: PGCancellable): PGSource; cdecl; external LazGio2_library name 'g_pollable_input_stream_create_source';
function g_pollable_input_stream_get_type: TGType; cdecl; external LazGio2_library name 'g_pollable_input_stream_get_type';
function g_pollable_input_stream_is_readable(stream: PGPollableInputStream): gboolean; cdecl; external LazGio2_library name 'g_pollable_input_stream_is_readable';
function g_pollable_input_stream_read_nonblocking(stream: PGPollableInputStream; buffer: Pguint8; count: gsize; cancellable: PGCancellable; error: PPGError): gssize; cdecl; external LazGio2_library name 'g_pollable_input_stream_read_nonblocking';
function g_pollable_output_stream_can_poll(stream: PGPollableOutputStream): gboolean; cdecl; external LazGio2_library name 'g_pollable_output_stream_can_poll';
function g_pollable_output_stream_create_source(stream: PGPollableOutputStream; cancellable: PGCancellable): PGSource; cdecl; external LazGio2_library name 'g_pollable_output_stream_create_source';
function g_pollable_output_stream_get_type: TGType; cdecl; external LazGio2_library name 'g_pollable_output_stream_get_type';
function g_pollable_output_stream_is_writable(stream: PGPollableOutputStream): gboolean; cdecl; external LazGio2_library name 'g_pollable_output_stream_is_writable';
function g_pollable_output_stream_write_nonblocking(stream: PGPollableOutputStream; buffer: Pguint8; count: gsize; cancellable: PGCancellable; error: PPGError): gssize; cdecl; external LazGio2_library name 'g_pollable_output_stream_write_nonblocking';
function g_pollable_output_stream_writev_nonblocking(stream: PGPollableOutputStream; vectors: PGOutputVector; n_vectors: gsize; bytes_written: Pgsize; cancellable: PGCancellable; error: PPGError): TGPollableReturn; cdecl; external LazGio2_library name 'g_pollable_output_stream_writev_nonblocking';
function g_pollable_source_new(pollable_stream: PGObject): PGSource; cdecl; external LazGio2_library name 'g_pollable_source_new';
function g_pollable_source_new_full(pollable_stream: PGObject; child_source: PGSource; cancellable: PGCancellable): PGSource; cdecl; external LazGio2_library name 'g_pollable_source_new_full';
function g_pollable_stream_read(stream: PGInputStream; buffer: Pguint8; count: gsize; blocking: gboolean; cancellable: PGCancellable; error: PPGError): gssize; cdecl; external LazGio2_library name 'g_pollable_stream_read';
function g_pollable_stream_write(stream: PGOutputStream; buffer: Pguint8; count: gsize; blocking: gboolean; cancellable: PGCancellable; error: PPGError): gssize; cdecl; external LazGio2_library name 'g_pollable_stream_write';
function g_pollable_stream_write_all(stream: PGOutputStream; buffer: Pguint8; count: gsize; blocking: gboolean; bytes_written: Pgsize; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_pollable_stream_write_all';
function g_property_action_get_type: TGType; cdecl; external LazGio2_library name 'g_property_action_get_type';
function g_property_action_new(name: Pgchar; object_: PGObject; property_name: Pgchar): PGPropertyAction; cdecl; external LazGio2_library name 'g_property_action_new';
function g_proxy_address_enumerator_get_type: TGType; cdecl; external LazGio2_library name 'g_proxy_address_enumerator_get_type';
function g_proxy_address_get_destination_hostname(proxy: PGProxyAddress): Pgchar; cdecl; external LazGio2_library name 'g_proxy_address_get_destination_hostname';
function g_proxy_address_get_destination_port(proxy: PGProxyAddress): guint16; cdecl; external LazGio2_library name 'g_proxy_address_get_destination_port';
function g_proxy_address_get_destination_protocol(proxy: PGProxyAddress): Pgchar; cdecl; external LazGio2_library name 'g_proxy_address_get_destination_protocol';
function g_proxy_address_get_password(proxy: PGProxyAddress): Pgchar; cdecl; external LazGio2_library name 'g_proxy_address_get_password';
function g_proxy_address_get_protocol(proxy: PGProxyAddress): Pgchar; cdecl; external LazGio2_library name 'g_proxy_address_get_protocol';
function g_proxy_address_get_type: TGType; cdecl; external LazGio2_library name 'g_proxy_address_get_type';
function g_proxy_address_get_uri(proxy: PGProxyAddress): Pgchar; cdecl; external LazGio2_library name 'g_proxy_address_get_uri';
function g_proxy_address_get_username(proxy: PGProxyAddress): Pgchar; cdecl; external LazGio2_library name 'g_proxy_address_get_username';
function g_proxy_address_new(inetaddr: PGInetAddress; port: guint16; protocol: Pgchar; dest_hostname: Pgchar; dest_port: guint16; username: Pgchar; password: Pgchar): PGProxyAddress; cdecl; external LazGio2_library name 'g_proxy_address_new';
function g_proxy_connect(proxy: PGProxy; connection: PGIOStream; proxy_address: PGProxyAddress; cancellable: PGCancellable; error: PPGError): PGIOStream; cdecl; external LazGio2_library name 'g_proxy_connect';
function g_proxy_connect_finish(proxy: PGProxy; result_: PGAsyncResult; error: PPGError): PGIOStream; cdecl; external LazGio2_library name 'g_proxy_connect_finish';
function g_proxy_get_default_for_protocol(protocol: Pgchar): PGProxy; cdecl; external LazGio2_library name 'g_proxy_get_default_for_protocol';
function g_proxy_get_type: TGType; cdecl; external LazGio2_library name 'g_proxy_get_type';
function g_proxy_resolver_get_default: PGProxyResolver; cdecl; external LazGio2_library name 'g_proxy_resolver_get_default';
function g_proxy_resolver_get_type: TGType; cdecl; external LazGio2_library name 'g_proxy_resolver_get_type';
function g_proxy_resolver_is_supported(resolver: PGProxyResolver): gboolean; cdecl; external LazGio2_library name 'g_proxy_resolver_is_supported';
function g_proxy_resolver_lookup(resolver: PGProxyResolver; uri: Pgchar; cancellable: PGCancellable; error: PPGError): PPgchar; cdecl; external LazGio2_library name 'g_proxy_resolver_lookup';
function g_proxy_resolver_lookup_finish(resolver: PGProxyResolver; result_: PGAsyncResult; error: PPGError): PPgchar; cdecl; external LazGio2_library name 'g_proxy_resolver_lookup_finish';
function g_proxy_supports_hostname(proxy: PGProxy): gboolean; cdecl; external LazGio2_library name 'g_proxy_supports_hostname';
function g_remote_action_group_get_type: TGType; cdecl; external LazGio2_library name 'g_remote_action_group_get_type';
function g_resolver_error_quark: TGQuark; cdecl; external LazGio2_library name 'g_resolver_error_quark';
function g_resolver_get_default: PGResolver; cdecl; external LazGio2_library name 'g_resolver_get_default';
function g_resolver_get_type: TGType; cdecl; external LazGio2_library name 'g_resolver_get_type';
function g_resolver_lookup_by_address(resolver: PGResolver; address: PGInetAddress; cancellable: PGCancellable; error: PPGError): Pgchar; cdecl; external LazGio2_library name 'g_resolver_lookup_by_address';
function g_resolver_lookup_by_address_finish(resolver: PGResolver; result_: PGAsyncResult; error: PPGError): Pgchar; cdecl; external LazGio2_library name 'g_resolver_lookup_by_address_finish';
function g_resolver_lookup_by_name(resolver: PGResolver; hostname: Pgchar; cancellable: PGCancellable; error: PPGError): PGList; cdecl; external LazGio2_library name 'g_resolver_lookup_by_name';
function g_resolver_lookup_by_name_finish(resolver: PGResolver; result_: PGAsyncResult; error: PPGError): PGList; cdecl; external LazGio2_library name 'g_resolver_lookup_by_name_finish';
function g_resolver_lookup_by_name_with_flags(resolver: PGResolver; hostname: Pgchar; flags: TGResolverNameLookupFlags; cancellable: PGCancellable; error: PPGError): PGList; cdecl; external LazGio2_library name 'g_resolver_lookup_by_name_with_flags';
function g_resolver_lookup_by_name_with_flags_finish(resolver: PGResolver; result_: PGAsyncResult; error: PPGError): PGList; cdecl; external LazGio2_library name 'g_resolver_lookup_by_name_with_flags_finish';
function g_resolver_lookup_records(resolver: PGResolver; rrname: Pgchar; record_type: TGResolverRecordType; cancellable: PGCancellable; error: PPGError): PGList; cdecl; external LazGio2_library name 'g_resolver_lookup_records';
function g_resolver_lookup_records_finish(resolver: PGResolver; result_: PGAsyncResult; error: PPGError): PGList; cdecl; external LazGio2_library name 'g_resolver_lookup_records_finish';
function g_resolver_lookup_service(resolver: PGResolver; service: Pgchar; protocol: Pgchar; domain: Pgchar; cancellable: PGCancellable; error: PPGError): PGList; cdecl; external LazGio2_library name 'g_resolver_lookup_service';
function g_resolver_lookup_service_finish(resolver: PGResolver; result_: PGAsyncResult; error: PPGError): PGList; cdecl; external LazGio2_library name 'g_resolver_lookup_service_finish';
function g_resource_enumerate_children(resource: PGResource; path: Pgchar; lookup_flags: TGResourceLookupFlags; error: PPGError): PPgchar; cdecl; external LazGio2_library name 'g_resource_enumerate_children';
function g_resource_error_quark: TGQuark; cdecl; external LazGio2_library name 'g_resource_error_quark';
function g_resource_get_info(resource: PGResource; path: Pgchar; lookup_flags: TGResourceLookupFlags; size: Pgsize; flags: Pguint32; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_resource_get_info';
function g_resource_get_type: TGType; cdecl; external LazGio2_library name 'g_resource_get_type';
function g_resource_load(filename: Pgchar; error: PPGError): PGResource; cdecl; external LazGio2_library name 'g_resource_load';
function g_resource_lookup_data(resource: PGResource; path: Pgchar; lookup_flags: TGResourceLookupFlags; error: PPGError): PGBytes; cdecl; external LazGio2_library name 'g_resource_lookup_data';
function g_resource_new_from_data(data: PGBytes; error: PPGError): PGResource; cdecl; external LazGio2_library name 'g_resource_new_from_data';
function g_resource_open_stream(resource: PGResource; path: Pgchar; lookup_flags: TGResourceLookupFlags; error: PPGError): PGInputStream; cdecl; external LazGio2_library name 'g_resource_open_stream';
function g_resource_ref(resource: PGResource): PGResource; cdecl; external LazGio2_library name 'g_resource_ref';
function g_resources_enumerate_children(path: Pgchar; lookup_flags: TGResourceLookupFlags; error: PPGError): PPgchar; cdecl; external LazGio2_library name 'g_resources_enumerate_children';
function g_resources_get_info(path: Pgchar; lookup_flags: TGResourceLookupFlags; size: Pgsize; flags: Pguint32; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_resources_get_info';
function g_resources_lookup_data(path: Pgchar; lookup_flags: TGResourceLookupFlags; error: PPGError): PGBytes; cdecl; external LazGio2_library name 'g_resources_lookup_data';
function g_resources_open_stream(path: Pgchar; lookup_flags: TGResourceLookupFlags; error: PPGError): PGInputStream; cdecl; external LazGio2_library name 'g_resources_open_stream';
function g_seekable_can_seek(seekable: PGSeekable): gboolean; cdecl; external LazGio2_library name 'g_seekable_can_seek';
function g_seekable_can_truncate(seekable: PGSeekable): gboolean; cdecl; external LazGio2_library name 'g_seekable_can_truncate';
function g_seekable_get_type: TGType; cdecl; external LazGio2_library name 'g_seekable_get_type';
function g_seekable_seek(seekable: PGSeekable; offset: gint64; type_: TGSeekType; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_seekable_seek';
function g_seekable_tell(seekable: PGSeekable): gint64; cdecl; external LazGio2_library name 'g_seekable_tell';
function g_seekable_truncate(seekable: PGSeekable; offset: gint64; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_seekable_truncate';
function g_settings_backend_get_default: PGSettingsBackend; cdecl; external LazGio2_library name 'g_settings_backend_get_default';
function g_settings_backend_get_type: TGType; cdecl; external LazGio2_library name 'g_settings_backend_get_type';
function g_settings_create_action(settings: PGSettings; key: Pgchar): PGAction; cdecl; external LazGio2_library name 'g_settings_create_action';
function g_settings_get_boolean(settings: PGSettings; key: Pgchar): gboolean; cdecl; external LazGio2_library name 'g_settings_get_boolean';
function g_settings_get_child(settings: PGSettings; name: Pgchar): PGSettings; cdecl; external LazGio2_library name 'g_settings_get_child';
function g_settings_get_default_value(settings: PGSettings; key: Pgchar): PGVariant; cdecl; external LazGio2_library name 'g_settings_get_default_value';
function g_settings_get_double(settings: PGSettings; key: Pgchar): gdouble; cdecl; external LazGio2_library name 'g_settings_get_double';
function g_settings_get_enum(settings: PGSettings; key: Pgchar): gint; cdecl; external LazGio2_library name 'g_settings_get_enum';
function g_settings_get_flags(settings: PGSettings; key: Pgchar): guint; cdecl; external LazGio2_library name 'g_settings_get_flags';
function g_settings_get_has_unapplied(settings: PGSettings): gboolean; cdecl; external LazGio2_library name 'g_settings_get_has_unapplied';
function g_settings_get_int(settings: PGSettings; key: Pgchar): gint; cdecl; external LazGio2_library name 'g_settings_get_int';
function g_settings_get_int64(settings: PGSettings; key: Pgchar): gint64; cdecl; external LazGio2_library name 'g_settings_get_int64';
function g_settings_get_mapped(settings: PGSettings; key: Pgchar; mapping: TGSettingsGetMapping; user_data: gpointer): gpointer; cdecl; external LazGio2_library name 'g_settings_get_mapped';
function g_settings_get_string(settings: PGSettings; key: Pgchar): Pgchar; cdecl; external LazGio2_library name 'g_settings_get_string';
function g_settings_get_strv(settings: PGSettings; key: Pgchar): PPgchar; cdecl; external LazGio2_library name 'g_settings_get_strv';
function g_settings_get_type: TGType; cdecl; external LazGio2_library name 'g_settings_get_type';
function g_settings_get_uint(settings: PGSettings; key: Pgchar): guint; cdecl; external LazGio2_library name 'g_settings_get_uint';
function g_settings_get_uint64(settings: PGSettings; key: Pgchar): guint64; cdecl; external LazGio2_library name 'g_settings_get_uint64';
function g_settings_get_user_value(settings: PGSettings; key: Pgchar): PGVariant; cdecl; external LazGio2_library name 'g_settings_get_user_value';
function g_settings_get_value(settings: PGSettings; key: Pgchar): PGVariant; cdecl; external LazGio2_library name 'g_settings_get_value';
function g_settings_is_writable(settings: PGSettings; name: Pgchar): gboolean; cdecl; external LazGio2_library name 'g_settings_is_writable';
function g_settings_list_children(settings: PGSettings): PPgchar; cdecl; external LazGio2_library name 'g_settings_list_children';
function g_settings_new(schema_id: Pgchar): PGSettings; cdecl; external LazGio2_library name 'g_settings_new';
function g_settings_new_full(schema: PGSettingsSchema; backend: PGSettingsBackend; path: Pgchar): PGSettings; cdecl; external LazGio2_library name 'g_settings_new_full';
function g_settings_new_with_backend(schema_id: Pgchar; backend: PGSettingsBackend): PGSettings; cdecl; external LazGio2_library name 'g_settings_new_with_backend';
function g_settings_new_with_backend_and_path(schema_id: Pgchar; backend: PGSettingsBackend; path: Pgchar): PGSettings; cdecl; external LazGio2_library name 'g_settings_new_with_backend_and_path';
function g_settings_new_with_path(schema_id: Pgchar; path: Pgchar): PGSettings; cdecl; external LazGio2_library name 'g_settings_new_with_path';
function g_settings_schema_get_id(schema: PGSettingsSchema): Pgchar; cdecl; external LazGio2_library name 'g_settings_schema_get_id';
function g_settings_schema_get_key(schema: PGSettingsSchema; name: Pgchar): PGSettingsSchemaKey; cdecl; external LazGio2_library name 'g_settings_schema_get_key';
function g_settings_schema_get_path(schema: PGSettingsSchema): Pgchar; cdecl; external LazGio2_library name 'g_settings_schema_get_path';
function g_settings_schema_get_type: TGType; cdecl; external LazGio2_library name 'g_settings_schema_get_type';
function g_settings_schema_has_key(schema: PGSettingsSchema; name: Pgchar): gboolean; cdecl; external LazGio2_library name 'g_settings_schema_has_key';
function g_settings_schema_key_get_default_value(key: PGSettingsSchemaKey): PGVariant; cdecl; external LazGio2_library name 'g_settings_schema_key_get_default_value';
function g_settings_schema_key_get_description(key: PGSettingsSchemaKey): Pgchar; cdecl; external LazGio2_library name 'g_settings_schema_key_get_description';
function g_settings_schema_key_get_name(key: PGSettingsSchemaKey): Pgchar; cdecl; external LazGio2_library name 'g_settings_schema_key_get_name';
function g_settings_schema_key_get_range(key: PGSettingsSchemaKey): PGVariant; cdecl; external LazGio2_library name 'g_settings_schema_key_get_range';
function g_settings_schema_key_get_summary(key: PGSettingsSchemaKey): Pgchar; cdecl; external LazGio2_library name 'g_settings_schema_key_get_summary';
function g_settings_schema_key_get_type: TGType; cdecl; external LazGio2_library name 'g_settings_schema_key_get_type';
function g_settings_schema_key_get_value_type(key: PGSettingsSchemaKey): PGVariantType; cdecl; external LazGio2_library name 'g_settings_schema_key_get_value_type';
function g_settings_schema_key_range_check(key: PGSettingsSchemaKey; value: PGVariant): gboolean; cdecl; external LazGio2_library name 'g_settings_schema_key_range_check';
function g_settings_schema_key_ref(key: PGSettingsSchemaKey): PGSettingsSchemaKey; cdecl; external LazGio2_library name 'g_settings_schema_key_ref';
function g_settings_schema_list_children(schema: PGSettingsSchema): PPgchar; cdecl; external LazGio2_library name 'g_settings_schema_list_children';
function g_settings_schema_list_keys(schema: PGSettingsSchema): PPgchar; cdecl; external LazGio2_library name 'g_settings_schema_list_keys';
function g_settings_schema_ref(schema: PGSettingsSchema): PGSettingsSchema; cdecl; external LazGio2_library name 'g_settings_schema_ref';
function g_settings_schema_source_get_default: PGSettingsSchemaSource; cdecl; external LazGio2_library name 'g_settings_schema_source_get_default';
function g_settings_schema_source_get_type: TGType; cdecl; external LazGio2_library name 'g_settings_schema_source_get_type';
function g_settings_schema_source_lookup(source: PGSettingsSchemaSource; schema_id: Pgchar; recursive: gboolean): PGSettingsSchema; cdecl; external LazGio2_library name 'g_settings_schema_source_lookup';
function g_settings_schema_source_new_from_directory(directory: Pgchar; parent: PGSettingsSchemaSource; trusted: gboolean; error: PPGError): PGSettingsSchemaSource; cdecl; external LazGio2_library name 'g_settings_schema_source_new_from_directory';
function g_settings_schema_source_ref(source: PGSettingsSchemaSource): PGSettingsSchemaSource; cdecl; external LazGio2_library name 'g_settings_schema_source_ref';
function g_settings_set(settings: PGSettings; key: Pgchar; format: Pgchar; args: array of const): gboolean; cdecl; external LazGio2_library name 'g_settings_set';
function g_settings_set_boolean(settings: PGSettings; key: Pgchar; value: gboolean): gboolean; cdecl; external LazGio2_library name 'g_settings_set_boolean';
function g_settings_set_double(settings: PGSettings; key: Pgchar; value: gdouble): gboolean; cdecl; external LazGio2_library name 'g_settings_set_double';
function g_settings_set_enum(settings: PGSettings; key: Pgchar; value: gint): gboolean; cdecl; external LazGio2_library name 'g_settings_set_enum';
function g_settings_set_flags(settings: PGSettings; key: Pgchar; value: guint): gboolean; cdecl; external LazGio2_library name 'g_settings_set_flags';
function g_settings_set_int(settings: PGSettings; key: Pgchar; value: gint): gboolean; cdecl; external LazGio2_library name 'g_settings_set_int';
function g_settings_set_int64(settings: PGSettings; key: Pgchar; value: gint64): gboolean; cdecl; external LazGio2_library name 'g_settings_set_int64';
function g_settings_set_string(settings: PGSettings; key: Pgchar; value: Pgchar): gboolean; cdecl; external LazGio2_library name 'g_settings_set_string';
function g_settings_set_strv(settings: PGSettings; key: Pgchar; value: PPgchar): gboolean; cdecl; external LazGio2_library name 'g_settings_set_strv';
function g_settings_set_uint(settings: PGSettings; key: Pgchar; value: guint): gboolean; cdecl; external LazGio2_library name 'g_settings_set_uint';
function g_settings_set_uint64(settings: PGSettings; key: Pgchar; value: guint64): gboolean; cdecl; external LazGio2_library name 'g_settings_set_uint64';
function g_settings_set_value(settings: PGSettings; key: Pgchar; value: PGVariant): gboolean; cdecl; external LazGio2_library name 'g_settings_set_value';
function g_simple_action_get_type: TGType; cdecl; external LazGio2_library name 'g_simple_action_get_type';
function g_simple_action_group_get_type: TGType; cdecl; external LazGio2_library name 'g_simple_action_group_get_type';
function g_simple_action_group_new: PGSimpleActionGroup; cdecl; external LazGio2_library name 'g_simple_action_group_new';
function g_simple_action_new(name: Pgchar; parameter_type: PGVariantType): PGSimpleAction; cdecl; external LazGio2_library name 'g_simple_action_new';
function g_simple_action_new_stateful(name: Pgchar; parameter_type: PGVariantType; state: PGVariant): PGSimpleAction; cdecl; external LazGio2_library name 'g_simple_action_new_stateful';
function g_simple_async_result_get_type: TGType; cdecl; external LazGio2_library name 'g_simple_async_result_get_type';
function g_simple_io_stream_get_type: TGType; cdecl; external LazGio2_library name 'g_simple_io_stream_get_type';
function g_simple_io_stream_new(input_stream: PGInputStream; output_stream: PGOutputStream): PGSimpleIOStream; cdecl; external LazGio2_library name 'g_simple_io_stream_new';
function g_simple_permission_get_type: TGType; cdecl; external LazGio2_library name 'g_simple_permission_get_type';
function g_simple_permission_new(allowed: gboolean): PGSimplePermission; cdecl; external LazGio2_library name 'g_simple_permission_new';
function g_simple_proxy_resolver_get_type: TGType; cdecl; external LazGio2_library name 'g_simple_proxy_resolver_get_type';
function g_simple_proxy_resolver_new(default_proxy: Pgchar; ignore_hosts: PPgchar): PGProxyResolver; cdecl; external LazGio2_library name 'g_simple_proxy_resolver_new';
function g_socket_accept(socket: PGSocket; cancellable: PGCancellable; error: PPGError): PGSocket; cdecl; external LazGio2_library name 'g_socket_accept';
function g_socket_address_enumerator_get_type: TGType; cdecl; external LazGio2_library name 'g_socket_address_enumerator_get_type';
function g_socket_address_enumerator_next(enumerator: PGSocketAddressEnumerator; cancellable: PGCancellable; error: PPGError): PGSocketAddress; cdecl; external LazGio2_library name 'g_socket_address_enumerator_next';
function g_socket_address_enumerator_next_finish(enumerator: PGSocketAddressEnumerator; result_: PGAsyncResult; error: PPGError): PGSocketAddress; cdecl; external LazGio2_library name 'g_socket_address_enumerator_next_finish';
function g_socket_address_get_family(address: PGSocketAddress): TGSocketFamily; cdecl; external LazGio2_library name 'g_socket_address_get_family';
function g_socket_address_get_native_size(address: PGSocketAddress): gssize; cdecl; external LazGio2_library name 'g_socket_address_get_native_size';
function g_socket_address_get_type: TGType; cdecl; external LazGio2_library name 'g_socket_address_get_type';
function g_socket_address_new_from_native(native: gpointer; len: gsize): PGSocketAddress; cdecl; external LazGio2_library name 'g_socket_address_new_from_native';
function g_socket_address_to_native(address: PGSocketAddress; dest: gpointer; destlen: gsize; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_socket_address_to_native';
function g_socket_bind(socket: PGSocket; address: PGSocketAddress; allow_reuse: gboolean; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_socket_bind';
function g_socket_check_connect_result(socket: PGSocket; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_socket_check_connect_result';
function g_socket_client_connect(client: PGSocketClient; connectable: PGSocketConnectable; cancellable: PGCancellable; error: PPGError): PGSocketConnection; cdecl; external LazGio2_library name 'g_socket_client_connect';
function g_socket_client_connect_finish(client: PGSocketClient; result_: PGAsyncResult; error: PPGError): PGSocketConnection; cdecl; external LazGio2_library name 'g_socket_client_connect_finish';
function g_socket_client_connect_to_host(client: PGSocketClient; host_and_port: Pgchar; default_port: guint16; cancellable: PGCancellable; error: PPGError): PGSocketConnection; cdecl; external LazGio2_library name 'g_socket_client_connect_to_host';
function g_socket_client_connect_to_host_finish(client: PGSocketClient; result_: PGAsyncResult; error: PPGError): PGSocketConnection; cdecl; external LazGio2_library name 'g_socket_client_connect_to_host_finish';
function g_socket_client_connect_to_service(client: PGSocketClient; domain: Pgchar; service: Pgchar; cancellable: PGCancellable; error: PPGError): PGSocketConnection; cdecl; external LazGio2_library name 'g_socket_client_connect_to_service';
function g_socket_client_connect_to_service_finish(client: PGSocketClient; result_: PGAsyncResult; error: PPGError): PGSocketConnection; cdecl; external LazGio2_library name 'g_socket_client_connect_to_service_finish';
function g_socket_client_connect_to_uri(client: PGSocketClient; uri: Pgchar; default_port: guint16; cancellable: PGCancellable; error: PPGError): PGSocketConnection; cdecl; external LazGio2_library name 'g_socket_client_connect_to_uri';
function g_socket_client_connect_to_uri_finish(client: PGSocketClient; result_: PGAsyncResult; error: PPGError): PGSocketConnection; cdecl; external LazGio2_library name 'g_socket_client_connect_to_uri_finish';
function g_socket_client_get_enable_proxy(client: PGSocketClient): gboolean; cdecl; external LazGio2_library name 'g_socket_client_get_enable_proxy';
function g_socket_client_get_family(client: PGSocketClient): TGSocketFamily; cdecl; external LazGio2_library name 'g_socket_client_get_family';
function g_socket_client_get_local_address(client: PGSocketClient): PGSocketAddress; cdecl; external LazGio2_library name 'g_socket_client_get_local_address';
function g_socket_client_get_protocol(client: PGSocketClient): TGSocketProtocol; cdecl; external LazGio2_library name 'g_socket_client_get_protocol';
function g_socket_client_get_proxy_resolver(client: PGSocketClient): PGProxyResolver; cdecl; external LazGio2_library name 'g_socket_client_get_proxy_resolver';
function g_socket_client_get_socket_type(client: PGSocketClient): TGSocketType; cdecl; external LazGio2_library name 'g_socket_client_get_socket_type';
function g_socket_client_get_timeout(client: PGSocketClient): guint; cdecl; external LazGio2_library name 'g_socket_client_get_timeout';
function g_socket_client_get_tls(client: PGSocketClient): gboolean; cdecl; external LazGio2_library name 'g_socket_client_get_tls';
function g_socket_client_get_tls_validation_flags(client: PGSocketClient): TGTlsCertificateFlags; cdecl; external LazGio2_library name 'g_socket_client_get_tls_validation_flags'; deprecated 'Do not attempt to ignore validation errors.';
function g_socket_client_get_type: TGType; cdecl; external LazGio2_library name 'g_socket_client_get_type';
function g_socket_client_new: PGSocketClient; cdecl; external LazGio2_library name 'g_socket_client_new';
function g_socket_close(socket: PGSocket; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_socket_close';
function g_socket_condition_check(socket: PGSocket; condition: TGIOCondition): TGIOCondition; cdecl; external LazGio2_library name 'g_socket_condition_check';
function g_socket_condition_timed_wait(socket: PGSocket; condition: TGIOCondition; timeout_us: gint64; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_socket_condition_timed_wait';
function g_socket_condition_wait(socket: PGSocket; condition: TGIOCondition; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_socket_condition_wait';
function g_socket_connect(socket: PGSocket; address: PGSocketAddress; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_socket_connect';
function g_socket_connectable_enumerate(connectable: PGSocketConnectable): PGSocketAddressEnumerator; cdecl; external LazGio2_library name 'g_socket_connectable_enumerate';
function g_socket_connectable_get_type: TGType; cdecl; external LazGio2_library name 'g_socket_connectable_get_type';
function g_socket_connectable_proxy_enumerate(connectable: PGSocketConnectable): PGSocketAddressEnumerator; cdecl; external LazGio2_library name 'g_socket_connectable_proxy_enumerate';
function g_socket_connectable_to_string(connectable: PGSocketConnectable): Pgchar; cdecl; external LazGio2_library name 'g_socket_connectable_to_string';
function g_socket_connection_connect(connection: PGSocketConnection; address: PGSocketAddress; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_socket_connection_connect';
function g_socket_connection_connect_finish(connection: PGSocketConnection; result_: PGAsyncResult; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_socket_connection_connect_finish';
function g_socket_connection_factory_create_connection(socket: PGSocket): PGSocketConnection; cdecl; external LazGio2_library name 'g_socket_connection_factory_create_connection';
function g_socket_connection_factory_lookup_type(family: TGSocketFamily; type_: TGSocketType; protocol_id: gint): TGType; cdecl; external LazGio2_library name 'g_socket_connection_factory_lookup_type';
function g_socket_connection_get_local_address(connection: PGSocketConnection; error: PPGError): PGSocketAddress; cdecl; external LazGio2_library name 'g_socket_connection_get_local_address';
function g_socket_connection_get_remote_address(connection: PGSocketConnection; error: PPGError): PGSocketAddress; cdecl; external LazGio2_library name 'g_socket_connection_get_remote_address';
function g_socket_connection_get_socket(connection: PGSocketConnection): PGSocket; cdecl; external LazGio2_library name 'g_socket_connection_get_socket';
function g_socket_connection_get_type: TGType; cdecl; external LazGio2_library name 'g_socket_connection_get_type';
function g_socket_connection_is_connected(connection: PGSocketConnection): gboolean; cdecl; external LazGio2_library name 'g_socket_connection_is_connected';
function g_socket_control_message_deserialize(level: gint; type_: gint; size: gsize; data: guint8): PGSocketControlMessage; cdecl; external LazGio2_library name 'g_socket_control_message_deserialize';
function g_socket_control_message_get_level(message: PGSocketControlMessage): gint; cdecl; external LazGio2_library name 'g_socket_control_message_get_level';
function g_socket_control_message_get_msg_type(message: PGSocketControlMessage): gint; cdecl; external LazGio2_library name 'g_socket_control_message_get_msg_type';
function g_socket_control_message_get_size(message: PGSocketControlMessage): gsize; cdecl; external LazGio2_library name 'g_socket_control_message_get_size';
function g_socket_control_message_get_type: TGType; cdecl; external LazGio2_library name 'g_socket_control_message_get_type';
function g_socket_create_source(socket: PGSocket; condition: TGIOCondition; cancellable: PGCancellable): PGSource; cdecl; external LazGio2_library name 'g_socket_create_source';
function g_socket_get_available_bytes(socket: PGSocket): gssize; cdecl; external LazGio2_library name 'g_socket_get_available_bytes';
function g_socket_get_blocking(socket: PGSocket): gboolean; cdecl; external LazGio2_library name 'g_socket_get_blocking';
function g_socket_get_broadcast(socket: PGSocket): gboolean; cdecl; external LazGio2_library name 'g_socket_get_broadcast';
function g_socket_get_credentials(socket: PGSocket; error: PPGError): PGCredentials; cdecl; external LazGio2_library name 'g_socket_get_credentials';
function g_socket_get_family(socket: PGSocket): TGSocketFamily; cdecl; external LazGio2_library name 'g_socket_get_family';
function g_socket_get_fd(socket: PGSocket): gint; cdecl; external LazGio2_library name 'g_socket_get_fd';
function g_socket_get_keepalive(socket: PGSocket): gboolean; cdecl; external LazGio2_library name 'g_socket_get_keepalive';
function g_socket_get_listen_backlog(socket: PGSocket): gint; cdecl; external LazGio2_library name 'g_socket_get_listen_backlog';
function g_socket_get_local_address(socket: PGSocket; error: PPGError): PGSocketAddress; cdecl; external LazGio2_library name 'g_socket_get_local_address';
function g_socket_get_multicast_loopback(socket: PGSocket): gboolean; cdecl; external LazGio2_library name 'g_socket_get_multicast_loopback';
function g_socket_get_multicast_ttl(socket: PGSocket): guint; cdecl; external LazGio2_library name 'g_socket_get_multicast_ttl';
function g_socket_get_option(socket: PGSocket; level: gint; optname: gint; value: Pgint; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_socket_get_option';
function g_socket_get_protocol(socket: PGSocket): TGSocketProtocol; cdecl; external LazGio2_library name 'g_socket_get_protocol';
function g_socket_get_remote_address(socket: PGSocket; error: PPGError): PGSocketAddress; cdecl; external LazGio2_library name 'g_socket_get_remote_address';
function g_socket_get_socket_type(socket: PGSocket): TGSocketType; cdecl; external LazGio2_library name 'g_socket_get_socket_type';
function g_socket_get_timeout(socket: PGSocket): guint; cdecl; external LazGio2_library name 'g_socket_get_timeout';
function g_socket_get_ttl(socket: PGSocket): guint; cdecl; external LazGio2_library name 'g_socket_get_ttl';
function g_socket_get_type: TGType; cdecl; external LazGio2_library name 'g_socket_get_type';
function g_socket_is_closed(socket: PGSocket): gboolean; cdecl; external LazGio2_library name 'g_socket_is_closed';
function g_socket_is_connected(socket: PGSocket): gboolean; cdecl; external LazGio2_library name 'g_socket_is_connected';
function g_socket_join_multicast_group(socket: PGSocket; group: PGInetAddress; source_specific: gboolean; iface: Pgchar; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_socket_join_multicast_group';
function g_socket_join_multicast_group_ssm(socket: PGSocket; group: PGInetAddress; source_specific: PGInetAddress; iface: Pgchar; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_socket_join_multicast_group_ssm';
function g_socket_leave_multicast_group(socket: PGSocket; group: PGInetAddress; source_specific: gboolean; iface: Pgchar; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_socket_leave_multicast_group';
function g_socket_leave_multicast_group_ssm(socket: PGSocket; group: PGInetAddress; source_specific: PGInetAddress; iface: Pgchar; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_socket_leave_multicast_group_ssm';
function g_socket_listen(socket: PGSocket; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_socket_listen';
function g_socket_listener_accept(listener: PGSocketListener; source_object: PPGObject; cancellable: PGCancellable; error: PPGError): PGSocketConnection; cdecl; external LazGio2_library name 'g_socket_listener_accept';
function g_socket_listener_accept_finish(listener: PGSocketListener; result_: PGAsyncResult; source_object: PPGObject; error: PPGError): PGSocketConnection; cdecl; external LazGio2_library name 'g_socket_listener_accept_finish';
function g_socket_listener_accept_socket(listener: PGSocketListener; source_object: PPGObject; cancellable: PGCancellable; error: PPGError): PGSocket; cdecl; external LazGio2_library name 'g_socket_listener_accept_socket';
function g_socket_listener_accept_socket_finish(listener: PGSocketListener; result_: PGAsyncResult; source_object: PPGObject; error: PPGError): PGSocket; cdecl; external LazGio2_library name 'g_socket_listener_accept_socket_finish';
function g_socket_listener_add_address(listener: PGSocketListener; address: PGSocketAddress; type_: TGSocketType; protocol: TGSocketProtocol; source_object: PGObject; effective_address: PPGSocketAddress; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_socket_listener_add_address';
function g_socket_listener_add_any_inet_port(listener: PGSocketListener; source_object: PGObject; error: PPGError): guint16; cdecl; external LazGio2_library name 'g_socket_listener_add_any_inet_port';
function g_socket_listener_add_inet_port(listener: PGSocketListener; port: guint16; source_object: PGObject; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_socket_listener_add_inet_port';
function g_socket_listener_add_socket(listener: PGSocketListener; socket: PGSocket; source_object: PGObject; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_socket_listener_add_socket';
function g_socket_listener_get_type: TGType; cdecl; external LazGio2_library name 'g_socket_listener_get_type';
function g_socket_listener_new: PGSocketListener; cdecl; external LazGio2_library name 'g_socket_listener_new';
function g_socket_new(family: TGSocketFamily; type_: TGSocketType; protocol: TGSocketProtocol; error: PPGError): PGSocket; cdecl; external LazGio2_library name 'g_socket_new';
function g_socket_new_from_fd(fd: gint; error: PPGError): PGSocket; cdecl; external LazGio2_library name 'g_socket_new_from_fd';
function g_socket_receive(socket: PGSocket; buffer: Pgchar; size: Pgsize; cancellable: PGCancellable; error: PPGError): gssize; cdecl; external LazGio2_library name 'g_socket_receive';
function g_socket_receive_from(socket: PGSocket; address: PPGSocketAddress; buffer: Pgchar; size: Pgsize; cancellable: PGCancellable; error: PPGError): gssize; cdecl; external LazGio2_library name 'g_socket_receive_from';
function g_socket_receive_message(socket: PGSocket; address: PPGSocketAddress; vectors: PGInputVector; num_vectors: gint; messages: PPPGSocketControlMessage; num_messages: Pgint; flags: Pgint; cancellable: PGCancellable; error: PPGError): gssize; cdecl; external LazGio2_library name 'g_socket_receive_message';
function g_socket_receive_messages(socket: PGSocket; messages: PGInputMessage; num_messages: guint; flags: gint; cancellable: PGCancellable; error: PPGError): gint; cdecl; external LazGio2_library name 'g_socket_receive_messages';
function g_socket_receive_with_blocking(socket: PGSocket; buffer: Pgchar; size: Pgsize; blocking: gboolean; cancellable: PGCancellable; error: PPGError): gssize; cdecl; external LazGio2_library name 'g_socket_receive_with_blocking';
function g_socket_send(socket: PGSocket; buffer: Pgchar; size: gsize; cancellable: PGCancellable; error: PPGError): gssize; cdecl; external LazGio2_library name 'g_socket_send';
function g_socket_send_message(socket: PGSocket; address: PGSocketAddress; vectors: PGOutputVector; num_vectors: gint; messages: PPGSocketControlMessage; num_messages: gint; flags: gint; cancellable: PGCancellable; error: PPGError): gssize; cdecl; external LazGio2_library name 'g_socket_send_message';
function g_socket_send_message_with_timeout(socket: PGSocket; address: PGSocketAddress; vectors: PGOutputVector; num_vectors: gint; messages: PPGSocketControlMessage; num_messages: gint; flags: gint; timeout_us: gint64; bytes_written: Pgsize; cancellable: PGCancellable; error: PPGError): TGPollableReturn; cdecl; external LazGio2_library name 'g_socket_send_message_with_timeout';
function g_socket_send_messages(socket: PGSocket; messages: PGOutputMessage; num_messages: guint; flags: gint; cancellable: PGCancellable; error: PPGError): gint; cdecl; external LazGio2_library name 'g_socket_send_messages';
function g_socket_send_to(socket: PGSocket; address: PGSocketAddress; buffer: Pgchar; size: gsize; cancellable: PGCancellable; error: PPGError): gssize; cdecl; external LazGio2_library name 'g_socket_send_to';
function g_socket_send_with_blocking(socket: PGSocket; buffer: Pgchar; size: gsize; blocking: gboolean; cancellable: PGCancellable; error: PPGError): gssize; cdecl; external LazGio2_library name 'g_socket_send_with_blocking';
function g_socket_service_get_type: TGType; cdecl; external LazGio2_library name 'g_socket_service_get_type';
function g_socket_service_is_active(service: PGSocketService): gboolean; cdecl; external LazGio2_library name 'g_socket_service_is_active';
function g_socket_service_new: PGSocketService; cdecl; external LazGio2_library name 'g_socket_service_new';
function g_socket_set_option(socket: PGSocket; level: gint; optname: gint; value: gint; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_socket_set_option';
function g_socket_shutdown(socket: PGSocket; shutdown_read: gboolean; shutdown_write: gboolean; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_socket_shutdown';
function g_socket_speaks_ipv4(socket: PGSocket): gboolean; cdecl; external LazGio2_library name 'g_socket_speaks_ipv4';
function g_srv_target_copy(target: PGSrvTarget): PGSrvTarget; cdecl; external LazGio2_library name 'g_srv_target_copy';
function g_srv_target_get_hostname(target: PGSrvTarget): Pgchar; cdecl; external LazGio2_library name 'g_srv_target_get_hostname';
function g_srv_target_get_port(target: PGSrvTarget): guint16; cdecl; external LazGio2_library name 'g_srv_target_get_port';
function g_srv_target_get_priority(target: PGSrvTarget): guint16; cdecl; external LazGio2_library name 'g_srv_target_get_priority';
function g_srv_target_get_type: TGType; cdecl; external LazGio2_library name 'g_srv_target_get_type';
function g_srv_target_get_weight(target: PGSrvTarget): guint16; cdecl; external LazGio2_library name 'g_srv_target_get_weight';
function g_srv_target_list_sort(targets: PGList): PGList; cdecl; external LazGio2_library name 'g_srv_target_list_sort';
function g_srv_target_new(hostname: Pgchar; port: guint16; priority: guint16; weight: guint16): PGSrvTarget; cdecl; external LazGio2_library name 'g_srv_target_new';
function g_static_resource_get_resource(static_resource: PGStaticResource): PGResource; cdecl; external LazGio2_library name 'g_static_resource_get_resource';
function g_subprocess_communicate(subprocess: PGSubprocess; stdin_buf: PGBytes; cancellable: PGCancellable; stdout_buf: PPGBytes; stderr_buf: PPGBytes; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_subprocess_communicate';
function g_subprocess_communicate_finish(subprocess: PGSubprocess; result_: PGAsyncResult; stdout_buf: PPGBytes; stderr_buf: PPGBytes; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_subprocess_communicate_finish';
function g_subprocess_communicate_utf8(subprocess: PGSubprocess; stdin_buf: Pgchar; cancellable: PGCancellable; stdout_buf: PPgchar; stderr_buf: PPgchar; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_subprocess_communicate_utf8';
function g_subprocess_communicate_utf8_finish(subprocess: PGSubprocess; result_: PGAsyncResult; stdout_buf: PPgchar; stderr_buf: PPgchar; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_subprocess_communicate_utf8_finish';
function g_subprocess_get_exit_status(subprocess: PGSubprocess): gint; cdecl; external LazGio2_library name 'g_subprocess_get_exit_status';
function g_subprocess_get_identifier(subprocess: PGSubprocess): Pgchar; cdecl; external LazGio2_library name 'g_subprocess_get_identifier';
function g_subprocess_get_if_exited(subprocess: PGSubprocess): gboolean; cdecl; external LazGio2_library name 'g_subprocess_get_if_exited';
function g_subprocess_get_if_signaled(subprocess: PGSubprocess): gboolean; cdecl; external LazGio2_library name 'g_subprocess_get_if_signaled';
function g_subprocess_get_status(subprocess: PGSubprocess): gint; cdecl; external LazGio2_library name 'g_subprocess_get_status';
function g_subprocess_get_stderr_pipe(subprocess: PGSubprocess): PGInputStream; cdecl; external LazGio2_library name 'g_subprocess_get_stderr_pipe';
function g_subprocess_get_stdin_pipe(subprocess: PGSubprocess): PGOutputStream; cdecl; external LazGio2_library name 'g_subprocess_get_stdin_pipe';
function g_subprocess_get_stdout_pipe(subprocess: PGSubprocess): PGInputStream; cdecl; external LazGio2_library name 'g_subprocess_get_stdout_pipe';
function g_subprocess_get_successful(subprocess: PGSubprocess): gboolean; cdecl; external LazGio2_library name 'g_subprocess_get_successful';
function g_subprocess_get_term_sig(subprocess: PGSubprocess): gint; cdecl; external LazGio2_library name 'g_subprocess_get_term_sig';
function g_subprocess_get_type: TGType; cdecl; external LazGio2_library name 'g_subprocess_get_type';
function g_subprocess_launcher_get_type: TGType; cdecl; external LazGio2_library name 'g_subprocess_launcher_get_type';
function g_subprocess_launcher_getenv(self: PGSubprocessLauncher; variable: Pgchar): Pgchar; cdecl; external LazGio2_library name 'g_subprocess_launcher_getenv';
function g_subprocess_launcher_new(flags: TGSubprocessFlags): PGSubprocessLauncher; cdecl; external LazGio2_library name 'g_subprocess_launcher_new';
function g_subprocess_launcher_spawn(self: PGSubprocessLauncher; error: PPGError; argv0: Pgchar; args: array of const): PGSubprocess; cdecl; external LazGio2_library name 'g_subprocess_launcher_spawn';
function g_subprocess_launcher_spawnv(self: PGSubprocessLauncher; argv: PPgchar; error: PPGError): PGSubprocess; cdecl; external LazGio2_library name 'g_subprocess_launcher_spawnv';
function g_subprocess_new(flags: TGSubprocessFlags; error: PPGError; argv0: Pgchar; args: array of const): PGSubprocess; cdecl; external LazGio2_library name 'g_subprocess_new';
function g_subprocess_newv(argv: PPgchar; flags: TGSubprocessFlags; error: PPGError): PGSubprocess; cdecl; external LazGio2_library name 'g_subprocess_newv';
function g_subprocess_wait(subprocess: PGSubprocess; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_subprocess_wait';
function g_subprocess_wait_check(subprocess: PGSubprocess; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_subprocess_wait_check';
function g_subprocess_wait_check_finish(subprocess: PGSubprocess; result_: PGAsyncResult; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_subprocess_wait_check_finish';
function g_subprocess_wait_finish(subprocess: PGSubprocess; result_: PGAsyncResult; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_subprocess_wait_finish';
function g_task_get_cancellable(task: PGTask): PGCancellable; cdecl; external LazGio2_library name 'g_task_get_cancellable';
function g_task_get_check_cancellable(task: PGTask): gboolean; cdecl; external LazGio2_library name 'g_task_get_check_cancellable';
function g_task_get_completed(task: PGTask): gboolean; cdecl; external LazGio2_library name 'g_task_get_completed';
function g_task_get_context(task: PGTask): PGMainContext; cdecl; external LazGio2_library name 'g_task_get_context';
function g_task_get_name(task: PGTask): Pgchar; cdecl; external LazGio2_library name 'g_task_get_name';
function g_task_get_priority(task: PGTask): gint; cdecl; external LazGio2_library name 'g_task_get_priority';
function g_task_get_return_on_cancel(task: PGTask): gboolean; cdecl; external LazGio2_library name 'g_task_get_return_on_cancel';
function g_task_get_source_object(task: PGTask): PGObject; cdecl; external LazGio2_library name 'g_task_get_source_object';
function g_task_get_source_tag(task: PGTask): gpointer; cdecl; external LazGio2_library name 'g_task_get_source_tag';
function g_task_get_task_data(task: PGTask): gpointer; cdecl; external LazGio2_library name 'g_task_get_task_data';
function g_task_get_type: TGType; cdecl; external LazGio2_library name 'g_task_get_type';
function g_task_had_error(task: PGTask): gboolean; cdecl; external LazGio2_library name 'g_task_had_error';
function g_task_is_valid(result_: PGAsyncResult; source_object: PGObject): gboolean; cdecl; external LazGio2_library name 'g_task_is_valid';
function g_task_new(source_object: PGObject; cancellable: PGCancellable; callback: TGAsyncReadyCallback; callback_data: gpointer): PGTask; cdecl; external LazGio2_library name 'g_task_new';
function g_task_propagate_boolean(task: PGTask; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_task_propagate_boolean';
function g_task_propagate_int(task: PGTask; error: PPGError): gssize; cdecl; external LazGio2_library name 'g_task_propagate_int';
function g_task_propagate_pointer(task: PGTask; error: PPGError): gpointer; cdecl; external LazGio2_library name 'g_task_propagate_pointer';
function g_task_propagate_value(task: PGTask; value: PGValue; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_task_propagate_value';
function g_task_return_error_if_cancelled(task: PGTask): gboolean; cdecl; external LazGio2_library name 'g_task_return_error_if_cancelled';
function g_task_set_return_on_cancel(task: PGTask; return_on_cancel: gboolean): gboolean; cdecl; external LazGio2_library name 'g_task_set_return_on_cancel';
function g_tcp_connection_get_graceful_disconnect(connection: PGTcpConnection): gboolean; cdecl; external LazGio2_library name 'g_tcp_connection_get_graceful_disconnect';
function g_tcp_connection_get_type: TGType; cdecl; external LazGio2_library name 'g_tcp_connection_get_type';
function g_tcp_wrapper_connection_get_base_io_stream(conn: PGTcpWrapperConnection): PGIOStream; cdecl; external LazGio2_library name 'g_tcp_wrapper_connection_get_base_io_stream';
function g_tcp_wrapper_connection_get_type: TGType; cdecl; external LazGio2_library name 'g_tcp_wrapper_connection_get_type';
function g_tcp_wrapper_connection_new(base_io_stream: PGIOStream; socket: PGSocket): PGTcpWrapperConnection; cdecl; external LazGio2_library name 'g_tcp_wrapper_connection_new';
function g_test_dbus_get_bus_address(self: PGTestDBus): Pgchar; cdecl; external LazGio2_library name 'g_test_dbus_get_bus_address';
function g_test_dbus_get_flags(self: PGTestDBus): TGTestDBusFlags; cdecl; external LazGio2_library name 'g_test_dbus_get_flags';
function g_test_dbus_get_type: TGType; cdecl; external LazGio2_library name 'g_test_dbus_get_type';
function g_test_dbus_new(flags: TGTestDBusFlags): PGTestDBus; cdecl; external LazGio2_library name 'g_test_dbus_new';
function g_themed_icon_get_names(icon: PGThemedIcon): PPgchar; cdecl; external LazGio2_library name 'g_themed_icon_get_names';
function g_themed_icon_get_type: TGType; cdecl; external LazGio2_library name 'g_themed_icon_get_type';
function g_themed_icon_new(iconname: Pgchar): PGThemedIcon; cdecl; external LazGio2_library name 'g_themed_icon_new';
function g_themed_icon_new_from_names(iconnames: PPgchar; len: gint): PGThemedIcon; cdecl; external LazGio2_library name 'g_themed_icon_new_from_names';
function g_themed_icon_new_with_default_fallbacks(iconname: Pgchar): PGThemedIcon; cdecl; external LazGio2_library name 'g_themed_icon_new_with_default_fallbacks';
function g_threaded_socket_service_get_type: TGType; cdecl; external LazGio2_library name 'g_threaded_socket_service_get_type';
function g_threaded_socket_service_new(max_threads: gint): PGThreadedSocketService; cdecl; external LazGio2_library name 'g_threaded_socket_service_new';
function g_tls_backend_get_certificate_type(backend: PGTlsBackend): TGType; cdecl; external LazGio2_library name 'g_tls_backend_get_certificate_type';
function g_tls_backend_get_client_connection_type(backend: PGTlsBackend): TGType; cdecl; external LazGio2_library name 'g_tls_backend_get_client_connection_type';
function g_tls_backend_get_default: PGTlsBackend; cdecl; external LazGio2_library name 'g_tls_backend_get_default';
function g_tls_backend_get_default_database(backend: PGTlsBackend): PGTlsDatabase; cdecl; external LazGio2_library name 'g_tls_backend_get_default_database';
function g_tls_backend_get_dtls_client_connection_type(backend: PGTlsBackend): TGType; cdecl; external LazGio2_library name 'g_tls_backend_get_dtls_client_connection_type';
function g_tls_backend_get_dtls_server_connection_type(backend: PGTlsBackend): TGType; cdecl; external LazGio2_library name 'g_tls_backend_get_dtls_server_connection_type';
function g_tls_backend_get_file_database_type(backend: PGTlsBackend): TGType; cdecl; external LazGio2_library name 'g_tls_backend_get_file_database_type';
function g_tls_backend_get_server_connection_type(backend: PGTlsBackend): TGType; cdecl; external LazGio2_library name 'g_tls_backend_get_server_connection_type';
function g_tls_backend_get_type: TGType; cdecl; external LazGio2_library name 'g_tls_backend_get_type';
function g_tls_backend_supports_dtls(backend: PGTlsBackend): gboolean; cdecl; external LazGio2_library name 'g_tls_backend_supports_dtls';
function g_tls_backend_supports_tls(backend: PGTlsBackend): gboolean; cdecl; external LazGio2_library name 'g_tls_backend_supports_tls';
function g_tls_certificate_get_issuer(cert: PGTlsCertificate): PGTlsCertificate; cdecl; external LazGio2_library name 'g_tls_certificate_get_issuer';
function g_tls_certificate_get_type: TGType; cdecl; external LazGio2_library name 'g_tls_certificate_get_type';
function g_tls_certificate_is_same(cert_one: PGTlsCertificate; cert_two: PGTlsCertificate): gboolean; cdecl; external LazGio2_library name 'g_tls_certificate_is_same';
function g_tls_certificate_list_new_from_file(file_: Pgchar; error: PPGError): PGList; cdecl; external LazGio2_library name 'g_tls_certificate_list_new_from_file';
function g_tls_certificate_new_from_file(file_: Pgchar; error: PPGError): PGTlsCertificate; cdecl; external LazGio2_library name 'g_tls_certificate_new_from_file';
function g_tls_certificate_new_from_files(cert_file: Pgchar; key_file: Pgchar; error: PPGError): PGTlsCertificate; cdecl; external LazGio2_library name 'g_tls_certificate_new_from_files';
function g_tls_certificate_new_from_pem(data: Pgchar; length: gssize; error: PPGError): PGTlsCertificate; cdecl; external LazGio2_library name 'g_tls_certificate_new_from_pem';
function g_tls_certificate_verify(cert: PGTlsCertificate; identity: PGSocketConnectable; trusted_ca: PGTlsCertificate): TGTlsCertificateFlags; cdecl; external LazGio2_library name 'g_tls_certificate_verify';
function g_tls_channel_binding_error_quark: TGQuark; cdecl; external LazGio2_library name 'g_tls_channel_binding_error_quark';
function g_tls_client_connection_get_accepted_cas(conn: PGTlsClientConnection): PGList; cdecl; external LazGio2_library name 'g_tls_client_connection_get_accepted_cas';
function g_tls_client_connection_get_server_identity(conn: PGTlsClientConnection): PGSocketConnectable; cdecl; external LazGio2_library name 'g_tls_client_connection_get_server_identity';
function g_tls_client_connection_get_type: TGType; cdecl; external LazGio2_library name 'g_tls_client_connection_get_type';
function g_tls_client_connection_get_validation_flags(conn: PGTlsClientConnection): TGTlsCertificateFlags; cdecl; external LazGio2_library name 'g_tls_client_connection_get_validation_flags'; deprecated 'Do not attempt to ignore validation errors.';
function g_tls_client_connection_new(base_io_stream: PGIOStream; server_identity: PGSocketConnectable; error: PPGError): PGTlsClientConnection; cdecl; external LazGio2_library name 'g_tls_client_connection_new';
function g_tls_connection_emit_accept_certificate(conn: PGTlsConnection; peer_cert: PGTlsCertificate; errors: TGTlsCertificateFlags): gboolean; cdecl; external LazGio2_library name 'g_tls_connection_emit_accept_certificate';
function g_tls_connection_get_certificate(conn: PGTlsConnection): PGTlsCertificate; cdecl; external LazGio2_library name 'g_tls_connection_get_certificate';
{$IFDEF USEGTK3LATESTBINDINGS}
function g_tls_connection_get_channel_binding_data(conn: PGTlsConnection; type_: TGTlsChannelBindingType; data: Pguint8; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_tls_connection_get_channel_binding_data';
{$ENDIF}
function g_tls_connection_get_database(conn: PGTlsConnection): PGTlsDatabase; cdecl; external LazGio2_library name 'g_tls_connection_get_database';
function g_tls_connection_get_interaction(conn: PGTlsConnection): PGTlsInteraction; cdecl; external LazGio2_library name 'g_tls_connection_get_interaction';
function g_tls_connection_get_negotiated_protocol(conn: PGTlsConnection): Pgchar; cdecl; external LazGio2_library name 'g_tls_connection_get_negotiated_protocol';
function g_tls_connection_get_peer_certificate(conn: PGTlsConnection): PGTlsCertificate; cdecl; external LazGio2_library name 'g_tls_connection_get_peer_certificate';
function g_tls_connection_get_peer_certificate_errors(conn: PGTlsConnection): TGTlsCertificateFlags; cdecl; external LazGio2_library name 'g_tls_connection_get_peer_certificate_errors';
function g_tls_connection_get_require_close_notify(conn: PGTlsConnection): gboolean; cdecl; external LazGio2_library name 'g_tls_connection_get_require_close_notify';
function g_tls_connection_get_type: TGType; cdecl; external LazGio2_library name 'g_tls_connection_get_type';
function g_tls_connection_handshake(conn: PGTlsConnection; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_tls_connection_handshake';
function g_tls_connection_handshake_finish(conn: PGTlsConnection; result_: PGAsyncResult; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_tls_connection_handshake_finish';
function g_tls_database_create_certificate_handle(self: PGTlsDatabase; certificate: PGTlsCertificate): Pgchar; cdecl; external LazGio2_library name 'g_tls_database_create_certificate_handle';
function g_tls_database_get_type: TGType; cdecl; external LazGio2_library name 'g_tls_database_get_type';
function g_tls_database_lookup_certificate_for_handle(self: PGTlsDatabase; handle: Pgchar; interaction: PGTlsInteraction; flags: TGTlsDatabaseLookupFlags; cancellable: PGCancellable; error: PPGError): PGTlsCertificate; cdecl; external LazGio2_library name 'g_tls_database_lookup_certificate_for_handle';
function g_tls_database_lookup_certificate_for_handle_finish(self: PGTlsDatabase; result_: PGAsyncResult; error: PPGError): PGTlsCertificate; cdecl; external LazGio2_library name 'g_tls_database_lookup_certificate_for_handle_finish';
function g_tls_database_lookup_certificate_issuer(self: PGTlsDatabase; certificate: PGTlsCertificate; interaction: PGTlsInteraction; flags: TGTlsDatabaseLookupFlags; cancellable: PGCancellable; error: PPGError): PGTlsCertificate; cdecl; external LazGio2_library name 'g_tls_database_lookup_certificate_issuer';
function g_tls_database_lookup_certificate_issuer_finish(self: PGTlsDatabase; result_: PGAsyncResult; error: PPGError): PGTlsCertificate; cdecl; external LazGio2_library name 'g_tls_database_lookup_certificate_issuer_finish';
function g_tls_database_lookup_certificates_issued_by(self: PGTlsDatabase; issuer_raw_dn: Pguint8; interaction: PGTlsInteraction; flags: TGTlsDatabaseLookupFlags; cancellable: PGCancellable; error: PPGError): PGList; cdecl; external LazGio2_library name 'g_tls_database_lookup_certificates_issued_by';
function g_tls_database_lookup_certificates_issued_by_finish(self: PGTlsDatabase; result_: PGAsyncResult; error: PPGError): PGList; cdecl; external LazGio2_library name 'g_tls_database_lookup_certificates_issued_by_finish';
function g_tls_database_verify_chain(self: PGTlsDatabase; chain: PGTlsCertificate; purpose: Pgchar; identity: PGSocketConnectable; interaction: PGTlsInteraction; flags: TGTlsDatabaseVerifyFlags; cancellable: PGCancellable; error: PPGError): TGTlsCertificateFlags; cdecl; external LazGio2_library name 'g_tls_database_verify_chain';
function g_tls_database_verify_chain_finish(self: PGTlsDatabase; result_: PGAsyncResult; error: PPGError): TGTlsCertificateFlags; cdecl; external LazGio2_library name 'g_tls_database_verify_chain_finish';
function g_tls_error_quark: TGQuark; cdecl; external LazGio2_library name 'g_tls_error_quark';
function g_tls_file_database_get_type: TGType; cdecl; external LazGio2_library name 'g_tls_file_database_get_type';
function g_tls_file_database_new(anchors: Pgchar; error: PPGError): PGTlsFileDatabase; cdecl; external LazGio2_library name 'g_tls_file_database_new';
function g_tls_interaction_ask_password(interaction: PGTlsInteraction; password: PGTlsPassword; cancellable: PGCancellable; error: PPGError): TGTlsInteractionResult; cdecl; external LazGio2_library name 'g_tls_interaction_ask_password';
function g_tls_interaction_ask_password_finish(interaction: PGTlsInteraction; result_: PGAsyncResult; error: PPGError): TGTlsInteractionResult; cdecl; external LazGio2_library name 'g_tls_interaction_ask_password_finish';
function g_tls_interaction_get_type: TGType; cdecl; external LazGio2_library name 'g_tls_interaction_get_type';
function g_tls_interaction_invoke_ask_password(interaction: PGTlsInteraction; password: PGTlsPassword; cancellable: PGCancellable; error: PPGError): TGTlsInteractionResult; cdecl; external LazGio2_library name 'g_tls_interaction_invoke_ask_password';
function g_tls_interaction_invoke_request_certificate(interaction: PGTlsInteraction; connection: PGTlsConnection; flags: TGTlsCertificateRequestFlags; cancellable: PGCancellable; error: PPGError): TGTlsInteractionResult; cdecl; external LazGio2_library name 'g_tls_interaction_invoke_request_certificate';
function g_tls_interaction_request_certificate(interaction: PGTlsInteraction; connection: PGTlsConnection; flags: TGTlsCertificateRequestFlags; cancellable: PGCancellable; error: PPGError): TGTlsInteractionResult; cdecl; external LazGio2_library name 'g_tls_interaction_request_certificate';
function g_tls_interaction_request_certificate_finish(interaction: PGTlsInteraction; result_: PGAsyncResult; error: PPGError): TGTlsInteractionResult; cdecl; external LazGio2_library name 'g_tls_interaction_request_certificate_finish';
function g_tls_password_get_description(password: PGTlsPassword): Pgchar; cdecl; external LazGio2_library name 'g_tls_password_get_description';
function g_tls_password_get_flags(password: PGTlsPassword): TGTlsPasswordFlags; cdecl; external LazGio2_library name 'g_tls_password_get_flags';
function g_tls_password_get_type: TGType; cdecl; external LazGio2_library name 'g_tls_password_get_type';
function g_tls_password_get_value(password: PGTlsPassword; length: Pgsize): Pguint8; cdecl; external LazGio2_library name 'g_tls_password_get_value';
function g_tls_password_get_warning(password: PGTlsPassword): Pgchar; cdecl; external LazGio2_library name 'g_tls_password_get_warning';
function g_tls_password_new(flags: TGTlsPasswordFlags; description: Pgchar): PGTlsPassword; cdecl; external LazGio2_library name 'g_tls_password_new';
function g_tls_server_connection_get_type: TGType; cdecl; external LazGio2_library name 'g_tls_server_connection_get_type';
function g_tls_server_connection_new(base_io_stream: PGIOStream; certificate: PGTlsCertificate; error: PPGError): PGTlsServerConnection; cdecl; external LazGio2_library name 'g_tls_server_connection_new';
function g_unix_connection_get_type: TGType; cdecl; external LazGio2_library name 'g_unix_connection_get_type';
function g_unix_connection_receive_credentials(connection: PGUnixConnection; cancellable: PGCancellable; error: PPGError): PGCredentials; cdecl; external LazGio2_library name 'g_unix_connection_receive_credentials';
function g_unix_connection_receive_credentials_finish(connection: PGUnixConnection; result_: PGAsyncResult; error: PPGError): PGCredentials; cdecl; external LazGio2_library name 'g_unix_connection_receive_credentials_finish';
function g_unix_connection_receive_fd(connection: PGUnixConnection; cancellable: PGCancellable; error: PPGError): gint; cdecl; external LazGio2_library name 'g_unix_connection_receive_fd';
function g_unix_connection_send_credentials(connection: PGUnixConnection; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_unix_connection_send_credentials';
function g_unix_connection_send_credentials_finish(connection: PGUnixConnection; result_: PGAsyncResult; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_unix_connection_send_credentials_finish';
function g_unix_connection_send_fd(connection: PGUnixConnection; fd: gint; cancellable: PGCancellable; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_unix_connection_send_fd';
function g_unix_credentials_message_get_credentials(message: PGUnixCredentialsMessage): PGCredentials; cdecl; external LazGio2_library name 'g_unix_credentials_message_get_credentials';
function g_unix_credentials_message_get_type: TGType; cdecl; external LazGio2_library name 'g_unix_credentials_message_get_type';
function g_unix_credentials_message_is_supported: gboolean; cdecl; external LazGio2_library name 'g_unix_credentials_message_is_supported';
function g_unix_credentials_message_new: PGUnixCredentialsMessage; cdecl; external LazGio2_library name 'g_unix_credentials_message_new';
function g_unix_credentials_message_new_with_credentials(credentials: PGCredentials): PGUnixCredentialsMessage; cdecl; external LazGio2_library name 'g_unix_credentials_message_new_with_credentials';
function g_unix_fd_list_append(list: PGUnixFDList; fd: gint; error: PPGError): gint; cdecl; external LazGio2_library name 'g_unix_fd_list_append';
function g_unix_fd_list_get(list: PGUnixFDList; index_: gint; error: PPGError): gint; cdecl; external LazGio2_library name 'g_unix_fd_list_get';
function g_unix_fd_list_get_length(list: PGUnixFDList): gint; cdecl; external LazGio2_library name 'g_unix_fd_list_get_length';
function g_unix_fd_list_get_type: TGType; cdecl; external LazGio2_library name 'g_unix_fd_list_get_type';
function g_unix_fd_list_new: PGUnixFDList; cdecl; external LazGio2_library name 'g_unix_fd_list_new';
function g_unix_fd_list_new_from_array(fds: Pgint; n_fds: gint): PGUnixFDList; cdecl; external LazGio2_library name 'g_unix_fd_list_new_from_array';
function g_unix_fd_list_peek_fds(list: PGUnixFDList; length: Pgint): Pgint; cdecl; external LazGio2_library name 'g_unix_fd_list_peek_fds';
function g_unix_fd_list_steal_fds(list: PGUnixFDList; length: Pgint): Pgint; cdecl; external LazGio2_library name 'g_unix_fd_list_steal_fds';
function g_unix_fd_message_append_fd(message: PGUnixFDMessage; fd: gint; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_unix_fd_message_append_fd';
function g_unix_fd_message_get_fd_list(message: PGUnixFDMessage): PGUnixFDList; cdecl; external LazGio2_library name 'g_unix_fd_message_get_fd_list';
function g_unix_fd_message_get_type: TGType; cdecl; external LazGio2_library name 'g_unix_fd_message_get_type';
function g_unix_fd_message_new: PGUnixFDMessage; cdecl; external LazGio2_library name 'g_unix_fd_message_new';
function g_unix_fd_message_new_with_fd_list(fd_list: PGUnixFDList): PGUnixFDMessage; cdecl; external LazGio2_library name 'g_unix_fd_message_new_with_fd_list';
function g_unix_fd_message_steal_fds(message: PGUnixFDMessage; length: Pgint): Pgint; cdecl; external LazGio2_library name 'g_unix_fd_message_steal_fds';
function g_unix_input_stream_get_close_fd(stream: PGUnixInputStream): gboolean; cdecl; external LazGio2_library name 'g_unix_input_stream_get_close_fd';
function g_unix_input_stream_get_fd(stream: PGUnixInputStream): gint; cdecl; external LazGio2_library name 'g_unix_input_stream_get_fd';
function g_unix_input_stream_get_type: TGType; cdecl; external LazGio2_library name 'g_unix_input_stream_get_type';
function g_unix_input_stream_new(fd: gint; close_fd: gboolean): PGUnixInputStream; cdecl; external LazGio2_library name 'g_unix_input_stream_new';
function g_unix_is_mount_path_system_internal(mount_path: Pgchar): gboolean; cdecl; external LazGio2_library name 'g_unix_is_mount_path_system_internal';
function g_unix_is_system_device_path(device_path: Pgchar): gboolean; cdecl; external LazGio2_library name 'g_unix_is_system_device_path';
function g_unix_is_system_fs_type(fs_type: Pgchar): gboolean; cdecl; external LazGio2_library name 'g_unix_is_system_fs_type';
function g_unix_mount_at(mount_path: Pgchar; time_read: Pguint64): PGUnixMountEntry; cdecl; external LazGio2_library name 'g_unix_mount_at';
function g_unix_mount_compare(mount1: PGUnixMountEntry; mount2: PGUnixMountEntry): gint; cdecl; external LazGio2_library name 'g_unix_mount_compare';
function g_unix_mount_copy(mount_entry: PGUnixMountEntry): PGUnixMountEntry; cdecl; external LazGio2_library name 'g_unix_mount_copy';
function g_unix_mount_entry_get_type: TGType; cdecl; external LazGio2_library name 'g_unix_mount_entry_get_type';
function g_unix_mount_for(file_path: Pgchar; time_read: Pguint64): PGUnixMountEntry; cdecl; external LazGio2_library name 'g_unix_mount_for';
function g_unix_mount_get_device_path(mount_entry: PGUnixMountEntry): Pgchar; cdecl; external LazGio2_library name 'g_unix_mount_get_device_path';
function g_unix_mount_get_fs_type(mount_entry: PGUnixMountEntry): Pgchar; cdecl; external LazGio2_library name 'g_unix_mount_get_fs_type';
function g_unix_mount_get_mount_path(mount_entry: PGUnixMountEntry): Pgchar; cdecl; external LazGio2_library name 'g_unix_mount_get_mount_path';
function g_unix_mount_get_options(mount_entry: PGUnixMountEntry): Pgchar; cdecl; external LazGio2_library name 'g_unix_mount_get_options';
function g_unix_mount_get_root_path(mount_entry: PGUnixMountEntry): Pgchar; cdecl; external LazGio2_library name 'g_unix_mount_get_root_path';
function g_unix_mount_guess_can_eject(mount_entry: PGUnixMountEntry): gboolean; cdecl; external LazGio2_library name 'g_unix_mount_guess_can_eject';
function g_unix_mount_guess_icon(mount_entry: PGUnixMountEntry): PGIcon; cdecl; external LazGio2_library name 'g_unix_mount_guess_icon';
function g_unix_mount_guess_name(mount_entry: PGUnixMountEntry): Pgchar; cdecl; external LazGio2_library name 'g_unix_mount_guess_name';
function g_unix_mount_guess_should_display(mount_entry: PGUnixMountEntry): gboolean; cdecl; external LazGio2_library name 'g_unix_mount_guess_should_display';
function g_unix_mount_guess_symbolic_icon(mount_entry: PGUnixMountEntry): PGIcon; cdecl; external LazGio2_library name 'g_unix_mount_guess_symbolic_icon';
function g_unix_mount_is_readonly(mount_entry: PGUnixMountEntry): gboolean; cdecl; external LazGio2_library name 'g_unix_mount_is_readonly';
function g_unix_mount_is_system_internal(mount_entry: PGUnixMountEntry): gboolean; cdecl; external LazGio2_library name 'g_unix_mount_is_system_internal';
function g_unix_mount_monitor_get: PGUnixMountMonitor; cdecl; external LazGio2_library name 'g_unix_mount_monitor_get';
function g_unix_mount_monitor_get_type: TGType; cdecl; external LazGio2_library name 'g_unix_mount_monitor_get_type';
{$IFDEF USEGTK3LATESTBINDINGS}
function g_unix_mount_point_at(mount_path: Pgchar; time_read: Pguint64): PGUnixMountPoint; cdecl; external LazGio2_library name 'g_unix_mount_point_at';
{$ENDIF}
function g_unix_mount_point_compare(mount1: PGUnixMountPoint; mount2: PGUnixMountPoint): gint; cdecl; external LazGio2_library name 'g_unix_mount_point_compare';
function g_unix_mount_point_copy(mount_point: PGUnixMountPoint): PGUnixMountPoint; cdecl; external LazGio2_library name 'g_unix_mount_point_copy';
function g_unix_mount_point_get_device_path(mount_point: PGUnixMountPoint): Pgchar; cdecl; external LazGio2_library name 'g_unix_mount_point_get_device_path';
function g_unix_mount_point_get_fs_type(mount_point: PGUnixMountPoint): Pgchar; cdecl; external LazGio2_library name 'g_unix_mount_point_get_fs_type';
function g_unix_mount_point_get_mount_path(mount_point: PGUnixMountPoint): Pgchar; cdecl; external LazGio2_library name 'g_unix_mount_point_get_mount_path';
function g_unix_mount_point_get_options(mount_point: PGUnixMountPoint): Pgchar; cdecl; external LazGio2_library name 'g_unix_mount_point_get_options';
function g_unix_mount_point_get_type: TGType; cdecl; external LazGio2_library name 'g_unix_mount_point_get_type';
function g_unix_mount_point_guess_can_eject(mount_point: PGUnixMountPoint): gboolean; cdecl; external LazGio2_library name 'g_unix_mount_point_guess_can_eject';
function g_unix_mount_point_guess_icon(mount_point: PGUnixMountPoint): PGIcon; cdecl; external LazGio2_library name 'g_unix_mount_point_guess_icon';
function g_unix_mount_point_guess_name(mount_point: PGUnixMountPoint): Pgchar; cdecl; external LazGio2_library name 'g_unix_mount_point_guess_name';
function g_unix_mount_point_guess_symbolic_icon(mount_point: PGUnixMountPoint): PGIcon; cdecl; external LazGio2_library name 'g_unix_mount_point_guess_symbolic_icon';
function g_unix_mount_point_is_loopback(mount_point: PGUnixMountPoint): gboolean; cdecl; external LazGio2_library name 'g_unix_mount_point_is_loopback';
function g_unix_mount_point_is_readonly(mount_point: PGUnixMountPoint): gboolean; cdecl; external LazGio2_library name 'g_unix_mount_point_is_readonly';
function g_unix_mount_point_is_user_mountable(mount_point: PGUnixMountPoint): gboolean; cdecl; external LazGio2_library name 'g_unix_mount_point_is_user_mountable';
function g_unix_mount_points_changed_since(time: guint64): gboolean; cdecl; external LazGio2_library name 'g_unix_mount_points_changed_since';
function g_unix_mount_points_get(time_read: Pguint64): PGList; cdecl; external LazGio2_library name 'g_unix_mount_points_get';
function g_unix_mounts_changed_since(time: guint64): gboolean; cdecl; external LazGio2_library name 'g_unix_mounts_changed_since';
function g_unix_mounts_get(time_read: Pguint64): PGList; cdecl; external LazGio2_library name 'g_unix_mounts_get';
function g_unix_output_stream_get_close_fd(stream: PGUnixOutputStream): gboolean; cdecl; external LazGio2_library name 'g_unix_output_stream_get_close_fd';
function g_unix_output_stream_get_fd(stream: PGUnixOutputStream): gint; cdecl; external LazGio2_library name 'g_unix_output_stream_get_fd';
function g_unix_output_stream_get_type: TGType; cdecl; external LazGio2_library name 'g_unix_output_stream_get_type';
function g_unix_output_stream_new(fd: gint; close_fd: gboolean): PGUnixOutputStream; cdecl; external LazGio2_library name 'g_unix_output_stream_new';
function g_unix_socket_address_abstract_names_supported: gboolean; cdecl; external LazGio2_library name 'g_unix_socket_address_abstract_names_supported';
function g_unix_socket_address_get_address_type(address: PGUnixSocketAddress): TGUnixSocketAddressType; cdecl; external LazGio2_library name 'g_unix_socket_address_get_address_type';
function g_unix_socket_address_get_path(address: PGUnixSocketAddress): Pgchar; cdecl; external LazGio2_library name 'g_unix_socket_address_get_path';
function g_unix_socket_address_get_path_len(address: PGUnixSocketAddress): gsize; cdecl; external LazGio2_library name 'g_unix_socket_address_get_path_len';
function g_unix_socket_address_get_type: TGType; cdecl; external LazGio2_library name 'g_unix_socket_address_get_type';
function g_unix_socket_address_new(path: Pgchar): PGUnixSocketAddress; cdecl; external LazGio2_library name 'g_unix_socket_address_new';
function g_unix_socket_address_new_with_type(path: Pgchar; path_len: gint; type_: TGUnixSocketAddressType): PGUnixSocketAddress; cdecl; external LazGio2_library name 'g_unix_socket_address_new_with_type';
function g_vfs_get_default: PGVfs; cdecl; external LazGio2_library name 'g_vfs_get_default';
function g_vfs_get_file_for_path(vfs: PGVfs; path: Pgchar): PGFile; cdecl; external LazGio2_library name 'g_vfs_get_file_for_path';
function g_vfs_get_file_for_uri(vfs: PGVfs; uri: Pgchar): PGFile; cdecl; external LazGio2_library name 'g_vfs_get_file_for_uri';
function g_vfs_get_local: PGVfs; cdecl; external LazGio2_library name 'g_vfs_get_local';
function g_vfs_get_supported_uri_schemes(vfs: PGVfs): PPgchar; cdecl; external LazGio2_library name 'g_vfs_get_supported_uri_schemes';
function g_vfs_get_type: TGType; cdecl; external LazGio2_library name 'g_vfs_get_type';
function g_vfs_is_active(vfs: PGVfs): gboolean; cdecl; external LazGio2_library name 'g_vfs_is_active';
function g_vfs_parse_name(vfs: PGVfs; parse_name: Pgchar): PGFile; cdecl; external LazGio2_library name 'g_vfs_parse_name';
function g_vfs_register_uri_scheme(vfs: PGVfs; scheme: Pgchar; uri_func: TGVfsFileLookupFunc; uri_data: gpointer; uri_destroy: TGDestroyNotify; parse_name_func: TGVfsFileLookupFunc; parse_name_data: gpointer; parse_name_destroy: TGDestroyNotify): gboolean; cdecl; external LazGio2_library name 'g_vfs_register_uri_scheme';
function g_vfs_unregister_uri_scheme(vfs: PGVfs; scheme: Pgchar): gboolean; cdecl; external LazGio2_library name 'g_vfs_unregister_uri_scheme';
function g_volume_can_eject(volume: PGVolume): gboolean; cdecl; external LazGio2_library name 'g_volume_can_eject';
function g_volume_can_mount(volume: PGVolume): gboolean; cdecl; external LazGio2_library name 'g_volume_can_mount';
function g_volume_eject_with_operation_finish(volume: PGVolume; result_: PGAsyncResult; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_volume_eject_with_operation_finish';
function g_volume_enumerate_identifiers(volume: PGVolume): PPgchar; cdecl; external LazGio2_library name 'g_volume_enumerate_identifiers';
function g_volume_get_activation_root(volume: PGVolume): PGFile; cdecl; external LazGio2_library name 'g_volume_get_activation_root';
function g_volume_get_drive(volume: PGVolume): PGDrive; cdecl; external LazGio2_library name 'g_volume_get_drive';
function g_volume_get_icon(volume: PGVolume): PGIcon; cdecl; external LazGio2_library name 'g_volume_get_icon';
function g_volume_get_identifier(volume: PGVolume; kind: Pgchar): Pgchar; cdecl; external LazGio2_library name 'g_volume_get_identifier';
function g_volume_get_mount(volume: PGVolume): PGMount; cdecl; external LazGio2_library name 'g_volume_get_mount';
function g_volume_get_name(volume: PGVolume): Pgchar; cdecl; external LazGio2_library name 'g_volume_get_name';
function g_volume_get_sort_key(volume: PGVolume): Pgchar; cdecl; external LazGio2_library name 'g_volume_get_sort_key';
function g_volume_get_symbolic_icon(volume: PGVolume): PGIcon; cdecl; external LazGio2_library name 'g_volume_get_symbolic_icon';
function g_volume_get_type: TGType; cdecl; external LazGio2_library name 'g_volume_get_type';
function g_volume_get_uuid(volume: PGVolume): Pgchar; cdecl; external LazGio2_library name 'g_volume_get_uuid';
function g_volume_monitor_get: PGVolumeMonitor; cdecl; external LazGio2_library name 'g_volume_monitor_get';
function g_volume_monitor_get_connected_drives(volume_monitor: PGVolumeMonitor): PGList; cdecl; external LazGio2_library name 'g_volume_monitor_get_connected_drives';
function g_volume_monitor_get_mount_for_uuid(volume_monitor: PGVolumeMonitor; uuid: Pgchar): PGMount; cdecl; external LazGio2_library name 'g_volume_monitor_get_mount_for_uuid';
function g_volume_monitor_get_mounts(volume_monitor: PGVolumeMonitor): PGList; cdecl; external LazGio2_library name 'g_volume_monitor_get_mounts';
function g_volume_monitor_get_type: TGType; cdecl; external LazGio2_library name 'g_volume_monitor_get_type';
function g_volume_monitor_get_volume_for_uuid(volume_monitor: PGVolumeMonitor; uuid: Pgchar): PGVolume; cdecl; external LazGio2_library name 'g_volume_monitor_get_volume_for_uuid';
function g_volume_monitor_get_volumes(volume_monitor: PGVolumeMonitor): PGList; cdecl; external LazGio2_library name 'g_volume_monitor_get_volumes';
function g_volume_mount_finish(volume: PGVolume; result_: PGAsyncResult; error: PPGError): gboolean; cdecl; external LazGio2_library name 'g_volume_mount_finish';
function g_volume_should_automount(volume: PGVolume): gboolean; cdecl; external LazGio2_library name 'g_volume_should_automount';
function g_zlib_compressor_get_file_info(compressor: PGZlibCompressor): PGFileInfo; cdecl; external LazGio2_library name 'g_zlib_compressor_get_file_info';
function g_zlib_compressor_get_type: TGType; cdecl; external LazGio2_library name 'g_zlib_compressor_get_type';
function g_zlib_compressor_new(format: TGZlibCompressorFormat; level: gint): PGZlibCompressor; cdecl; external LazGio2_library name 'g_zlib_compressor_new';
function g_zlib_decompressor_get_file_info(decompressor: PGZlibDecompressor): PGFileInfo; cdecl; external LazGio2_library name 'g_zlib_decompressor_get_file_info';
function g_zlib_decompressor_get_type: TGType; cdecl; external LazGio2_library name 'g_zlib_decompressor_get_type';
function g_zlib_decompressor_new(format: TGZlibCompressorFormat): PGZlibDecompressor; cdecl; external LazGio2_library name 'g_zlib_decompressor_new';
procedure g_action_activate(action: PGAction; parameter: PGVariant); cdecl; external LazGio2_library name 'g_action_activate';
procedure g_action_change_state(action: PGAction; value: PGVariant); cdecl; external LazGio2_library name 'g_action_change_state';
procedure g_action_group_action_added(action_group: PGActionGroup; action_name: Pgchar); cdecl; external LazGio2_library name 'g_action_group_action_added';
procedure g_action_group_action_enabled_changed(action_group: PGActionGroup; action_name: Pgchar; enabled: gboolean); cdecl; external LazGio2_library name 'g_action_group_action_enabled_changed';
procedure g_action_group_action_removed(action_group: PGActionGroup; action_name: Pgchar); cdecl; external LazGio2_library name 'g_action_group_action_removed';
procedure g_action_group_action_state_changed(action_group: PGActionGroup; action_name: Pgchar; state: PGVariant); cdecl; external LazGio2_library name 'g_action_group_action_state_changed';
procedure g_action_group_activate_action(action_group: PGActionGroup; action_name: Pgchar; parameter: PGVariant); cdecl; external LazGio2_library name 'g_action_group_activate_action';
procedure g_action_group_change_action_state(action_group: PGActionGroup; action_name: Pgchar; value: PGVariant); cdecl; external LazGio2_library name 'g_action_group_change_action_state';
procedure g_action_map_add_action(action_map: PGActionMap; action: PGAction); cdecl; external LazGio2_library name 'g_action_map_add_action';
procedure g_action_map_add_action_entries(action_map: PGActionMap; entries: PGActionEntry; n_entries: gint; user_data: gpointer); cdecl; external LazGio2_library name 'g_action_map_add_action_entries';
procedure g_action_map_remove_action(action_map: PGActionMap; action_name: Pgchar); cdecl; external LazGio2_library name 'g_action_map_remove_action';
procedure g_app_info_launch_default_for_uri_async(uri: Pgchar; context: PGAppLaunchContext; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_app_info_launch_default_for_uri_async';
procedure g_app_info_launch_uris_async(appinfo: PGAppInfo; uris: PGList; context: PGAppLaunchContext; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_app_info_launch_uris_async';
procedure g_app_info_reset_type_associations(content_type: Pgchar); cdecl; external LazGio2_library name 'g_app_info_reset_type_associations';
procedure g_app_launch_context_launch_failed(context: PGAppLaunchContext; startup_notify_id: Pgchar); cdecl; external LazGio2_library name 'g_app_launch_context_launch_failed';
procedure g_app_launch_context_setenv(context: PGAppLaunchContext; variable: Pgchar; value: Pgchar); cdecl; external LazGio2_library name 'g_app_launch_context_setenv';
procedure g_app_launch_context_unsetenv(context: PGAppLaunchContext; variable: Pgchar); cdecl; external LazGio2_library name 'g_app_launch_context_unsetenv';
procedure g_application_activate(application: PGApplication); cdecl; external LazGio2_library name 'g_application_activate';
procedure g_application_add_main_option(application: PGApplication; long_name: Pgchar; short_name: gchar; flags: TGOptionFlags; arg: TGOptionArg; description: Pgchar; arg_description: Pgchar); cdecl; external LazGio2_library name 'g_application_add_main_option';
procedure g_application_add_main_option_entries(application: PGApplication; entries: PGOptionEntry); cdecl; external LazGio2_library name 'g_application_add_main_option_entries';
procedure g_application_add_option_group(application: PGApplication; group: PGOptionGroup); cdecl; external LazGio2_library name 'g_application_add_option_group';
procedure g_application_bind_busy_property(application: PGApplication; object_: PGObject; property_: Pgchar); cdecl; external LazGio2_library name 'g_application_bind_busy_property';
procedure g_application_command_line_print(cmdline: PGApplicationCommandLine; format: Pgchar; args: array of const); cdecl; external LazGio2_library name 'g_application_command_line_print';
procedure g_application_command_line_printerr(cmdline: PGApplicationCommandLine; format: Pgchar; args: array of const); cdecl; external LazGio2_library name 'g_application_command_line_printerr';
procedure g_application_command_line_set_exit_status(cmdline: PGApplicationCommandLine; exit_status: gint); cdecl; external LazGio2_library name 'g_application_command_line_set_exit_status';
procedure g_application_hold(application: PGApplication); cdecl; external LazGio2_library name 'g_application_hold';
procedure g_application_mark_busy(application: PGApplication); cdecl; external LazGio2_library name 'g_application_mark_busy';
procedure g_application_open(application: PGApplication; files: PPGFile; n_files: gint; hint: Pgchar); cdecl; external LazGio2_library name 'g_application_open';
procedure g_application_quit(application: PGApplication); cdecl; external LazGio2_library name 'g_application_quit';
procedure g_application_release(application: PGApplication); cdecl; external LazGio2_library name 'g_application_release';
procedure g_application_send_notification(application: PGApplication; id: Pgchar; notification: PGNotification); cdecl; external LazGio2_library name 'g_application_send_notification';
procedure g_application_set_application_id(application: PGApplication; application_id: Pgchar); cdecl; external LazGio2_library name 'g_application_set_application_id';
procedure g_application_set_default(application: PGApplication); cdecl; external LazGio2_library name 'g_application_set_default';
procedure g_application_set_flags(application: PGApplication; flags: TGApplicationFlags); cdecl; external LazGio2_library name 'g_application_set_flags';
procedure g_application_set_inactivity_timeout(application: PGApplication; inactivity_timeout: guint); cdecl; external LazGio2_library name 'g_application_set_inactivity_timeout';
procedure g_application_set_option_context_description(application: PGApplication; description: Pgchar); cdecl; external LazGio2_library name 'g_application_set_option_context_description';
procedure g_application_set_option_context_parameter_string(application: PGApplication; parameter_string: Pgchar); cdecl; external LazGio2_library name 'g_application_set_option_context_parameter_string';
procedure g_application_set_option_context_summary(application: PGApplication; summary: Pgchar); cdecl; external LazGio2_library name 'g_application_set_option_context_summary';
procedure g_application_set_resource_base_path(application: PGApplication; resource_path: Pgchar); cdecl; external LazGio2_library name 'g_application_set_resource_base_path';
procedure g_application_unbind_busy_property(application: PGApplication; object_: PGObject; property_: Pgchar); cdecl; external LazGio2_library name 'g_application_unbind_busy_property';
procedure g_application_unmark_busy(application: PGApplication); cdecl; external LazGio2_library name 'g_application_unmark_busy';
procedure g_application_withdraw_notification(application: PGApplication; id: Pgchar); cdecl; external LazGio2_library name 'g_application_withdraw_notification';
procedure g_async_initable_init_async(initable: PGAsyncInitable; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_async_initable_init_async';
procedure g_async_initable_new_async(object_type: TGType; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer; first_property_name: Pgchar; args: array of const); cdecl; external LazGio2_library name 'g_async_initable_new_async';
procedure g_async_initable_new_valist_async(object_type: TGType; first_property_name: Pgchar; var_args: Tva_list; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_async_initable_new_valist_async';
procedure g_buffered_input_stream_fill_async(stream: PGBufferedInputStream; count: gssize; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_buffered_input_stream_fill_async';
procedure g_buffered_input_stream_set_buffer_size(stream: PGBufferedInputStream; size: gsize); cdecl; external LazGio2_library name 'g_buffered_input_stream_set_buffer_size';
procedure g_buffered_output_stream_set_auto_grow(stream: PGBufferedOutputStream; auto_grow: gboolean); cdecl; external LazGio2_library name 'g_buffered_output_stream_set_auto_grow';
procedure g_buffered_output_stream_set_buffer_size(stream: PGBufferedOutputStream; size: gsize); cdecl; external LazGio2_library name 'g_buffered_output_stream_set_buffer_size';
procedure g_bus_get(bus_type: TGBusType; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_bus_get';
procedure g_bus_unown_name(owner_id: guint); cdecl; external LazGio2_library name 'g_bus_unown_name';
procedure g_bus_unwatch_name(watcher_id: guint); cdecl; external LazGio2_library name 'g_bus_unwatch_name';
procedure g_cancellable_cancel(cancellable: PGCancellable); cdecl; external LazGio2_library name 'g_cancellable_cancel';
procedure g_cancellable_disconnect(cancellable: PGCancellable; handler_id: gulong); cdecl; external LazGio2_library name 'g_cancellable_disconnect';
procedure g_cancellable_pop_current(cancellable: PGCancellable); cdecl; external LazGio2_library name 'g_cancellable_pop_current';
procedure g_cancellable_push_current(cancellable: PGCancellable); cdecl; external LazGio2_library name 'g_cancellable_push_current';
procedure g_cancellable_release_fd(cancellable: PGCancellable); cdecl; external LazGio2_library name 'g_cancellable_release_fd';
procedure g_cancellable_reset(cancellable: PGCancellable); cdecl; external LazGio2_library name 'g_cancellable_reset';
procedure g_charset_converter_set_use_fallback(converter: PGCharsetConverter; use_fallback: gboolean); cdecl; external LazGio2_library name 'g_charset_converter_set_use_fallback';
procedure g_content_type_set_mime_dirs(dirs: PPgchar); cdecl; external LazGio2_library name 'g_content_type_set_mime_dirs';
procedure g_converter_reset(converter: PGConverter); cdecl; external LazGio2_library name 'g_converter_reset';
procedure g_credentials_set_native(credentials: PGCredentials; native_type: TGCredentialsType; native: gpointer); cdecl; external LazGio2_library name 'g_credentials_set_native';
procedure g_data_input_stream_read_line_async(stream: PGDataInputStream; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_data_input_stream_read_line_async';
procedure g_data_input_stream_read_upto_async(stream: PGDataInputStream; stop_chars: Pgchar; stop_chars_len: gssize; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_data_input_stream_read_upto_async';
procedure g_data_input_stream_set_byte_order(stream: PGDataInputStream; order: TGDataStreamByteOrder); cdecl; external LazGio2_library name 'g_data_input_stream_set_byte_order';
procedure g_data_input_stream_set_newline_type(stream: PGDataInputStream; type_: TGDataStreamNewlineType); cdecl; external LazGio2_library name 'g_data_input_stream_set_newline_type';
procedure g_data_output_stream_set_byte_order(stream: PGDataOutputStream; order: TGDataStreamByteOrder); cdecl; external LazGio2_library name 'g_data_output_stream_set_byte_order';
procedure g_dbus_address_get_stream(address: Pgchar; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_dbus_address_get_stream';
procedure g_dbus_annotation_info_unref(info: PGDBusAnnotationInfo); cdecl; external LazGio2_library name 'g_dbus_annotation_info_unref';
procedure g_dbus_arg_info_unref(info: PGDBusArgInfo); cdecl; external LazGio2_library name 'g_dbus_arg_info_unref';
procedure g_dbus_connection_call(connection: PGDBusConnection; bus_name: Pgchar; object_path: Pgchar; interface_name: Pgchar; method_name: Pgchar; parameters: PGVariant; reply_type: PGVariantType; flags: TGDBusCallFlags; timeout_msec: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_dbus_connection_call';
procedure g_dbus_connection_call_with_unix_fd_list(connection: PGDBusConnection; bus_name: Pgchar; object_path: Pgchar; interface_name: Pgchar; method_name: Pgchar; parameters: PGVariant; reply_type: PGVariantType; flags: TGDBusCallFlags; timeout_msec: gint; fd_list: PGUnixFDList; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_dbus_connection_call_with_unix_fd_list';
procedure g_dbus_connection_close(connection: PGDBusConnection; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_dbus_connection_close';
procedure g_dbus_connection_flush(connection: PGDBusConnection; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_dbus_connection_flush';
procedure g_dbus_connection_new(stream: PGIOStream; guid: Pgchar; flags: TGDBusConnectionFlags; observer: PGDBusAuthObserver; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_dbus_connection_new';
procedure g_dbus_connection_new_for_address(address: Pgchar; flags: TGDBusConnectionFlags; observer: PGDBusAuthObserver; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_dbus_connection_new_for_address';
procedure g_dbus_connection_remove_filter(connection: PGDBusConnection; filter_id: guint); cdecl; external LazGio2_library name 'g_dbus_connection_remove_filter';
procedure g_dbus_connection_send_message_with_reply(connection: PGDBusConnection; message: PGDBusMessage; flags: TGDBusSendMessageFlags; timeout_msec: gint; out_serial: Pguint32; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_dbus_connection_send_message_with_reply';
procedure g_dbus_connection_set_exit_on_close(connection: PGDBusConnection; exit_on_close: gboolean); cdecl; external LazGio2_library name 'g_dbus_connection_set_exit_on_close';
procedure g_dbus_connection_signal_unsubscribe(connection: PGDBusConnection; subscription_id: guint); cdecl; external LazGio2_library name 'g_dbus_connection_signal_unsubscribe';
procedure g_dbus_connection_start_message_processing(connection: PGDBusConnection); cdecl; external LazGio2_library name 'g_dbus_connection_start_message_processing';
procedure g_dbus_connection_unexport_action_group(connection: PGDBusConnection; export_id: guint); cdecl; external LazGio2_library name 'g_dbus_connection_unexport_action_group';
procedure g_dbus_connection_unexport_menu_model(connection: PGDBusConnection; export_id: guint); cdecl; external LazGio2_library name 'g_dbus_connection_unexport_menu_model';
procedure g_dbus_error_register_error_domain(error_domain_quark_name: Pgchar; quark_volatile: Pgsize; entries: PGDBusErrorEntry; num_entries: guint); cdecl; external LazGio2_library name 'g_dbus_error_register_error_domain';
procedure g_dbus_error_set_dbus_error(error: PPGError; dbus_error_name: Pgchar; dbus_error_message: Pgchar; format: Pgchar; args: array of const); cdecl; external LazGio2_library name 'g_dbus_error_set_dbus_error';
procedure g_dbus_error_set_dbus_error_valist(error: PPGError; dbus_error_name: Pgchar; dbus_error_message: Pgchar; format: Pgchar; var_args: Tva_list); cdecl; external LazGio2_library name 'g_dbus_error_set_dbus_error_valist';
procedure g_dbus_gvariant_to_gvalue(value: PGVariant; out_gvalue: PGValue); cdecl; external LazGio2_library name 'g_dbus_gvariant_to_gvalue';
procedure g_dbus_interface_info_cache_build(info: PGDBusInterfaceInfo); cdecl; external LazGio2_library name 'g_dbus_interface_info_cache_build';
procedure g_dbus_interface_info_cache_release(info: PGDBusInterfaceInfo); cdecl; external LazGio2_library name 'g_dbus_interface_info_cache_release';
procedure g_dbus_interface_info_generate_xml(info: PGDBusInterfaceInfo; indent: guint; string_builder: PGString); cdecl; external LazGio2_library name 'g_dbus_interface_info_generate_xml';
procedure g_dbus_interface_info_unref(info: PGDBusInterfaceInfo); cdecl; external LazGio2_library name 'g_dbus_interface_info_unref';
procedure g_dbus_interface_set_object(interface_: PGDBusInterface; object_: PGDBusObject); cdecl; external LazGio2_library name 'g_dbus_interface_set_object';
procedure g_dbus_interface_skeleton_flush(interface_: PGDBusInterfaceSkeleton); cdecl; external LazGio2_library name 'g_dbus_interface_skeleton_flush';
procedure g_dbus_interface_skeleton_set_flags(interface_: PGDBusInterfaceSkeleton; flags: TGDBusInterfaceSkeletonFlags); cdecl; external LazGio2_library name 'g_dbus_interface_skeleton_set_flags';
procedure g_dbus_interface_skeleton_unexport(interface_: PGDBusInterfaceSkeleton); cdecl; external LazGio2_library name 'g_dbus_interface_skeleton_unexport';
procedure g_dbus_interface_skeleton_unexport_from_connection(interface_: PGDBusInterfaceSkeleton; connection: PGDBusConnection); cdecl; external LazGio2_library name 'g_dbus_interface_skeleton_unexport_from_connection';
procedure g_dbus_message_lock(message: PGDBusMessage); cdecl; external LazGio2_library name 'g_dbus_message_lock';
procedure g_dbus_message_set_body(message: PGDBusMessage; body: PGVariant); cdecl; external LazGio2_library name 'g_dbus_message_set_body';
procedure g_dbus_message_set_byte_order(message: PGDBusMessage; byte_order: TGDBusMessageByteOrder); cdecl; external LazGio2_library name 'g_dbus_message_set_byte_order';
procedure g_dbus_message_set_destination(message: PGDBusMessage; value: Pgchar); cdecl; external LazGio2_library name 'g_dbus_message_set_destination';
procedure g_dbus_message_set_error_name(message: PGDBusMessage; value: Pgchar); cdecl; external LazGio2_library name 'g_dbus_message_set_error_name';
procedure g_dbus_message_set_flags(message: PGDBusMessage; flags: TGDBusMessageFlags); cdecl; external LazGio2_library name 'g_dbus_message_set_flags';
procedure g_dbus_message_set_header(message: PGDBusMessage; header_field: TGDBusMessageHeaderField; value: PGVariant); cdecl; external LazGio2_library name 'g_dbus_message_set_header';
procedure g_dbus_message_set_interface(message: PGDBusMessage; value: Pgchar); cdecl; external LazGio2_library name 'g_dbus_message_set_interface';
procedure g_dbus_message_set_member(message: PGDBusMessage; value: Pgchar); cdecl; external LazGio2_library name 'g_dbus_message_set_member';
procedure g_dbus_message_set_message_type(message: PGDBusMessage; type_: TGDBusMessageType); cdecl; external LazGio2_library name 'g_dbus_message_set_message_type';
procedure g_dbus_message_set_num_unix_fds(message: PGDBusMessage; value: guint32); cdecl; external LazGio2_library name 'g_dbus_message_set_num_unix_fds';
procedure g_dbus_message_set_path(message: PGDBusMessage; value: Pgchar); cdecl; external LazGio2_library name 'g_dbus_message_set_path';
procedure g_dbus_message_set_reply_serial(message: PGDBusMessage; value: guint32); cdecl; external LazGio2_library name 'g_dbus_message_set_reply_serial';
procedure g_dbus_message_set_sender(message: PGDBusMessage; value: Pgchar); cdecl; external LazGio2_library name 'g_dbus_message_set_sender';
procedure g_dbus_message_set_serial(message: PGDBusMessage; serial: guint32); cdecl; external LazGio2_library name 'g_dbus_message_set_serial';
procedure g_dbus_message_set_signature(message: PGDBusMessage; value: Pgchar); cdecl; external LazGio2_library name 'g_dbus_message_set_signature';
procedure g_dbus_message_set_unix_fd_list(message: PGDBusMessage; fd_list: PGUnixFDList); cdecl; external LazGio2_library name 'g_dbus_message_set_unix_fd_list';
procedure g_dbus_method_info_unref(info: PGDBusMethodInfo); cdecl; external LazGio2_library name 'g_dbus_method_info_unref';
procedure g_dbus_method_invocation_return_dbus_error(invocation: PGDBusMethodInvocation; error_name: Pgchar; error_message: Pgchar); cdecl; external LazGio2_library name 'g_dbus_method_invocation_return_dbus_error';
procedure g_dbus_method_invocation_return_error(invocation: PGDBusMethodInvocation; domain: TGQuark; code: gint; format: Pgchar; args: array of const); cdecl; external LazGio2_library name 'g_dbus_method_invocation_return_error';
procedure g_dbus_method_invocation_return_error_literal(invocation: PGDBusMethodInvocation; domain: TGQuark; code: gint; message: Pgchar); cdecl; external LazGio2_library name 'g_dbus_method_invocation_return_error_literal';
procedure g_dbus_method_invocation_return_error_valist(invocation: PGDBusMethodInvocation; domain: TGQuark; code: gint; format: Pgchar; var_args: Tva_list); cdecl; external LazGio2_library name 'g_dbus_method_invocation_return_error_valist';
procedure g_dbus_method_invocation_return_gerror(invocation: PGDBusMethodInvocation; error: PGError); cdecl; external LazGio2_library name 'g_dbus_method_invocation_return_gerror';
procedure g_dbus_method_invocation_return_value(invocation: PGDBusMethodInvocation; parameters: PGVariant); cdecl; external LazGio2_library name 'g_dbus_method_invocation_return_value';
procedure g_dbus_method_invocation_return_value_with_unix_fd_list(invocation: PGDBusMethodInvocation; parameters: PGVariant; fd_list: PGUnixFDList); cdecl; external LazGio2_library name 'g_dbus_method_invocation_return_value_with_unix_fd_list';
procedure g_dbus_method_invocation_take_error(invocation: PGDBusMethodInvocation; error: PGError); cdecl; external LazGio2_library name 'g_dbus_method_invocation_take_error';
procedure g_dbus_node_info_generate_xml(info: PGDBusNodeInfo; indent: guint; string_builder: PGString); cdecl; external LazGio2_library name 'g_dbus_node_info_generate_xml';
procedure g_dbus_node_info_unref(info: PGDBusNodeInfo); cdecl; external LazGio2_library name 'g_dbus_node_info_unref';
procedure g_dbus_object_manager_client_new(connection: PGDBusConnection; flags: TGDBusObjectManagerClientFlags; name: Pgchar; object_path: Pgchar; get_proxy_type_func: TGDBusProxyTypeFunc; get_proxy_type_user_data: gpointer; get_proxy_type_destroy_notify: TGDestroyNotify; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_dbus_object_manager_client_new';
procedure g_dbus_object_manager_client_new_for_bus(bus_type: TGBusType; flags: TGDBusObjectManagerClientFlags; name: Pgchar; object_path: Pgchar; get_proxy_type_func: TGDBusProxyTypeFunc; get_proxy_type_user_data: gpointer; get_proxy_type_destroy_notify: TGDestroyNotify; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_dbus_object_manager_client_new_for_bus';
procedure g_dbus_object_manager_server_export(manager: PGDBusObjectManagerServer; object_: PGDBusObjectSkeleton); cdecl; external LazGio2_library name 'g_dbus_object_manager_server_export';
procedure g_dbus_object_manager_server_export_uniquely(manager: PGDBusObjectManagerServer; object_: PGDBusObjectSkeleton); cdecl; external LazGio2_library name 'g_dbus_object_manager_server_export_uniquely';
procedure g_dbus_object_manager_server_set_connection(manager: PGDBusObjectManagerServer; connection: PGDBusConnection); cdecl; external LazGio2_library name 'g_dbus_object_manager_server_set_connection';
procedure g_dbus_object_skeleton_add_interface(object_: PGDBusObjectSkeleton; interface_: PGDBusInterfaceSkeleton); cdecl; external LazGio2_library name 'g_dbus_object_skeleton_add_interface';
procedure g_dbus_object_skeleton_flush(object_: PGDBusObjectSkeleton); cdecl; external LazGio2_library name 'g_dbus_object_skeleton_flush';
procedure g_dbus_object_skeleton_remove_interface(object_: PGDBusObjectSkeleton; interface_: PGDBusInterfaceSkeleton); cdecl; external LazGio2_library name 'g_dbus_object_skeleton_remove_interface';
procedure g_dbus_object_skeleton_remove_interface_by_name(object_: PGDBusObjectSkeleton; interface_name: Pgchar); cdecl; external LazGio2_library name 'g_dbus_object_skeleton_remove_interface_by_name';
procedure g_dbus_object_skeleton_set_object_path(object_: PGDBusObjectSkeleton; object_path: Pgchar); cdecl; external LazGio2_library name 'g_dbus_object_skeleton_set_object_path';
procedure g_dbus_property_info_unref(info: PGDBusPropertyInfo); cdecl; external LazGio2_library name 'g_dbus_property_info_unref';
procedure g_dbus_proxy_call(proxy: PGDBusProxy; method_name: Pgchar; parameters: PGVariant; flags: TGDBusCallFlags; timeout_msec: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_dbus_proxy_call';
procedure g_dbus_proxy_call_with_unix_fd_list(proxy: PGDBusProxy; method_name: Pgchar; parameters: PGVariant; flags: TGDBusCallFlags; timeout_msec: gint; fd_list: PGUnixFDList; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_dbus_proxy_call_with_unix_fd_list';
procedure g_dbus_proxy_new(connection: PGDBusConnection; flags: TGDBusProxyFlags; info: PGDBusInterfaceInfo; name: Pgchar; object_path: Pgchar; interface_name: Pgchar; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_dbus_proxy_new';
procedure g_dbus_proxy_new_for_bus(bus_type: TGBusType; flags: TGDBusProxyFlags; info: PGDBusInterfaceInfo; name: Pgchar; object_path: Pgchar; interface_name: Pgchar; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_dbus_proxy_new_for_bus';
procedure g_dbus_proxy_set_cached_property(proxy: PGDBusProxy; property_name: Pgchar; value: PGVariant); cdecl; external LazGio2_library name 'g_dbus_proxy_set_cached_property';
procedure g_dbus_proxy_set_default_timeout(proxy: PGDBusProxy; timeout_msec: gint); cdecl; external LazGio2_library name 'g_dbus_proxy_set_default_timeout';
procedure g_dbus_proxy_set_interface_info(proxy: PGDBusProxy; info: PGDBusInterfaceInfo); cdecl; external LazGio2_library name 'g_dbus_proxy_set_interface_info';
procedure g_dbus_server_start(server: PGDBusServer); cdecl; external LazGio2_library name 'g_dbus_server_start';
procedure g_dbus_server_stop(server: PGDBusServer); cdecl; external LazGio2_library name 'g_dbus_server_stop';
procedure g_dbus_signal_info_unref(info: PGDBusSignalInfo); cdecl; external LazGio2_library name 'g_dbus_signal_info_unref';
procedure g_desktop_app_info_launch_action(info: PGDesktopAppInfo; action_name: Pgchar; launch_context: PGAppLaunchContext); cdecl; external LazGio2_library name 'g_desktop_app_info_launch_action';
procedure g_drive_eject_with_operation(drive: PGDrive; flags: TGMountUnmountFlags; mount_operation: PGMountOperation; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_drive_eject_with_operation';
procedure g_drive_poll_for_media(drive: PGDrive; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_drive_poll_for_media';
procedure g_drive_start(drive: PGDrive; flags: TGDriveStartFlags; mount_operation: PGMountOperation; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_drive_start';
procedure g_drive_stop(drive: PGDrive; flags: TGMountUnmountFlags; mount_operation: PGMountOperation; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_drive_stop';
procedure g_dtls_client_connection_set_server_identity(conn: PGDtlsClientConnection; identity: PGSocketConnectable); cdecl; external LazGio2_library name 'g_dtls_client_connection_set_server_identity';
procedure g_dtls_client_connection_set_validation_flags(conn: PGDtlsClientConnection; flags: TGTlsCertificateFlags); cdecl; external LazGio2_library name 'g_dtls_client_connection_set_validation_flags'; deprecated 'Do not attempt to ignore validation errors.';
procedure g_dtls_connection_close_async(conn: PGDtlsConnection; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_dtls_connection_close_async';
procedure g_dtls_connection_handshake_async(conn: PGDtlsConnection; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_dtls_connection_handshake_async';
procedure g_dtls_connection_set_advertised_protocols(conn: PGDtlsConnection; protocols: PPgchar); cdecl; external LazGio2_library name 'g_dtls_connection_set_advertised_protocols';
procedure g_dtls_connection_set_certificate(conn: PGDtlsConnection; certificate: PGTlsCertificate); cdecl; external LazGio2_library name 'g_dtls_connection_set_certificate';
procedure g_dtls_connection_set_database(conn: PGDtlsConnection; database: PGTlsDatabase); cdecl; external LazGio2_library name 'g_dtls_connection_set_database';
procedure g_dtls_connection_set_interaction(conn: PGDtlsConnection; interaction: PGTlsInteraction); cdecl; external LazGio2_library name 'g_dtls_connection_set_interaction';
procedure g_dtls_connection_set_require_close_notify(conn: PGDtlsConnection; require_close_notify: gboolean); cdecl; external LazGio2_library name 'g_dtls_connection_set_require_close_notify';
procedure g_dtls_connection_shutdown_async(conn: PGDtlsConnection; shutdown_read: gboolean; shutdown_write: gboolean; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_dtls_connection_shutdown_async';
procedure g_emblemed_icon_add_emblem(emblemed: PGEmblemedIcon; emblem: PGEmblem); cdecl; external LazGio2_library name 'g_emblemed_icon_add_emblem';
procedure g_emblemed_icon_clear_emblems(emblemed: PGEmblemedIcon); cdecl; external LazGio2_library name 'g_emblemed_icon_clear_emblems';
procedure g_file_append_to_async(file_: PGFile; flags: TGFileCreateFlags; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_file_append_to_async';
procedure g_file_attribute_info_list_add(list: PGFileAttributeInfoList; name: Pgchar; type_: TGFileAttributeType; flags: TGFileAttributeInfoFlags); cdecl; external LazGio2_library name 'g_file_attribute_info_list_add';
procedure g_file_attribute_info_list_unref(list: PGFileAttributeInfoList); cdecl; external LazGio2_library name 'g_file_attribute_info_list_unref';
procedure g_file_attribute_matcher_unref(matcher: PGFileAttributeMatcher); cdecl; external LazGio2_library name 'g_file_attribute_matcher_unref';
procedure g_file_copy_async(source: PGFile; destination: PGFile; flags: TGFileCopyFlags; io_priority: gint; cancellable: PGCancellable; progress_callback: TGFileProgressCallback; progress_callback_data: gpointer; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_file_copy_async';
procedure g_file_create_async(file_: PGFile; flags: TGFileCreateFlags; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_file_create_async';
procedure g_file_create_readwrite_async(file_: PGFile; flags: TGFileCreateFlags; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_file_create_readwrite_async';
procedure g_file_delete_async(file_: PGFile; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_file_delete_async';
procedure g_file_eject_mountable_with_operation(file_: PGFile; flags: TGMountUnmountFlags; mount_operation: PGMountOperation; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_file_eject_mountable_with_operation';
procedure g_file_enumerate_children_async(file_: PGFile; attributes: Pgchar; flags: TGFileQueryInfoFlags; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_file_enumerate_children_async';
procedure g_file_enumerator_close_async(enumerator: PGFileEnumerator; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_file_enumerator_close_async';
procedure g_file_enumerator_next_files_async(enumerator: PGFileEnumerator; num_files: gint; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_file_enumerator_next_files_async';
procedure g_file_enumerator_set_pending(enumerator: PGFileEnumerator; pending: gboolean); cdecl; external LazGio2_library name 'g_file_enumerator_set_pending';
procedure g_file_find_enclosing_mount_async(file_: PGFile; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_file_find_enclosing_mount_async';
procedure g_file_info_clear_status(info: PGFileInfo); cdecl; external LazGio2_library name 'g_file_info_clear_status';
procedure g_file_info_copy_into(src_info: PGFileInfo; dest_info: PGFileInfo); cdecl; external LazGio2_library name 'g_file_info_copy_into';
procedure g_file_info_remove_attribute(info: PGFileInfo; attribute: Pgchar); cdecl; external LazGio2_library name 'g_file_info_remove_attribute';
procedure g_file_info_set_attribute(info: PGFileInfo; attribute: Pgchar; type_: TGFileAttributeType; value_p: gpointer); cdecl; external LazGio2_library name 'g_file_info_set_attribute';
procedure g_file_info_set_attribute_boolean(info: PGFileInfo; attribute: Pgchar; attr_value: gboolean); cdecl; external LazGio2_library name 'g_file_info_set_attribute_boolean';
procedure g_file_info_set_attribute_byte_string(info: PGFileInfo; attribute: Pgchar; attr_value: Pgchar); cdecl; external LazGio2_library name 'g_file_info_set_attribute_byte_string';
procedure g_file_info_set_attribute_int32(info: PGFileInfo; attribute: Pgchar; attr_value: gint32); cdecl; external LazGio2_library name 'g_file_info_set_attribute_int32';
procedure g_file_info_set_attribute_int64(info: PGFileInfo; attribute: Pgchar; attr_value: gint64); cdecl; external LazGio2_library name 'g_file_info_set_attribute_int64';
procedure g_file_info_set_attribute_mask(info: PGFileInfo; mask: PGFileAttributeMatcher); cdecl; external LazGio2_library name 'g_file_info_set_attribute_mask';
procedure g_file_info_set_attribute_object(info: PGFileInfo; attribute: Pgchar; attr_value: PGObject); cdecl; external LazGio2_library name 'g_file_info_set_attribute_object';
procedure g_file_info_set_attribute_string(info: PGFileInfo; attribute: Pgchar; attr_value: Pgchar); cdecl; external LazGio2_library name 'g_file_info_set_attribute_string';
procedure g_file_info_set_attribute_stringv(info: PGFileInfo; attribute: Pgchar; attr_value: PPgchar); cdecl; external LazGio2_library name 'g_file_info_set_attribute_stringv';
procedure g_file_info_set_attribute_uint32(info: PGFileInfo; attribute: Pgchar; attr_value: guint32); cdecl; external LazGio2_library name 'g_file_info_set_attribute_uint32';
procedure g_file_info_set_attribute_uint64(info: PGFileInfo; attribute: Pgchar; attr_value: guint64); cdecl; external LazGio2_library name 'g_file_info_set_attribute_uint64';
procedure g_file_info_set_content_type(info: PGFileInfo; content_type: Pgchar); cdecl; external LazGio2_library name 'g_file_info_set_content_type';
procedure g_file_info_set_display_name(info: PGFileInfo; display_name: Pgchar); cdecl; external LazGio2_library name 'g_file_info_set_display_name';
procedure g_file_info_set_edit_name(info: PGFileInfo; edit_name: Pgchar); cdecl; external LazGio2_library name 'g_file_info_set_edit_name';
procedure g_file_info_set_file_type(info: PGFileInfo; type_: TGFileType); cdecl; external LazGio2_library name 'g_file_info_set_file_type';
procedure g_file_info_set_icon(info: PGFileInfo; icon: PGIcon); cdecl; external LazGio2_library name 'g_file_info_set_icon';
procedure g_file_info_set_is_hidden(info: PGFileInfo; is_hidden: gboolean); cdecl; external LazGio2_library name 'g_file_info_set_is_hidden';
procedure g_file_info_set_is_symlink(info: PGFileInfo; is_symlink: gboolean); cdecl; external LazGio2_library name 'g_file_info_set_is_symlink';
procedure g_file_info_set_modification_date_time(info: PGFileInfo; mtime: PGDateTime); cdecl; external LazGio2_library name 'g_file_info_set_modification_date_time';
procedure g_file_info_set_name(info: PGFileInfo; name: Pgchar); cdecl; external LazGio2_library name 'g_file_info_set_name';
procedure g_file_info_set_size(info: PGFileInfo; size: gint64); cdecl; external LazGio2_library name 'g_file_info_set_size';
procedure g_file_info_set_sort_order(info: PGFileInfo; sort_order: gint32); cdecl; external LazGio2_library name 'g_file_info_set_sort_order';
procedure g_file_info_set_symbolic_icon(info: PGFileInfo; icon: PGIcon); cdecl; external LazGio2_library name 'g_file_info_set_symbolic_icon';
procedure g_file_info_set_symlink_target(info: PGFileInfo; symlink_target: Pgchar); cdecl; external LazGio2_library name 'g_file_info_set_symlink_target';
procedure g_file_info_unset_attribute_mask(info: PGFileInfo); cdecl; external LazGio2_library name 'g_file_info_unset_attribute_mask';
procedure g_file_input_stream_query_info_async(stream: PGFileInputStream; attributes: Pgchar; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_file_input_stream_query_info_async';
procedure g_file_io_stream_query_info_async(stream: PGFileIOStream; attributes: Pgchar; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_file_io_stream_query_info_async';
procedure g_file_load_bytes_async(file_: PGFile; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_file_load_bytes_async';
procedure g_file_load_contents_async(file_: PGFile; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_file_load_contents_async';
procedure g_file_load_partial_contents_async(file_: PGFile; cancellable: PGCancellable; read_more_callback: TGFileReadMoreCallback; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_file_load_partial_contents_async';
procedure g_file_make_directory_async(file_: PGFile; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_file_make_directory_async';
procedure g_file_measure_disk_usage_async(file_: PGFile; flags: TGFileMeasureFlags; io_priority: gint; cancellable: PGCancellable; progress_callback: TGFileMeasureProgressCallback; progress_data: gpointer; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_file_measure_disk_usage_async';
procedure g_file_monitor_emit_event(monitor: PGFileMonitor; child: PGFile; other_file: PGFile; event_type: TGFileMonitorEvent); cdecl; external LazGio2_library name 'g_file_monitor_emit_event';
procedure g_file_monitor_set_rate_limit(monitor: PGFileMonitor; limit_msecs: gint); cdecl; external LazGio2_library name 'g_file_monitor_set_rate_limit';
procedure g_file_mount_enclosing_volume(location: PGFile; flags: TGMountMountFlags; mount_operation: PGMountOperation; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_file_mount_enclosing_volume';
procedure g_file_mount_mountable(file_: PGFile; flags: TGMountMountFlags; mount_operation: PGMountOperation; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_file_mount_mountable';
procedure g_file_open_readwrite_async(file_: PGFile; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_file_open_readwrite_async';
procedure g_file_output_stream_query_info_async(stream: PGFileOutputStream; attributes: Pgchar; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_file_output_stream_query_info_async';
procedure g_file_poll_mountable(file_: PGFile; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_file_poll_mountable';
procedure g_file_query_default_handler_async(file_: PGFile; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_file_query_default_handler_async';
procedure g_file_query_filesystem_info_async(file_: PGFile; attributes: Pgchar; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_file_query_filesystem_info_async';
procedure g_file_query_info_async(file_: PGFile; attributes: Pgchar; flags: TGFileQueryInfoFlags; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_file_query_info_async';
procedure g_file_read_async(file_: PGFile; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_file_read_async';
procedure g_file_replace_async(file_: PGFile; etag: Pgchar; make_backup: gboolean; flags: TGFileCreateFlags; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_file_replace_async';
procedure g_file_replace_contents_async(file_: PGFile; contents: Pgchar; length: gsize; etag: Pgchar; make_backup: gboolean; flags: TGFileCreateFlags; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_file_replace_contents_async';
procedure g_file_replace_contents_bytes_async(file_: PGFile; contents: PGBytes; etag: Pgchar; make_backup: gboolean; flags: TGFileCreateFlags; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_file_replace_contents_bytes_async';
procedure g_file_replace_readwrite_async(file_: PGFile; etag: Pgchar; make_backup: gboolean; flags: TGFileCreateFlags; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_file_replace_readwrite_async';
procedure g_file_set_attributes_async(file_: PGFile; info: PGFileInfo; flags: TGFileQueryInfoFlags; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_file_set_attributes_async';
procedure g_file_set_display_name_async(file_: PGFile; display_name: Pgchar; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_file_set_display_name_async';
procedure g_file_start_mountable(file_: PGFile; flags: TGDriveStartFlags; start_operation: PGMountOperation; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_file_start_mountable';
procedure g_file_stop_mountable(file_: PGFile; flags: TGMountUnmountFlags; mount_operation: PGMountOperation; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_file_stop_mountable';
procedure g_file_trash_async(file_: PGFile; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_file_trash_async';
procedure g_file_unmount_mountable_with_operation(file_: PGFile; flags: TGMountUnmountFlags; mount_operation: PGMountOperation; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_file_unmount_mountable_with_operation';
procedure g_filename_completer_set_dirs_only(completer: PGFilenameCompleter; dirs_only: gboolean); cdecl; external LazGio2_library name 'g_filename_completer_set_dirs_only';
procedure g_filter_input_stream_set_close_base_stream(stream: PGFilterInputStream; close_base: gboolean); cdecl; external LazGio2_library name 'g_filter_input_stream_set_close_base_stream';
procedure g_filter_output_stream_set_close_base_stream(stream: PGFilterOutputStream; close_base: gboolean); cdecl; external LazGio2_library name 'g_filter_output_stream_set_close_base_stream';
procedure g_input_stream_clear_pending(stream: PGInputStream); cdecl; external LazGio2_library name 'g_input_stream_clear_pending';
procedure g_input_stream_close_async(stream: PGInputStream; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_input_stream_close_async';
procedure g_input_stream_read_all_async(stream: PGInputStream; buffer: Pguint8; count: gsize; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_input_stream_read_all_async';
procedure g_input_stream_read_async(stream: PGInputStream; buffer: Pguint8; count: gsize; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_input_stream_read_async';
procedure g_input_stream_read_bytes_async(stream: PGInputStream; count: gsize; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_input_stream_read_bytes_async';
procedure g_input_stream_skip_async(stream: PGInputStream; count: gsize; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_input_stream_skip_async';
procedure g_io_extension_point_set_required_type(extension_point: PGIOExtensionPoint; type_: TGType); cdecl; external LazGio2_library name 'g_io_extension_point_set_required_type';
procedure g_io_module_scope_block(scope: PGIOModuleScope; basename: Pgchar); cdecl; external LazGio2_library name 'g_io_module_scope_block';
procedure g_io_module_scope_free(scope: PGIOModuleScope); cdecl; external LazGio2_library name 'g_io_module_scope_free';
procedure g_io_modules_scan_all_in_directory(dirname: Pgchar); cdecl; external LazGio2_library name 'g_io_modules_scan_all_in_directory';
procedure g_io_modules_scan_all_in_directory_with_scope(dirname: Pgchar; scope: PGIOModuleScope); cdecl; external LazGio2_library name 'g_io_modules_scan_all_in_directory_with_scope';
procedure g_io_stream_clear_pending(stream: PGIOStream); cdecl; external LazGio2_library name 'g_io_stream_clear_pending';
procedure g_io_stream_close_async(stream: PGIOStream; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_io_stream_close_async';
procedure g_io_stream_splice_async(stream1: PGIOStream; stream2: PGIOStream; flags: TGIOStreamSpliceFlags; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_io_stream_splice_async';
procedure g_list_model_items_changed(list: PGListModel; position: guint; removed: guint; added: guint); cdecl; external LazGio2_library name 'g_list_model_items_changed';
procedure g_list_store_append(store: PGListStore; item: PGObject); cdecl; external LazGio2_library name 'g_list_store_append';
procedure g_list_store_insert(store: PGListStore; position: guint; item: PGObject); cdecl; external LazGio2_library name 'g_list_store_insert';
procedure g_list_store_remove(store: PGListStore; position: guint); cdecl; external LazGio2_library name 'g_list_store_remove';
procedure g_list_store_remove_all(store: PGListStore); cdecl; external LazGio2_library name 'g_list_store_remove_all';
procedure g_list_store_sort(store: PGListStore; compare_func: TGCompareDataFunc; user_data: gpointer); cdecl; external LazGio2_library name 'g_list_store_sort';
procedure g_list_store_splice(store: PGListStore; position: guint; n_removals: guint; additions: PGObject; n_additions: guint); cdecl; external LazGio2_library name 'g_list_store_splice';
procedure g_loadable_icon_load_async(icon: PGLoadableIcon; size: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_loadable_icon_load_async';
procedure g_memory_input_stream_add_bytes(stream: PGMemoryInputStream; bytes: PGBytes); cdecl; external LazGio2_library name 'g_memory_input_stream_add_bytes';
procedure g_memory_input_stream_add_data(stream: PGMemoryInputStream; data: Pguint8; len: gssize; destroy_: TGDestroyNotify); cdecl; external LazGio2_library name 'g_memory_input_stream_add_data';
procedure g_menu_append(menu: PGMenu; label_: Pgchar; detailed_action: Pgchar); cdecl; external LazGio2_library name 'g_menu_append';
procedure g_menu_append_item(menu: PGMenu; item: PGMenuItem); cdecl; external LazGio2_library name 'g_menu_append_item';
procedure g_menu_append_section(menu: PGMenu; label_: Pgchar; section: PGMenuModel); cdecl; external LazGio2_library name 'g_menu_append_section';
procedure g_menu_append_submenu(menu: PGMenu; label_: Pgchar; submenu: PGMenuModel); cdecl; external LazGio2_library name 'g_menu_append_submenu';
procedure g_menu_freeze(menu: PGMenu); cdecl; external LazGio2_library name 'g_menu_freeze';
procedure g_menu_insert(menu: PGMenu; position: gint; label_: Pgchar; detailed_action: Pgchar); cdecl; external LazGio2_library name 'g_menu_insert';
procedure g_menu_insert_item(menu: PGMenu; position: gint; item: PGMenuItem); cdecl; external LazGio2_library name 'g_menu_insert_item';
procedure g_menu_insert_section(menu: PGMenu; position: gint; label_: Pgchar; section: PGMenuModel); cdecl; external LazGio2_library name 'g_menu_insert_section';
procedure g_menu_insert_submenu(menu: PGMenu; position: gint; label_: Pgchar; submenu: PGMenuModel); cdecl; external LazGio2_library name 'g_menu_insert_submenu';
procedure g_menu_item_set_action_and_target(menu_item: PGMenuItem; action: Pgchar; format_string: Pgchar; args: array of const); cdecl; external LazGio2_library name 'g_menu_item_set_action_and_target';
procedure g_menu_item_set_action_and_target_value(menu_item: PGMenuItem; action: Pgchar; target_value: PGVariant); cdecl; external LazGio2_library name 'g_menu_item_set_action_and_target_value';
procedure g_menu_item_set_attribute(menu_item: PGMenuItem; attribute: Pgchar; format_string: Pgchar; args: array of const); cdecl; external LazGio2_library name 'g_menu_item_set_attribute';
procedure g_menu_item_set_attribute_value(menu_item: PGMenuItem; attribute: Pgchar; value: PGVariant); cdecl; external LazGio2_library name 'g_menu_item_set_attribute_value';
procedure g_menu_item_set_detailed_action(menu_item: PGMenuItem; detailed_action: Pgchar); cdecl; external LazGio2_library name 'g_menu_item_set_detailed_action';
procedure g_menu_item_set_icon(menu_item: PGMenuItem; icon: PGIcon); cdecl; external LazGio2_library name 'g_menu_item_set_icon';
procedure g_menu_item_set_label(menu_item: PGMenuItem; label_: Pgchar); cdecl; external LazGio2_library name 'g_menu_item_set_label';
procedure g_menu_item_set_link(menu_item: PGMenuItem; link: Pgchar; model: PGMenuModel); cdecl; external LazGio2_library name 'g_menu_item_set_link';
procedure g_menu_item_set_section(menu_item: PGMenuItem; section: PGMenuModel); cdecl; external LazGio2_library name 'g_menu_item_set_section';
procedure g_menu_item_set_submenu(menu_item: PGMenuItem; submenu: PGMenuModel); cdecl; external LazGio2_library name 'g_menu_item_set_submenu';
procedure g_menu_model_items_changed(model: PGMenuModel; position: gint; removed: gint; added: gint); cdecl; external LazGio2_library name 'g_menu_model_items_changed';
procedure g_menu_prepend(menu: PGMenu; label_: Pgchar; detailed_action: Pgchar); cdecl; external LazGio2_library name 'g_menu_prepend';
procedure g_menu_prepend_item(menu: PGMenu; item: PGMenuItem); cdecl; external LazGio2_library name 'g_menu_prepend_item';
procedure g_menu_prepend_section(menu: PGMenu; label_: Pgchar; section: PGMenuModel); cdecl; external LazGio2_library name 'g_menu_prepend_section';
procedure g_menu_prepend_submenu(menu: PGMenu; label_: Pgchar; submenu: PGMenuModel); cdecl; external LazGio2_library name 'g_menu_prepend_submenu';
procedure g_menu_remove(menu: PGMenu; position: gint); cdecl; external LazGio2_library name 'g_menu_remove';
procedure g_menu_remove_all(menu: PGMenu); cdecl; external LazGio2_library name 'g_menu_remove_all';
procedure g_mount_eject_with_operation(mount: PGMount; flags: TGMountUnmountFlags; mount_operation: PGMountOperation; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_mount_eject_with_operation';
procedure g_mount_guess_content_type(mount: PGMount; force_rescan: gboolean; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_mount_guess_content_type';
procedure g_mount_operation_reply(op: PGMountOperation; result_: TGMountOperationResult); cdecl; external LazGio2_library name 'g_mount_operation_reply';
procedure g_mount_operation_set_anonymous(op: PGMountOperation; anonymous: gboolean); cdecl; external LazGio2_library name 'g_mount_operation_set_anonymous';
procedure g_mount_operation_set_choice(op: PGMountOperation; choice: gint); cdecl; external LazGio2_library name 'g_mount_operation_set_choice';
procedure g_mount_operation_set_domain(op: PGMountOperation; domain: Pgchar); cdecl; external LazGio2_library name 'g_mount_operation_set_domain';
procedure g_mount_operation_set_is_tcrypt_hidden_volume(op: PGMountOperation; hidden_volume: gboolean); cdecl; external LazGio2_library name 'g_mount_operation_set_is_tcrypt_hidden_volume';
procedure g_mount_operation_set_is_tcrypt_system_volume(op: PGMountOperation; system_volume: gboolean); cdecl; external LazGio2_library name 'g_mount_operation_set_is_tcrypt_system_volume';
procedure g_mount_operation_set_password(op: PGMountOperation; password: Pgchar); cdecl; external LazGio2_library name 'g_mount_operation_set_password';
procedure g_mount_operation_set_password_save(op: PGMountOperation; save: TGPasswordSave); cdecl; external LazGio2_library name 'g_mount_operation_set_password_save';
procedure g_mount_operation_set_pim(op: PGMountOperation; pim: guint); cdecl; external LazGio2_library name 'g_mount_operation_set_pim';
procedure g_mount_operation_set_username(op: PGMountOperation; username: Pgchar); cdecl; external LazGio2_library name 'g_mount_operation_set_username';
procedure g_mount_remount(mount: PGMount; flags: TGMountMountFlags; mount_operation: PGMountOperation; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_mount_remount';
procedure g_mount_shadow(mount: PGMount); cdecl; external LazGio2_library name 'g_mount_shadow';
procedure g_mount_unmount_with_operation(mount: PGMount; flags: TGMountUnmountFlags; mount_operation: PGMountOperation; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_mount_unmount_with_operation';
procedure g_mount_unshadow(mount: PGMount); cdecl; external LazGio2_library name 'g_mount_unshadow';
procedure g_network_monitor_can_reach_async(monitor: PGNetworkMonitor; connectable: PGSocketConnectable; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_network_monitor_can_reach_async';
procedure g_network_service_set_scheme(srv: PGNetworkService; scheme: Pgchar); cdecl; external LazGio2_library name 'g_network_service_set_scheme';
procedure g_networking_init; cdecl; external LazGio2_library name 'g_networking_init';
procedure g_notification_add_button(notification: PGNotification; label_: Pgchar; detailed_action: Pgchar); cdecl; external LazGio2_library name 'g_notification_add_button';
procedure g_notification_add_button_with_target(notification: PGNotification; label_: Pgchar; action: Pgchar; target_format: Pgchar; args: array of const); cdecl; external LazGio2_library name 'g_notification_add_button_with_target';
procedure g_notification_add_button_with_target_value(notification: PGNotification; label_: Pgchar; action: Pgchar; target: PGVariant); cdecl; external LazGio2_library name 'g_notification_add_button_with_target_value';
procedure g_notification_set_body(notification: PGNotification; body: Pgchar); cdecl; external LazGio2_library name 'g_notification_set_body';
procedure g_notification_set_default_action(notification: PGNotification; detailed_action: Pgchar); cdecl; external LazGio2_library name 'g_notification_set_default_action';
procedure g_notification_set_default_action_and_target(notification: PGNotification; action: Pgchar; target_format: Pgchar; args: array of const); cdecl; external LazGio2_library name 'g_notification_set_default_action_and_target';
procedure g_notification_set_default_action_and_target_value(notification: PGNotification; action: Pgchar; target: PGVariant); cdecl; external LazGio2_library name 'g_notification_set_default_action_and_target_value';
procedure g_notification_set_icon(notification: PGNotification; icon: PGIcon); cdecl; external LazGio2_library name 'g_notification_set_icon';
procedure g_notification_set_priority(notification: PGNotification; priority: TGNotificationPriority); cdecl; external LazGio2_library name 'g_notification_set_priority';
procedure g_notification_set_title(notification: PGNotification; title: Pgchar); cdecl; external LazGio2_library name 'g_notification_set_title';
procedure g_output_stream_clear_pending(stream: PGOutputStream); cdecl; external LazGio2_library name 'g_output_stream_clear_pending';
procedure g_output_stream_close_async(stream: PGOutputStream; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_output_stream_close_async';
procedure g_output_stream_flush_async(stream: PGOutputStream; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_output_stream_flush_async';
procedure g_output_stream_splice_async(stream: PGOutputStream; source: PGInputStream; flags: TGOutputStreamSpliceFlags; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_output_stream_splice_async';
procedure g_output_stream_write_all_async(stream: PGOutputStream; buffer: Pguint8; count: gsize; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_output_stream_write_all_async';
procedure g_output_stream_write_async(stream: PGOutputStream; buffer: Pguint8; count: gsize; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_output_stream_write_async';
procedure g_output_stream_write_bytes_async(stream: PGOutputStream; bytes: PGBytes; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_output_stream_write_bytes_async';
procedure g_output_stream_writev_all_async(stream: PGOutputStream; vectors: PGOutputVector; n_vectors: gsize; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_output_stream_writev_all_async';
procedure g_output_stream_writev_async(stream: PGOutputStream; vectors: PGOutputVector; n_vectors: gsize; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_output_stream_writev_async';
procedure g_permission_acquire_async(permission: PGPermission; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_permission_acquire_async';
procedure g_permission_impl_update(permission: PGPermission; allowed: gboolean; can_acquire: gboolean; can_release: gboolean); cdecl; external LazGio2_library name 'g_permission_impl_update';
procedure g_permission_release_async(permission: PGPermission; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_permission_release_async';
procedure g_proxy_connect_async(proxy: PGProxy; connection: PGIOStream; proxy_address: PGProxyAddress; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_proxy_connect_async';
procedure g_proxy_resolver_lookup_async(resolver: PGProxyResolver; uri: Pgchar; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_proxy_resolver_lookup_async';
procedure g_remote_action_group_activate_action_full(remote: PGRemoteActionGroup; action_name: Pgchar; parameter: PGVariant; platform_data: PGVariant); cdecl; external LazGio2_library name 'g_remote_action_group_activate_action_full';
procedure g_remote_action_group_change_action_state_full(remote: PGRemoteActionGroup; action_name: Pgchar; value: PGVariant; platform_data: PGVariant); cdecl; external LazGio2_library name 'g_remote_action_group_change_action_state_full';
procedure g_resolver_free_addresses(addresses: PGList); cdecl; external LazGio2_library name 'g_resolver_free_addresses';
procedure g_resolver_free_targets(targets: PGList); cdecl; external LazGio2_library name 'g_resolver_free_targets';
procedure g_resolver_lookup_by_address_async(resolver: PGResolver; address: PGInetAddress; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_resolver_lookup_by_address_async';
procedure g_resolver_lookup_by_name_async(resolver: PGResolver; hostname: Pgchar; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_resolver_lookup_by_name_async';
procedure g_resolver_lookup_by_name_with_flags_async(resolver: PGResolver; hostname: Pgchar; flags: TGResolverNameLookupFlags; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_resolver_lookup_by_name_with_flags_async';
procedure g_resolver_lookup_records_async(resolver: PGResolver; rrname: Pgchar; record_type: TGResolverRecordType; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_resolver_lookup_records_async';
procedure g_resolver_lookup_service_async(resolver: PGResolver; service: Pgchar; protocol: Pgchar; domain: Pgchar; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_resolver_lookup_service_async';
procedure g_resolver_set_default(resolver: PGResolver); cdecl; external LazGio2_library name 'g_resolver_set_default';
procedure g_resource_unref(resource: PGResource); cdecl; external LazGio2_library name 'g_resource_unref';
procedure g_resources_register(resource: PGResource); cdecl; external LazGio2_library name 'g_resources_register';
procedure g_resources_unregister(resource: PGResource); cdecl; external LazGio2_library name 'g_resources_unregister';
procedure g_settings_apply(settings: PGSettings); cdecl; external LazGio2_library name 'g_settings_apply';
procedure g_settings_backend_changed(backend: PGSettingsBackend; key: Pgchar; origin_tag: gpointer); cdecl; external LazGio2_library name 'g_settings_backend_changed';
procedure g_settings_backend_changed_tree(backend: PGSettingsBackend; tree: PGTree; origin_tag: gpointer); cdecl; external LazGio2_library name 'g_settings_backend_changed_tree';
procedure g_settings_backend_flatten_tree(tree: PGTree; path: PPgchar; keys: PPPgchar; values: PPPGVariant); cdecl; external LazGio2_library name 'g_settings_backend_flatten_tree';
procedure g_settings_backend_keys_changed(backend: PGSettingsBackend; path: Pgchar; items: PPgchar; origin_tag: gpointer); cdecl; external LazGio2_library name 'g_settings_backend_keys_changed';
procedure g_settings_backend_path_changed(backend: PGSettingsBackend; path: Pgchar; origin_tag: gpointer); cdecl; external LazGio2_library name 'g_settings_backend_path_changed';
procedure g_settings_backend_path_writable_changed(backend: PGSettingsBackend; path: Pgchar); cdecl; external LazGio2_library name 'g_settings_backend_path_writable_changed';
procedure g_settings_backend_writable_changed(backend: PGSettingsBackend; key: Pgchar); cdecl; external LazGio2_library name 'g_settings_backend_writable_changed';
procedure g_settings_bind(settings: PGSettings; key: Pgchar; object_: PGObject; property_: Pgchar; flags: TGSettingsBindFlags); cdecl; external LazGio2_library name 'g_settings_bind';
procedure g_settings_bind_with_mapping(settings: PGSettings; key: Pgchar; object_: PGObject; property_: Pgchar; flags: TGSettingsBindFlags; get_mapping: TGSettingsBindGetMapping; set_mapping: TGSettingsBindSetMapping; user_data: gpointer; destroy_: TGDestroyNotify); cdecl; external LazGio2_library name 'g_settings_bind_with_mapping';
procedure g_settings_bind_writable(settings: PGSettings; key: Pgchar; object_: PGObject; property_: Pgchar; inverted: gboolean); cdecl; external LazGio2_library name 'g_settings_bind_writable';
procedure g_settings_delay(settings: PGSettings); cdecl; external LazGio2_library name 'g_settings_delay';
procedure g_settings_get(settings: PGSettings; key: Pgchar; format: Pgchar; args: array of const); cdecl; external LazGio2_library name 'g_settings_get';
procedure g_settings_reset(settings: PGSettings; key: Pgchar); cdecl; external LazGio2_library name 'g_settings_reset';
procedure g_settings_revert(settings: PGSettings); cdecl; external LazGio2_library name 'g_settings_revert';
procedure g_settings_schema_key_unref(key: PGSettingsSchemaKey); cdecl; external LazGio2_library name 'g_settings_schema_key_unref';
procedure g_settings_schema_source_list_schemas(source: PGSettingsSchemaSource; recursive: gboolean; non_relocatable: PPPgchar; relocatable: PPPgchar); cdecl; external LazGio2_library name 'g_settings_schema_source_list_schemas';
procedure g_settings_schema_source_unref(source: PGSettingsSchemaSource); cdecl; external LazGio2_library name 'g_settings_schema_source_unref';
procedure g_settings_schema_unref(schema: PGSettingsSchema); cdecl; external LazGio2_library name 'g_settings_schema_unref';
procedure g_settings_sync; cdecl; external LazGio2_library name 'g_settings_sync';
procedure g_settings_unbind(object_: PGObject; property_: Pgchar); cdecl; external LazGio2_library name 'g_settings_unbind';
procedure g_simple_action_set_enabled(simple: PGSimpleAction; enabled: gboolean); cdecl; external LazGio2_library name 'g_simple_action_set_enabled';
procedure g_simple_action_set_state(simple: PGSimpleAction; value: PGVariant); cdecl; external LazGio2_library name 'g_simple_action_set_state';
procedure g_simple_action_set_state_hint(simple: PGSimpleAction; state_hint: PGVariant); cdecl; external LazGio2_library name 'g_simple_action_set_state_hint';
procedure g_simple_proxy_resolver_set_default_proxy(resolver: PGSimpleProxyResolver; default_proxy: Pgchar); cdecl; external LazGio2_library name 'g_simple_proxy_resolver_set_default_proxy';
procedure g_simple_proxy_resolver_set_ignore_hosts(resolver: PGSimpleProxyResolver; ignore_hosts: PPgchar); cdecl; external LazGio2_library name 'g_simple_proxy_resolver_set_ignore_hosts';
procedure g_simple_proxy_resolver_set_uri_proxy(resolver: PGSimpleProxyResolver; uri_scheme: Pgchar; proxy: Pgchar); cdecl; external LazGio2_library name 'g_simple_proxy_resolver_set_uri_proxy';
procedure g_socket_address_enumerator_next_async(enumerator: PGSocketAddressEnumerator; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_socket_address_enumerator_next_async';
procedure g_socket_client_add_application_proxy(client: PGSocketClient; protocol: Pgchar); cdecl; external LazGio2_library name 'g_socket_client_add_application_proxy';
procedure g_socket_client_connect_async(client: PGSocketClient; connectable: PGSocketConnectable; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_socket_client_connect_async';
procedure g_socket_client_connect_to_host_async(client: PGSocketClient; host_and_port: Pgchar; default_port: guint16; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_socket_client_connect_to_host_async';
procedure g_socket_client_connect_to_service_async(client: PGSocketClient; domain: Pgchar; service: Pgchar; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_socket_client_connect_to_service_async';
procedure g_socket_client_connect_to_uri_async(client: PGSocketClient; uri: Pgchar; default_port: guint16; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_socket_client_connect_to_uri_async';
procedure g_socket_client_set_enable_proxy(client: PGSocketClient; enable: gboolean); cdecl; external LazGio2_library name 'g_socket_client_set_enable_proxy';
procedure g_socket_client_set_family(client: PGSocketClient; family: TGSocketFamily); cdecl; external LazGio2_library name 'g_socket_client_set_family';
procedure g_socket_client_set_local_address(client: PGSocketClient; address: PGSocketAddress); cdecl; external LazGio2_library name 'g_socket_client_set_local_address';
procedure g_socket_client_set_protocol(client: PGSocketClient; protocol: TGSocketProtocol); cdecl; external LazGio2_library name 'g_socket_client_set_protocol';
procedure g_socket_client_set_proxy_resolver(client: PGSocketClient; proxy_resolver: PGProxyResolver); cdecl; external LazGio2_library name 'g_socket_client_set_proxy_resolver';
procedure g_socket_client_set_socket_type(client: PGSocketClient; type_: TGSocketType); cdecl; external LazGio2_library name 'g_socket_client_set_socket_type';
procedure g_socket_client_set_timeout(client: PGSocketClient; timeout: guint); cdecl; external LazGio2_library name 'g_socket_client_set_timeout';
procedure g_socket_client_set_tls(client: PGSocketClient; tls: gboolean); cdecl; external LazGio2_library name 'g_socket_client_set_tls';
procedure g_socket_client_set_tls_validation_flags(client: PGSocketClient; flags: TGTlsCertificateFlags); cdecl; external LazGio2_library name 'g_socket_client_set_tls_validation_flags'; deprecated 'Do not attempt to ignore validation errors.';
procedure g_socket_connection_connect_async(connection: PGSocketConnection; address: PGSocketAddress; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_socket_connection_connect_async';
procedure g_socket_connection_factory_register_type(g_type: TGType; family: TGSocketFamily; type_: TGSocketType; protocol: gint); cdecl; external LazGio2_library name 'g_socket_connection_factory_register_type';
procedure g_socket_control_message_serialize(message: PGSocketControlMessage; data: gpointer); cdecl; external LazGio2_library name 'g_socket_control_message_serialize';
procedure g_socket_listener_accept_async(listener: PGSocketListener; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_socket_listener_accept_async';
procedure g_socket_listener_accept_socket_async(listener: PGSocketListener; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_socket_listener_accept_socket_async';
procedure g_socket_listener_close(listener: PGSocketListener); cdecl; external LazGio2_library name 'g_socket_listener_close';
procedure g_socket_listener_set_backlog(listener: PGSocketListener; listen_backlog: gint); cdecl; external LazGio2_library name 'g_socket_listener_set_backlog';
procedure g_socket_service_start(service: PGSocketService); cdecl; external LazGio2_library name 'g_socket_service_start';
procedure g_socket_service_stop(service: PGSocketService); cdecl; external LazGio2_library name 'g_socket_service_stop';
procedure g_socket_set_blocking(socket: PGSocket; blocking: gboolean); cdecl; external LazGio2_library name 'g_socket_set_blocking';
procedure g_socket_set_broadcast(socket: PGSocket; broadcast: gboolean); cdecl; external LazGio2_library name 'g_socket_set_broadcast';
procedure g_socket_set_keepalive(socket: PGSocket; keepalive: gboolean); cdecl; external LazGio2_library name 'g_socket_set_keepalive';
procedure g_socket_set_listen_backlog(socket: PGSocket; backlog: gint); cdecl; external LazGio2_library name 'g_socket_set_listen_backlog';
procedure g_socket_set_multicast_loopback(socket: PGSocket; loopback: gboolean); cdecl; external LazGio2_library name 'g_socket_set_multicast_loopback';
procedure g_socket_set_multicast_ttl(socket: PGSocket; ttl: guint); cdecl; external LazGio2_library name 'g_socket_set_multicast_ttl';
procedure g_socket_set_timeout(socket: PGSocket; timeout: guint); cdecl; external LazGio2_library name 'g_socket_set_timeout';
procedure g_socket_set_ttl(socket: PGSocket; ttl: guint); cdecl; external LazGio2_library name 'g_socket_set_ttl';
procedure g_srv_target_free(target: PGSrvTarget); cdecl; external LazGio2_library name 'g_srv_target_free';
procedure g_static_resource_fini(static_resource: PGStaticResource); cdecl; external LazGio2_library name 'g_static_resource_fini';
procedure g_static_resource_init(static_resource: PGStaticResource); cdecl; external LazGio2_library name 'g_static_resource_init';
procedure g_subprocess_communicate_async(subprocess: PGSubprocess; stdin_buf: PGBytes; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_subprocess_communicate_async';
procedure g_subprocess_communicate_utf8_async(subprocess: PGSubprocess; stdin_buf: Pgchar; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_subprocess_communicate_utf8_async';
procedure g_subprocess_force_exit(subprocess: PGSubprocess); cdecl; external LazGio2_library name 'g_subprocess_force_exit';
procedure g_subprocess_launcher_set_child_setup(self: PGSubprocessLauncher; child_setup: TGSpawnChildSetupFunc; user_data: gpointer; destroy_notify: TGDestroyNotify); cdecl; external LazGio2_library name 'g_subprocess_launcher_set_child_setup';
procedure g_subprocess_launcher_set_cwd(self: PGSubprocessLauncher; cwd: Pgchar); cdecl; external LazGio2_library name 'g_subprocess_launcher_set_cwd';
procedure g_subprocess_launcher_set_environ(self: PGSubprocessLauncher; env: PPgchar); cdecl; external LazGio2_library name 'g_subprocess_launcher_set_environ';
procedure g_subprocess_launcher_set_flags(self: PGSubprocessLauncher; flags: TGSubprocessFlags); cdecl; external LazGio2_library name 'g_subprocess_launcher_set_flags';
procedure g_subprocess_launcher_set_stderr_file_path(self: PGSubprocessLauncher; path: Pgchar); cdecl; external LazGio2_library name 'g_subprocess_launcher_set_stderr_file_path';
procedure g_subprocess_launcher_set_stdin_file_path(self: PGSubprocessLauncher; path: Pgchar); cdecl; external LazGio2_library name 'g_subprocess_launcher_set_stdin_file_path';
procedure g_subprocess_launcher_set_stdout_file_path(self: PGSubprocessLauncher; path: Pgchar); cdecl; external LazGio2_library name 'g_subprocess_launcher_set_stdout_file_path';
procedure g_subprocess_launcher_setenv(self: PGSubprocessLauncher; variable: Pgchar; value: Pgchar; overwrite: gboolean); cdecl; external LazGio2_library name 'g_subprocess_launcher_setenv';
procedure g_subprocess_launcher_take_fd(self: PGSubprocessLauncher; source_fd: gint; target_fd: gint); cdecl; external LazGio2_library name 'g_subprocess_launcher_take_fd';
procedure g_subprocess_launcher_take_stderr_fd(self: PGSubprocessLauncher; fd: gint); cdecl; external LazGio2_library name 'g_subprocess_launcher_take_stderr_fd';
procedure g_subprocess_launcher_take_stdin_fd(self: PGSubprocessLauncher; fd: gint); cdecl; external LazGio2_library name 'g_subprocess_launcher_take_stdin_fd';
procedure g_subprocess_launcher_take_stdout_fd(self: PGSubprocessLauncher; fd: gint); cdecl; external LazGio2_library name 'g_subprocess_launcher_take_stdout_fd';
procedure g_subprocess_launcher_unsetenv(self: PGSubprocessLauncher; variable: Pgchar); cdecl; external LazGio2_library name 'g_subprocess_launcher_unsetenv';
procedure g_subprocess_send_signal(subprocess: PGSubprocess; signal_num: gint); cdecl; external LazGio2_library name 'g_subprocess_send_signal';
procedure g_subprocess_wait_async(subprocess: PGSubprocess; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_subprocess_wait_async';
procedure g_subprocess_wait_check_async(subprocess: PGSubprocess; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_subprocess_wait_check_async';
procedure g_task_attach_source(task: PGTask; source: PGSource; callback: TGSourceFunc); cdecl; external LazGio2_library name 'g_task_attach_source';
procedure g_task_report_error(source_object: PGObject; callback: TGAsyncReadyCallback; callback_data: gpointer; source_tag: gpointer; error: PGError); cdecl; external LazGio2_library name 'g_task_report_error';
procedure g_task_report_new_error(source_object: PGObject; callback: TGAsyncReadyCallback; callback_data: gpointer; source_tag: gpointer; domain: TGQuark; code: gint; format: Pgchar; args: array of const); cdecl; external LazGio2_library name 'g_task_report_new_error';
procedure g_task_return_boolean(task: PGTask; result_: gboolean); cdecl; external LazGio2_library name 'g_task_return_boolean';
procedure g_task_return_error(task: PGTask; error: PGError); cdecl; external LazGio2_library name 'g_task_return_error';
procedure g_task_return_int(task: PGTask; result_: gssize); cdecl; external LazGio2_library name 'g_task_return_int';
procedure g_task_return_new_error(task: PGTask; domain: TGQuark; code: gint; format: Pgchar; args: array of const); cdecl; external LazGio2_library name 'g_task_return_new_error';
procedure g_task_return_pointer(task: PGTask; result_: gpointer; result_destroy: TGDestroyNotify); cdecl; external LazGio2_library name 'g_task_return_pointer';
procedure g_task_return_value(task: PGTask; result_: PGValue); cdecl; external LazGio2_library name 'g_task_return_value';
procedure g_task_run_in_thread(task: PGTask; task_func: TGTaskThreadFunc); cdecl; external LazGio2_library name 'g_task_run_in_thread';
procedure g_task_run_in_thread_sync(task: PGTask; task_func: TGTaskThreadFunc); cdecl; external LazGio2_library name 'g_task_run_in_thread_sync';
procedure g_task_set_check_cancellable(task: PGTask; check_cancellable: gboolean); cdecl; external LazGio2_library name 'g_task_set_check_cancellable';
procedure g_task_set_name(task: PGTask; name: Pgchar); cdecl; external LazGio2_library name 'g_task_set_name';
procedure g_task_set_priority(task: PGTask; priority: gint); cdecl; external LazGio2_library name 'g_task_set_priority';
procedure g_task_set_source_tag(task: PGTask; source_tag: gpointer); cdecl; external LazGio2_library name 'g_task_set_source_tag';
procedure g_task_set_task_data(task: PGTask; task_data: gpointer; task_data_destroy: TGDestroyNotify); cdecl; external LazGio2_library name 'g_task_set_task_data';
procedure g_tcp_connection_set_graceful_disconnect(connection: PGTcpConnection; graceful_disconnect: gboolean); cdecl; external LazGio2_library name 'g_tcp_connection_set_graceful_disconnect';
procedure g_test_dbus_add_service_dir(self: PGTestDBus; path: Pgchar); cdecl; external LazGio2_library name 'g_test_dbus_add_service_dir';
procedure g_test_dbus_down(self: PGTestDBus); cdecl; external LazGio2_library name 'g_test_dbus_down';
procedure g_test_dbus_stop(self: PGTestDBus); cdecl; external LazGio2_library name 'g_test_dbus_stop';
procedure g_test_dbus_unset; cdecl; external LazGio2_library name 'g_test_dbus_unset';
procedure g_test_dbus_up(self: PGTestDBus); cdecl; external LazGio2_library name 'g_test_dbus_up';
procedure g_themed_icon_append_name(icon: PGThemedIcon; iconname: Pgchar); cdecl; external LazGio2_library name 'g_themed_icon_append_name';
procedure g_themed_icon_prepend_name(icon: PGThemedIcon; iconname: Pgchar); cdecl; external LazGio2_library name 'g_themed_icon_prepend_name';
procedure g_tls_backend_set_default_database(backend: PGTlsBackend; database: PGTlsDatabase); cdecl; external LazGio2_library name 'g_tls_backend_set_default_database';
procedure g_tls_client_connection_copy_session_state(conn: PGTlsClientConnection; source: PGTlsClientConnection); cdecl; external LazGio2_library name 'g_tls_client_connection_copy_session_state';
procedure g_tls_client_connection_set_server_identity(conn: PGTlsClientConnection; identity: PGSocketConnectable); cdecl; external LazGio2_library name 'g_tls_client_connection_set_server_identity';
procedure g_tls_client_connection_set_validation_flags(conn: PGTlsClientConnection; flags: TGTlsCertificateFlags); cdecl; external LazGio2_library name 'g_tls_client_connection_set_validation_flags'; deprecated 'Do not attempt to ignore validation errors.';
procedure g_tls_connection_handshake_async(conn: PGTlsConnection; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_tls_connection_handshake_async';
procedure g_tls_connection_set_advertised_protocols(conn: PGTlsConnection; protocols: PPgchar); cdecl; external LazGio2_library name 'g_tls_connection_set_advertised_protocols';
procedure g_tls_connection_set_certificate(conn: PGTlsConnection; certificate: PGTlsCertificate); cdecl; external LazGio2_library name 'g_tls_connection_set_certificate';
procedure g_tls_connection_set_database(conn: PGTlsConnection; database: PGTlsDatabase); cdecl; external LazGio2_library name 'g_tls_connection_set_database';
procedure g_tls_connection_set_interaction(conn: PGTlsConnection; interaction: PGTlsInteraction); cdecl; external LazGio2_library name 'g_tls_connection_set_interaction';
procedure g_tls_connection_set_require_close_notify(conn: PGTlsConnection; require_close_notify: gboolean); cdecl; external LazGio2_library name 'g_tls_connection_set_require_close_notify';
procedure g_tls_database_lookup_certificate_for_handle_async(self: PGTlsDatabase; handle: Pgchar; interaction: PGTlsInteraction; flags: TGTlsDatabaseLookupFlags; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_tls_database_lookup_certificate_for_handle_async';
procedure g_tls_database_lookup_certificate_issuer_async(self: PGTlsDatabase; certificate: PGTlsCertificate; interaction: PGTlsInteraction; flags: TGTlsDatabaseLookupFlags; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_tls_database_lookup_certificate_issuer_async';
procedure g_tls_database_lookup_certificates_issued_by_async(self: PGTlsDatabase; issuer_raw_dn: Pguint8; interaction: PGTlsInteraction; flags: TGTlsDatabaseLookupFlags; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_tls_database_lookup_certificates_issued_by_async';
procedure g_tls_database_verify_chain_async(self: PGTlsDatabase; chain: PGTlsCertificate; purpose: Pgchar; identity: PGSocketConnectable; interaction: PGTlsInteraction; flags: TGTlsDatabaseVerifyFlags; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_tls_database_verify_chain_async';
procedure g_tls_interaction_ask_password_async(interaction: PGTlsInteraction; password: PGTlsPassword; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_tls_interaction_ask_password_async';
procedure g_tls_interaction_request_certificate_async(interaction: PGTlsInteraction; connection: PGTlsConnection; flags: TGTlsCertificateRequestFlags; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_tls_interaction_request_certificate_async';
procedure g_tls_password_set_description(password: PGTlsPassword; description: Pgchar); cdecl; external LazGio2_library name 'g_tls_password_set_description';
procedure g_tls_password_set_flags(password: PGTlsPassword; flags: TGTlsPasswordFlags); cdecl; external LazGio2_library name 'g_tls_password_set_flags';
procedure g_tls_password_set_value(password: PGTlsPassword; value: Pguint8; length: gssize); cdecl; external LazGio2_library name 'g_tls_password_set_value';
procedure g_tls_password_set_value_full(password: PGTlsPassword; value: Pguint8; length: gssize; destroy_: TGDestroyNotify); cdecl; external LazGio2_library name 'g_tls_password_set_value_full';
procedure g_tls_password_set_warning(password: PGTlsPassword; warning: Pgchar); cdecl; external LazGio2_library name 'g_tls_password_set_warning';
procedure g_unix_connection_receive_credentials_async(connection: PGUnixConnection; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_unix_connection_receive_credentials_async';
procedure g_unix_connection_send_credentials_async(connection: PGUnixConnection; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_unix_connection_send_credentials_async';
procedure g_unix_input_stream_set_close_fd(stream: PGUnixInputStream; close_fd: gboolean); cdecl; external LazGio2_library name 'g_unix_input_stream_set_close_fd';
procedure g_unix_mount_free(mount_entry: PGUnixMountEntry); cdecl; external LazGio2_library name 'g_unix_mount_free';
procedure g_unix_mount_point_free(mount_point: PGUnixMountPoint); cdecl; external LazGio2_library name 'g_unix_mount_point_free';
procedure g_unix_output_stream_set_close_fd(stream: PGUnixOutputStream; close_fd: gboolean); cdecl; external LazGio2_library name 'g_unix_output_stream_set_close_fd';
procedure g_volume_eject_with_operation(volume: PGVolume; flags: TGMountUnmountFlags; mount_operation: PGMountOperation; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_volume_eject_with_operation';
procedure g_volume_mount(volume: PGVolume; flags: TGMountMountFlags; mount_operation: PGMountOperation; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl; external LazGio2_library name 'g_volume_mount';
procedure g_zlib_compressor_set_file_info(compressor: PGZlibCompressor; file_info: PGFileInfo); cdecl; external LazGio2_library name 'g_zlib_compressor_set_file_info';
implementation
function TGAction.name_is_valid(action_name: Pgchar): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_action_name_is_valid(action_name);
end;

function TGAction.parse_detailed_name(detailed_name: Pgchar; action_name: PPgchar; target_value: PPGVariant; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_action_parse_detailed_name(detailed_name, action_name, target_value, error);
end;

function TGAction.print_detailed_name(action_name: Pgchar; target_value: PGVariant): Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_action_print_detailed_name(action_name, target_value);
end;

procedure TGAction.activate(parameter: PGVariant); cdecl;
begin
  CastleInternalGio2.g_action_activate(@self, parameter);
end;

procedure TGAction.change_state(value: PGVariant); cdecl;
begin
  CastleInternalGio2.g_action_change_state(@self, value);
end;

function TGAction.get_enabled: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_action_get_enabled(@self);
end;

function TGAction.get_name: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_action_get_name(@self);
end;

function TGAction.get_parameter_type: PGVariantType; cdecl;
begin
  Result := CastleInternalGio2.g_action_get_parameter_type(@self);
end;

function TGAction.get_state: PGVariant; cdecl;
begin
  Result := CastleInternalGio2.g_action_get_state(@self);
end;

function TGAction.get_state_hint: PGVariant; cdecl;
begin
  Result := CastleInternalGio2.g_action_get_state_hint(@self);
end;

function TGAction.get_state_type: PGVariantType; cdecl;
begin
  Result := CastleInternalGio2.g_action_get_state_type(@self);
end;

function TGSimpleAction.new(name: Pgchar; parameter_type: PGVariantType): PGSimpleAction; cdecl;
begin
  Result := CastleInternalGio2.g_simple_action_new(name, parameter_type);
end;

function TGSimpleAction.new_stateful(name: Pgchar; parameter_type: PGVariantType; state: PGVariant): PGSimpleAction; cdecl;
begin
  Result := CastleInternalGio2.g_simple_action_new_stateful(name, parameter_type, state);
end;

procedure TGSimpleAction.set_enabled(enabled: gboolean); cdecl;
begin
  CastleInternalGio2.g_simple_action_set_enabled(@self, enabled);
end;

procedure TGSimpleAction.set_state(value: PGVariant); cdecl;
begin
  CastleInternalGio2.g_simple_action_set_state(@self, value);
end;

procedure TGSimpleAction.set_state_hint(state_hint: PGVariant); cdecl;
begin
  CastleInternalGio2.g_simple_action_set_state_hint(@self, state_hint);
end;

procedure TGActionGroup.action_added(action_name: Pgchar); cdecl;
begin
  CastleInternalGio2.g_action_group_action_added(@self, action_name);
end;

procedure TGActionGroup.action_enabled_changed(action_name: Pgchar; enabled: gboolean); cdecl;
begin
  CastleInternalGio2.g_action_group_action_enabled_changed(@self, action_name, enabled);
end;

procedure TGActionGroup.action_removed(action_name: Pgchar); cdecl;
begin
  CastleInternalGio2.g_action_group_action_removed(@self, action_name);
end;

procedure TGActionGroup.action_state_changed(action_name: Pgchar; state: PGVariant); cdecl;
begin
  CastleInternalGio2.g_action_group_action_state_changed(@self, action_name, state);
end;

procedure TGActionGroup.activate_action(action_name: Pgchar; parameter: PGVariant); cdecl;
begin
  CastleInternalGio2.g_action_group_activate_action(@self, action_name, parameter);
end;

procedure TGActionGroup.change_action_state(action_name: Pgchar; value: PGVariant); cdecl;
begin
  CastleInternalGio2.g_action_group_change_action_state(@self, action_name, value);
end;

function TGActionGroup.get_action_enabled(action_name: Pgchar): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_action_group_get_action_enabled(@self, action_name);
end;

function TGActionGroup.get_action_parameter_type(action_name: Pgchar): PGVariantType; cdecl;
begin
  Result := CastleInternalGio2.g_action_group_get_action_parameter_type(@self, action_name);
end;

function TGActionGroup.get_action_state(action_name: Pgchar): PGVariant; cdecl;
begin
  Result := CastleInternalGio2.g_action_group_get_action_state(@self, action_name);
end;

function TGActionGroup.get_action_state_hint(action_name: Pgchar): PGVariant; cdecl;
begin
  Result := CastleInternalGio2.g_action_group_get_action_state_hint(@self, action_name);
end;

function TGActionGroup.get_action_state_type(action_name: Pgchar): PGVariantType; cdecl;
begin
  Result := CastleInternalGio2.g_action_group_get_action_state_type(@self, action_name);
end;

function TGActionGroup.has_action(action_name: Pgchar): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_action_group_has_action(@self, action_name);
end;

function TGActionGroup.list_actions: PPgchar; cdecl;
begin
  Result := CastleInternalGio2.g_action_group_list_actions(@self);
end;

function TGActionGroup.query_action(action_name: Pgchar; enabled: Pgboolean; parameter_type: PPGVariantType; state_type: PPGVariantType; state_hint: PPGVariant; state: PPGVariant): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_action_group_query_action(@self, action_name, enabled, parameter_type, state_type, state_hint, state);
end;

procedure TGActionMap.add_action(action: PGAction); cdecl;
begin
  CastleInternalGio2.g_action_map_add_action(@self, action);
end;

procedure TGActionMap.add_action_entries(entries: PGActionEntry; n_entries: gint; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_action_map_add_action_entries(@self, entries, n_entries, user_data);
end;

function TGActionMap.lookup_action(action_name: Pgchar): PGAction; cdecl;
begin
  Result := CastleInternalGio2.g_action_map_lookup_action(@self, action_name);
end;

procedure TGActionMap.remove_action(action_name: Pgchar); cdecl;
begin
  CastleInternalGio2.g_action_map_remove_action(@self, action_name);
end;

function TGAppInfo.create_from_commandline(commandline: Pgchar; application_name: Pgchar; flags: TGAppInfoCreateFlags; error: PPGError): PGAppInfo; cdecl;
begin
  Result := CastleInternalGio2.g_app_info_create_from_commandline(commandline, application_name, flags, error);
end;

function TGAppInfo.get_all: PGList; cdecl;
begin
  Result := CastleInternalGio2.g_app_info_get_all();
end;

function TGAppInfo.get_all_for_type(content_type: Pgchar): PGList; cdecl;
begin
  Result := CastleInternalGio2.g_app_info_get_all_for_type(content_type);
end;

function TGAppInfo.get_default_for_type(content_type: Pgchar; must_support_uris: gboolean): PGAppInfo; cdecl;
begin
  Result := CastleInternalGio2.g_app_info_get_default_for_type(content_type, must_support_uris);
end;

function TGAppInfo.get_default_for_uri_scheme(uri_scheme: Pgchar): PGAppInfo; cdecl;
begin
  Result := CastleInternalGio2.g_app_info_get_default_for_uri_scheme(uri_scheme);
end;

function TGAppInfo.get_fallback_for_type(content_type: Pgchar): PGList; cdecl;
begin
  Result := CastleInternalGio2.g_app_info_get_fallback_for_type(content_type);
end;

function TGAppInfo.get_recommended_for_type(content_type: Pgchar): PGList; cdecl;
begin
  Result := CastleInternalGio2.g_app_info_get_recommended_for_type(content_type);
end;

function TGAppInfo.launch_default_for_uri(uri: Pgchar; context: PGAppLaunchContext; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_app_info_launch_default_for_uri(uri, context, error);
end;

procedure TGAppInfo.launch_default_for_uri_async(uri: Pgchar; context: PGAppLaunchContext; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_app_info_launch_default_for_uri_async(uri, context, cancellable, callback, user_data);
end;

function TGAppInfo.launch_default_for_uri_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_app_info_launch_default_for_uri_finish(result_, error);
end;

procedure TGAppInfo.reset_type_associations(content_type: Pgchar); cdecl;
begin
  CastleInternalGio2.g_app_info_reset_type_associations(content_type);
end;

function TGAppInfo.add_supports_type(content_type: Pgchar; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_app_info_add_supports_type(@self, content_type, error);
end;

function TGAppInfo.can_delete: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_app_info_can_delete(@self);
end;

function TGAppInfo.can_remove_supports_type: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_app_info_can_remove_supports_type(@self);
end;

function TGAppInfo.delete: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_app_info_delete(@self);
end;

function TGAppInfo.dup: PGAppInfo; cdecl;
begin
  Result := CastleInternalGio2.g_app_info_dup(@self);
end;

function TGAppInfo.equal(appinfo2: PGAppInfo): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_app_info_equal(@self, appinfo2);
end;

function TGAppInfo.get_commandline: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_app_info_get_commandline(@self);
end;

function TGAppInfo.get_description: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_app_info_get_description(@self);
end;

function TGAppInfo.get_display_name: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_app_info_get_display_name(@self);
end;

function TGAppInfo.get_executable: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_app_info_get_executable(@self);
end;

function TGAppInfo.get_icon: PGIcon; cdecl;
begin
  Result := CastleInternalGio2.g_app_info_get_icon(@self);
end;

function TGAppInfo.get_id: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_app_info_get_id(@self);
end;

function TGAppInfo.get_name: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_app_info_get_name(@self);
end;

function TGAppInfo.get_supported_types: PPgchar; cdecl;
begin
  Result := CastleInternalGio2.g_app_info_get_supported_types(@self);
end;

function TGAppInfo.launch(files: PGList; context: PGAppLaunchContext; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_app_info_launch(@self, files, context, error);
end;

function TGAppInfo.launch_uris(uris: PGList; context: PGAppLaunchContext; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_app_info_launch_uris(@self, uris, context, error);
end;

procedure TGAppInfo.launch_uris_async(uris: PGList; context: PGAppLaunchContext; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_app_info_launch_uris_async(@self, uris, context, cancellable, callback, user_data);
end;

function TGAppInfo.launch_uris_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_app_info_launch_uris_finish(@self, result_, error);
end;

function TGAppInfo.remove_supports_type(content_type: Pgchar; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_app_info_remove_supports_type(@self, content_type, error);
end;

function TGAppInfo.set_as_default_for_extension(extension: Pgchar; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_app_info_set_as_default_for_extension(@self, extension, error);
end;

function TGAppInfo.set_as_default_for_type(content_type: Pgchar; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_app_info_set_as_default_for_type(@self, content_type, error);
end;

function TGAppInfo.set_as_last_used_for_type(content_type: Pgchar; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_app_info_set_as_last_used_for_type(@self, content_type, error);
end;

function TGAppInfo.should_show: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_app_info_should_show(@self);
end;

function TGAppInfo.supports_files: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_app_info_supports_files(@self);
end;

function TGAppInfo.supports_uris: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_app_info_supports_uris(@self);
end;

function TGCancellable.new: PGCancellable; cdecl;
begin
  Result := CastleInternalGio2.g_cancellable_new();
end;

function TGCancellable.get_current: PGCancellable; cdecl;
begin
  Result := CastleInternalGio2.g_cancellable_get_current();
end;

procedure TGCancellable.cancel; cdecl;
begin
  CastleInternalGio2.g_cancellable_cancel(@self);
end;

function TGCancellable.connect(callback: TGCallback; data: gpointer; data_destroy_func: TGDestroyNotify): gulong; cdecl;
begin
  Result := CastleInternalGio2.g_cancellable_connect(@self, callback, data, data_destroy_func);
end;

procedure TGCancellable.disconnect(handler_id: gulong); cdecl;
begin
  CastleInternalGio2.g_cancellable_disconnect(@self, handler_id);
end;

function TGCancellable.get_fd: gint; cdecl;
begin
  Result := CastleInternalGio2.g_cancellable_get_fd(@self);
end;

function TGCancellable.is_cancelled: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_cancellable_is_cancelled(@self);
end;

function TGCancellable.make_pollfd(pollfd: PGPollFD): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_cancellable_make_pollfd(@self, pollfd);
end;

procedure TGCancellable.pop_current; cdecl;
begin
  CastleInternalGio2.g_cancellable_pop_current(@self);
end;

procedure TGCancellable.push_current; cdecl;
begin
  CastleInternalGio2.g_cancellable_push_current(@self);
end;

procedure TGCancellable.release_fd; cdecl;
begin
  CastleInternalGio2.g_cancellable_release_fd(@self);
end;

procedure TGCancellable.reset; cdecl;
begin
  CastleInternalGio2.g_cancellable_reset(@self);
end;

function TGCancellable.set_error_if_cancelled(error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_cancellable_set_error_if_cancelled(@self, error);
end;

function TGCancellable.source_new: PGSource; cdecl;
begin
  Result := CastleInternalGio2.g_cancellable_source_new(@self);
end;

function TGAsyncResult.get_source_object: PGObject; cdecl;
begin
  Result := CastleInternalGio2.g_async_result_get_source_object(@self);
end;

function TGAsyncResult.get_user_data: gpointer; cdecl;
begin
  Result := CastleInternalGio2.g_async_result_get_user_data(@self);
end;

function TGAsyncResult.is_tagged(source_tag: gpointer): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_async_result_is_tagged(@self, source_tag);
end;

function TGAsyncResult.legacy_propagate_error(error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_async_result_legacy_propagate_error(@self, error);
end;

function TGAppLaunchContext.new: PGAppLaunchContext; cdecl;
begin
  Result := CastleInternalGio2.g_app_launch_context_new();
end;

function TGAppLaunchContext.get_display(info: PGAppInfo; files: PGList): Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_app_launch_context_get_display(@self, info, files);
end;

function TGAppLaunchContext.get_environment: PPgchar; cdecl;
begin
  Result := CastleInternalGio2.g_app_launch_context_get_environment(@self);
end;

function TGAppLaunchContext.get_startup_notify_id(info: PGAppInfo; files: PGList): Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_app_launch_context_get_startup_notify_id(@self, info, files);
end;

procedure TGAppLaunchContext.launch_failed(startup_notify_id: Pgchar); cdecl;
begin
  CastleInternalGio2.g_app_launch_context_launch_failed(@self, startup_notify_id);
end;

procedure TGAppLaunchContext.setenv(variable: Pgchar; value: Pgchar); cdecl;
begin
  CastleInternalGio2.g_app_launch_context_setenv(@self, variable, value);
end;

procedure TGAppLaunchContext.unsetenv(variable: Pgchar); cdecl;
begin
  CastleInternalGio2.g_app_launch_context_unsetenv(@self, variable);
end;

function TGIcon.deserialize(value: PGVariant): PGIcon; cdecl;
begin
  Result := CastleInternalGio2.g_icon_deserialize(value);
end;

function TGIcon.hash(icon: Pgpointer): guint; cdecl;
begin
  Result := CastleInternalGio2.g_icon_hash(icon);
end;

function TGIcon.new_for_string(str: Pgchar; error: PPGError): PGIcon; cdecl;
begin
  Result := CastleInternalGio2.g_icon_new_for_string(str, error);
end;

function TGIcon.equal(icon2: PGIcon): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_icon_equal(@self, icon2);
end;

function TGIcon.serialize: PGVariant; cdecl;
begin
  Result := CastleInternalGio2.g_icon_serialize(@self);
end;

function TGIcon.to_string: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_icon_to_string(@self);
end;

function TGAppInfoMonitor.get: PGAppInfoMonitor; cdecl;
begin
  Result := CastleInternalGio2.g_app_info_monitor_get();
end;

function TGApplication.new(application_id: Pgchar; flags: TGApplicationFlags): PGApplication; cdecl;
begin
  Result := CastleInternalGio2.g_application_new(application_id, flags);
end;

function TGApplication.get_default: PGApplication; cdecl;
begin
  Result := CastleInternalGio2.g_application_get_default();
end;

function TGApplication.id_is_valid(application_id: Pgchar): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_application_id_is_valid(application_id);
end;

procedure TGApplication.activate; cdecl;
begin
  CastleInternalGio2.g_application_activate(@self);
end;

procedure TGApplication.add_main_option(long_name: Pgchar; short_name: gchar; flags: TGOptionFlags; arg: TGOptionArg; description: Pgchar; arg_description: Pgchar); cdecl;
begin
  CastleInternalGio2.g_application_add_main_option(@self, long_name, short_name, flags, arg, description, arg_description);
end;

procedure TGApplication.add_main_option_entries(entries: PGOptionEntry); cdecl;
begin
  CastleInternalGio2.g_application_add_main_option_entries(@self, entries);
end;

procedure TGApplication.add_option_group(group: PGOptionGroup); cdecl;
begin
  CastleInternalGio2.g_application_add_option_group(@self, group);
end;

procedure TGApplication.bind_busy_property(object_: PGObject; property_: Pgchar); cdecl;
begin
  CastleInternalGio2.g_application_bind_busy_property(@self, object_, property_);
end;

function TGApplication.get_application_id: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_application_get_application_id(@self);
end;

function TGApplication.get_dbus_connection: PGDBusConnection; cdecl;
begin
  Result := CastleInternalGio2.g_application_get_dbus_connection(@self);
end;

function TGApplication.get_dbus_object_path: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_application_get_dbus_object_path(@self);
end;

function TGApplication.get_flags: TGApplicationFlags; cdecl;
begin
  Result := CastleInternalGio2.g_application_get_flags(@self);
end;

function TGApplication.get_inactivity_timeout: guint; cdecl;
begin
  Result := CastleInternalGio2.g_application_get_inactivity_timeout(@self);
end;

function TGApplication.get_is_busy: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_application_get_is_busy(@self);
end;

function TGApplication.get_is_registered: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_application_get_is_registered(@self);
end;

function TGApplication.get_is_remote: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_application_get_is_remote(@self);
end;

function TGApplication.get_resource_base_path: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_application_get_resource_base_path(@self);
end;

procedure TGApplication.hold; cdecl;
begin
  CastleInternalGio2.g_application_hold(@self);
end;

procedure TGApplication.mark_busy; cdecl;
begin
  CastleInternalGio2.g_application_mark_busy(@self);
end;

procedure TGApplication.open(files: PPGFile; n_files: gint; hint: Pgchar); cdecl;
begin
  CastleInternalGio2.g_application_open(@self, files, n_files, hint);
end;

procedure TGApplication.quit; cdecl;
begin
  CastleInternalGio2.g_application_quit(@self);
end;

function TGApplication.register(cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_application_register(@self, cancellable, error);
end;

procedure TGApplication.release; cdecl;
begin
  CastleInternalGio2.g_application_release(@self);
end;

function TGApplication.run(argc: gint; argv: PPgchar): gint; cdecl;
begin
  Result := CastleInternalGio2.g_application_run(@self, argc, argv);
end;

procedure TGApplication.send_notification(id: Pgchar; notification: PGNotification); cdecl;
begin
  CastleInternalGio2.g_application_send_notification(@self, id, notification);
end;

procedure TGApplication.set_application_id(application_id: Pgchar); cdecl;
begin
  CastleInternalGio2.g_application_set_application_id(@self, application_id);
end;

procedure TGApplication.set_default; cdecl;
begin
  CastleInternalGio2.g_application_set_default(@self);
end;

procedure TGApplication.set_flags(flags: TGApplicationFlags); cdecl;
begin
  CastleInternalGio2.g_application_set_flags(@self, flags);
end;

procedure TGApplication.set_inactivity_timeout(inactivity_timeout: guint); cdecl;
begin
  CastleInternalGio2.g_application_set_inactivity_timeout(@self, inactivity_timeout);
end;

procedure TGApplication.set_option_context_description(description: Pgchar); cdecl;
begin
  CastleInternalGio2.g_application_set_option_context_description(@self, description);
end;

procedure TGApplication.set_option_context_parameter_string(parameter_string: Pgchar); cdecl;
begin
  CastleInternalGio2.g_application_set_option_context_parameter_string(@self, parameter_string);
end;

procedure TGApplication.set_option_context_summary(summary: Pgchar); cdecl;
begin
  CastleInternalGio2.g_application_set_option_context_summary(@self, summary);
end;

procedure TGApplication.set_resource_base_path(resource_path: Pgchar); cdecl;
begin
  CastleInternalGio2.g_application_set_resource_base_path(@self, resource_path);
end;

procedure TGApplication.unbind_busy_property(object_: PGObject; property_: Pgchar); cdecl;
begin
  CastleInternalGio2.g_application_unbind_busy_property(@self, object_, property_);
end;

procedure TGApplication.unmark_busy; cdecl;
begin
  CastleInternalGio2.g_application_unmark_busy(@self);
end;

procedure TGApplication.withdraw_notification(id: Pgchar); cdecl;
begin
  CastleInternalGio2.g_application_withdraw_notification(@self, id);
end;

function TGApplicationCommandLine.create_file_for_arg(arg: Pgchar): PGFile; cdecl;
begin
  Result := CastleInternalGio2.g_application_command_line_create_file_for_arg(@self, arg);
end;

function TGApplicationCommandLine.get_arguments(argc: Pgint): PPgchar; cdecl;
begin
  Result := CastleInternalGio2.g_application_command_line_get_arguments(@self, argc);
end;

function TGApplicationCommandLine.get_cwd: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_application_command_line_get_cwd(@self);
end;

function TGApplicationCommandLine.get_environ: PPgchar; cdecl;
begin
  Result := CastleInternalGio2.g_application_command_line_get_environ(@self);
end;

function TGApplicationCommandLine.get_exit_status: gint; cdecl;
begin
  Result := CastleInternalGio2.g_application_command_line_get_exit_status(@self);
end;

function TGApplicationCommandLine.get_is_remote: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_application_command_line_get_is_remote(@self);
end;

function TGApplicationCommandLine.get_options_dict: PGVariantDict; cdecl;
begin
  Result := CastleInternalGio2.g_application_command_line_get_options_dict(@self);
end;

function TGApplicationCommandLine.get_platform_data: PGVariant; cdecl;
begin
  Result := CastleInternalGio2.g_application_command_line_get_platform_data(@self);
end;

function TGApplicationCommandLine.get_stdin: PGInputStream; cdecl;
begin
  Result := CastleInternalGio2.g_application_command_line_get_stdin(@self);
end;

function TGApplicationCommandLine.getenv(name: Pgchar): Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_application_command_line_getenv(@self, name);
end;

procedure TGApplicationCommandLine.set_exit_status(exit_status: gint); cdecl;
begin
  CastleInternalGio2.g_application_command_line_set_exit_status(@self, exit_status);
end;

function TGDBusConnection.new_finish(res: PGAsyncResult; error: PPGError): PGDBusConnection; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_connection_new_finish(res, error);
end;

function TGDBusConnection.new_for_address_finish(res: PGAsyncResult; error: PPGError): PGDBusConnection; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_connection_new_for_address_finish(res, error);
end;

function TGDBusConnection.new_for_address_sync(address: Pgchar; flags: TGDBusConnectionFlags; observer: PGDBusAuthObserver; cancellable: PGCancellable; error: PPGError): PGDBusConnection; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_connection_new_for_address_sync(address, flags, observer, cancellable, error);
end;

function TGDBusConnection.new_sync(stream: PGIOStream; guid: Pgchar; flags: TGDBusConnectionFlags; observer: PGDBusAuthObserver; cancellable: PGCancellable; error: PPGError): PGDBusConnection; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_connection_new_sync(stream, guid, flags, observer, cancellable, error);
end;

procedure TGDBusConnection.new(stream: PGIOStream; guid: Pgchar; flags: TGDBusConnectionFlags; observer: PGDBusAuthObserver; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_dbus_connection_new(stream, guid, flags, observer, cancellable, callback, user_data);
end;

procedure TGDBusConnection.new_for_address(address: Pgchar; flags: TGDBusConnectionFlags; observer: PGDBusAuthObserver; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_dbus_connection_new_for_address(address, flags, observer, cancellable, callback, user_data);
end;

function TGDBusConnection.add_filter(filter_function: TGDBusMessageFilterFunction; user_data: gpointer; user_data_free_func: TGDestroyNotify): guint; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_connection_add_filter(@self, filter_function, user_data, user_data_free_func);
end;

procedure TGDBusConnection.call(bus_name: Pgchar; object_path: Pgchar; interface_name: Pgchar; method_name: Pgchar; parameters: PGVariant; reply_type: PGVariantType; flags: TGDBusCallFlags; timeout_msec: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_dbus_connection_call(@self, bus_name, object_path, interface_name, method_name, parameters, reply_type, flags, timeout_msec, cancellable, callback, user_data);
end;

function TGDBusConnection.call_finish(res: PGAsyncResult; error: PPGError): PGVariant; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_connection_call_finish(@self, res, error);
end;

function TGDBusConnection.call_sync(bus_name: Pgchar; object_path: Pgchar; interface_name: Pgchar; method_name: Pgchar; parameters: PGVariant; reply_type: PGVariantType; flags: TGDBusCallFlags; timeout_msec: gint; cancellable: PGCancellable; error: PPGError): PGVariant; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_connection_call_sync(@self, bus_name, object_path, interface_name, method_name, parameters, reply_type, flags, timeout_msec, cancellable, error);
end;

procedure TGDBusConnection.call_with_unix_fd_list(bus_name: Pgchar; object_path: Pgchar; interface_name: Pgchar; method_name: Pgchar; parameters: PGVariant; reply_type: PGVariantType; flags: TGDBusCallFlags; timeout_msec: gint; fd_list: PGUnixFDList; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_dbus_connection_call_with_unix_fd_list(@self, bus_name, object_path, interface_name, method_name, parameters, reply_type, flags, timeout_msec, fd_list, cancellable, callback, user_data);
end;

function TGDBusConnection.call_with_unix_fd_list_finish(out_fd_list: PPGUnixFDList; res: PGAsyncResult; error: PPGError): PGVariant; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_connection_call_with_unix_fd_list_finish(@self, out_fd_list, res, error);
end;

function TGDBusConnection.call_with_unix_fd_list_sync(bus_name: Pgchar; object_path: Pgchar; interface_name: Pgchar; method_name: Pgchar; parameters: PGVariant; reply_type: PGVariantType; flags: TGDBusCallFlags; timeout_msec: gint; fd_list: PGUnixFDList; out_fd_list: PPGUnixFDList; cancellable: PGCancellable; error: PPGError): PGVariant; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_connection_call_with_unix_fd_list_sync(@self, bus_name, object_path, interface_name, method_name, parameters, reply_type, flags, timeout_msec, fd_list, out_fd_list, cancellable, error);
end;

procedure TGDBusConnection.close(cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_dbus_connection_close(@self, cancellable, callback, user_data);
end;

function TGDBusConnection.close_finish(res: PGAsyncResult; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_connection_close_finish(@self, res, error);
end;

function TGDBusConnection.close_sync(cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_connection_close_sync(@self, cancellable, error);
end;

function TGDBusConnection.emit_signal(destination_bus_name: Pgchar; object_path: Pgchar; interface_name: Pgchar; signal_name: Pgchar; parameters: PGVariant; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_connection_emit_signal(@self, destination_bus_name, object_path, interface_name, signal_name, parameters, error);
end;

function TGDBusConnection.export_action_group(object_path: Pgchar; action_group: PGActionGroup; error: PPGError): guint; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_connection_export_action_group(@self, object_path, action_group, error);
end;

function TGDBusConnection.export_menu_model(object_path: Pgchar; menu: PGMenuModel; error: PPGError): guint; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_connection_export_menu_model(@self, object_path, menu, error);
end;

procedure TGDBusConnection.flush(cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_dbus_connection_flush(@self, cancellable, callback, user_data);
end;

function TGDBusConnection.flush_finish(res: PGAsyncResult; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_connection_flush_finish(@self, res, error);
end;

function TGDBusConnection.flush_sync(cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_connection_flush_sync(@self, cancellable, error);
end;

function TGDBusConnection.get_capabilities: TGDBusCapabilityFlags; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_connection_get_capabilities(@self);
end;

function TGDBusConnection.get_exit_on_close: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_connection_get_exit_on_close(@self);
end;

function TGDBusConnection.get_flags: TGDBusConnectionFlags; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_connection_get_flags(@self);
end;

function TGDBusConnection.get_guid: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_connection_get_guid(@self);
end;

function TGDBusConnection.get_last_serial: guint32; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_connection_get_last_serial(@self);
end;

function TGDBusConnection.get_peer_credentials: PGCredentials; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_connection_get_peer_credentials(@self);
end;

function TGDBusConnection.get_stream: PGIOStream; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_connection_get_stream(@self);
end;

function TGDBusConnection.get_unique_name: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_connection_get_unique_name(@self);
end;

function TGDBusConnection.is_closed: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_connection_is_closed(@self);
end;

function TGDBusConnection.register_object(object_path: Pgchar; interface_info: PGDBusInterfaceInfo; vtable: PGDBusInterfaceVTable; user_data: gpointer; user_data_free_func: TGDestroyNotify; error: PPGError): guint; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_connection_register_object(@self, object_path, interface_info, vtable, user_data, user_data_free_func, error);
end;

function TGDBusConnection.register_object_with_closures(object_path: Pgchar; interface_info: PGDBusInterfaceInfo; method_call_closure: PGClosure; get_property_closure: PGClosure; set_property_closure: PGClosure; error: PPGError): guint; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_connection_register_object_with_closures(@self, object_path, interface_info, method_call_closure, get_property_closure, set_property_closure, error);
end;

function TGDBusConnection.register_subtree(object_path: Pgchar; vtable: PGDBusSubtreeVTable; flags: TGDBusSubtreeFlags; user_data: gpointer; user_data_free_func: TGDestroyNotify; error: PPGError): guint; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_connection_register_subtree(@self, object_path, vtable, flags, user_data, user_data_free_func, error);
end;

procedure TGDBusConnection.remove_filter(filter_id: guint); cdecl;
begin
  CastleInternalGio2.g_dbus_connection_remove_filter(@self, filter_id);
end;

function TGDBusConnection.send_message(message: PGDBusMessage; flags: TGDBusSendMessageFlags; out_serial: Pguint32; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_connection_send_message(@self, message, flags, out_serial, error);
end;

procedure TGDBusConnection.send_message_with_reply(message: PGDBusMessage; flags: TGDBusSendMessageFlags; timeout_msec: gint; out_serial: Pguint32; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_dbus_connection_send_message_with_reply(@self, message, flags, timeout_msec, out_serial, cancellable, callback, user_data);
end;

function TGDBusConnection.send_message_with_reply_finish(res: PGAsyncResult; error: PPGError): PGDBusMessage; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_connection_send_message_with_reply_finish(@self, res, error);
end;

function TGDBusConnection.send_message_with_reply_sync(message: PGDBusMessage; flags: TGDBusSendMessageFlags; timeout_msec: gint; out_serial: Pguint32; cancellable: PGCancellable; error: PPGError): PGDBusMessage; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_connection_send_message_with_reply_sync(@self, message, flags, timeout_msec, out_serial, cancellable, error);
end;

procedure TGDBusConnection.set_exit_on_close(exit_on_close: gboolean); cdecl;
begin
  CastleInternalGio2.g_dbus_connection_set_exit_on_close(@self, exit_on_close);
end;

function TGDBusConnection.signal_subscribe(sender: Pgchar; interface_name: Pgchar; member: Pgchar; object_path: Pgchar; arg0: Pgchar; flags: TGDBusSignalFlags; callback: TGDBusSignalCallback; user_data: gpointer; user_data_free_func: TGDestroyNotify): guint; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_connection_signal_subscribe(@self, sender, interface_name, member, object_path, arg0, flags, callback, user_data, user_data_free_func);
end;

procedure TGDBusConnection.signal_unsubscribe(subscription_id: guint); cdecl;
begin
  CastleInternalGio2.g_dbus_connection_signal_unsubscribe(@self, subscription_id);
end;

procedure TGDBusConnection.start_message_processing; cdecl;
begin
  CastleInternalGio2.g_dbus_connection_start_message_processing(@self);
end;

procedure TGDBusConnection.unexport_action_group(export_id: guint); cdecl;
begin
  CastleInternalGio2.g_dbus_connection_unexport_action_group(@self, export_id);
end;

procedure TGDBusConnection.unexport_menu_model(export_id: guint); cdecl;
begin
  CastleInternalGio2.g_dbus_connection_unexport_menu_model(@self, export_id);
end;

function TGDBusConnection.unregister_object(registration_id: guint): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_connection_unregister_object(@self, registration_id);
end;

function TGDBusConnection.unregister_subtree(registration_id: guint): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_connection_unregister_subtree(@self, registration_id);
end;

function TGFile.new_for_commandline_arg(arg: Pgchar): PGFile; cdecl;
begin
  Result := CastleInternalGio2.g_file_new_for_commandline_arg(arg);
end;

function TGFile.new_for_commandline_arg_and_cwd(arg: Pgchar; cwd: Pgchar): PGFile; cdecl;
begin
  Result := CastleInternalGio2.g_file_new_for_commandline_arg_and_cwd(arg, cwd);
end;

function TGFile.new_for_path(path: Pgchar): PGFile; cdecl;
begin
  Result := CastleInternalGio2.g_file_new_for_path(path);
end;

function TGFile.new_for_uri(uri: Pgchar): PGFile; cdecl;
begin
  Result := CastleInternalGio2.g_file_new_for_uri(uri);
end;

function TGFile.new_tmp(tmpl: Pgchar; iostream: PPGFileIOStream; error: PPGError): PGFile; cdecl;
begin
  Result := CastleInternalGio2.g_file_new_tmp(tmpl, iostream, error);
end;

function TGFile.parse_name(parse_name: Pgchar): PGFile; cdecl;
begin
  Result := CastleInternalGio2.g_file_parse_name(parse_name);
end;

function TGFile.append_to(flags: TGFileCreateFlags; cancellable: PGCancellable; error: PPGError): PGFileOutputStream; cdecl;
begin
  Result := CastleInternalGio2.g_file_append_to(@self, flags, cancellable, error);
end;

procedure TGFile.append_to_async(flags: TGFileCreateFlags; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_file_append_to_async(@self, flags, io_priority, cancellable, callback, user_data);
end;

function TGFile.append_to_finish(res: PGAsyncResult; error: PPGError): PGFileOutputStream; cdecl;
begin
  Result := CastleInternalGio2.g_file_append_to_finish(@self, res, error);
end;

function TGFile.copy(destination: PGFile; flags: TGFileCopyFlags; cancellable: PGCancellable; progress_callback: TGFileProgressCallback; progress_callback_data: gpointer; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_file_copy(@self, destination, flags, cancellable, progress_callback, progress_callback_data, error);
end;

procedure TGFile.copy_async(destination: PGFile; flags: TGFileCopyFlags; io_priority: gint; cancellable: PGCancellable; progress_callback: TGFileProgressCallback; progress_callback_data: gpointer; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_file_copy_async(@self, destination, flags, io_priority, cancellable, progress_callback, progress_callback_data, callback, user_data);
end;

function TGFile.copy_attributes(destination: PGFile; flags: TGFileCopyFlags; cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_file_copy_attributes(@self, destination, flags, cancellable, error);
end;

function TGFile.copy_finish(res: PGAsyncResult; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_file_copy_finish(@self, res, error);
end;

function TGFile.create(flags: TGFileCreateFlags; cancellable: PGCancellable; error: PPGError): PGFileOutputStream; cdecl;
begin
  Result := CastleInternalGio2.g_file_create(@self, flags, cancellable, error);
end;

procedure TGFile.create_async(flags: TGFileCreateFlags; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_file_create_async(@self, flags, io_priority, cancellable, callback, user_data);
end;

function TGFile.create_finish(res: PGAsyncResult; error: PPGError): PGFileOutputStream; cdecl;
begin
  Result := CastleInternalGio2.g_file_create_finish(@self, res, error);
end;

function TGFile.create_readwrite(flags: TGFileCreateFlags; cancellable: PGCancellable; error: PPGError): PGFileIOStream; cdecl;
begin
  Result := CastleInternalGio2.g_file_create_readwrite(@self, flags, cancellable, error);
end;

procedure TGFile.create_readwrite_async(flags: TGFileCreateFlags; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_file_create_readwrite_async(@self, flags, io_priority, cancellable, callback, user_data);
end;

function TGFile.create_readwrite_finish(res: PGAsyncResult; error: PPGError): PGFileIOStream; cdecl;
begin
  Result := CastleInternalGio2.g_file_create_readwrite_finish(@self, res, error);
end;

function TGFile.delete(cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_file_delete(@self, cancellable, error);
end;

procedure TGFile.delete_async(io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_file_delete_async(@self, io_priority, cancellable, callback, user_data);
end;

function TGFile.delete_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_file_delete_finish(@self, result_, error);
end;

function TGFile.dup: PGFile; cdecl;
begin
  Result := CastleInternalGio2.g_file_dup(@self);
end;

procedure TGFile.eject_mountable_with_operation(flags: TGMountUnmountFlags; mount_operation: PGMountOperation; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_file_eject_mountable_with_operation(@self, flags, mount_operation, cancellable, callback, user_data);
end;

function TGFile.eject_mountable_with_operation_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_file_eject_mountable_with_operation_finish(@self, result_, error);
end;

function TGFile.enumerate_children(attributes: Pgchar; flags: TGFileQueryInfoFlags; cancellable: PGCancellable; error: PPGError): PGFileEnumerator; cdecl;
begin
  Result := CastleInternalGio2.g_file_enumerate_children(@self, attributes, flags, cancellable, error);
end;

procedure TGFile.enumerate_children_async(attributes: Pgchar; flags: TGFileQueryInfoFlags; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_file_enumerate_children_async(@self, attributes, flags, io_priority, cancellable, callback, user_data);
end;

function TGFile.enumerate_children_finish(res: PGAsyncResult; error: PPGError): PGFileEnumerator; cdecl;
begin
  Result := CastleInternalGio2.g_file_enumerate_children_finish(@self, res, error);
end;

function TGFile.equal(file2: PGFile): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_file_equal(@self, file2);
end;

function TGFile.find_enclosing_mount(cancellable: PGCancellable; error: PPGError): PGMount; cdecl;
begin
  Result := CastleInternalGio2.g_file_find_enclosing_mount(@self, cancellable, error);
end;

procedure TGFile.find_enclosing_mount_async(io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_file_find_enclosing_mount_async(@self, io_priority, cancellable, callback, user_data);
end;

function TGFile.find_enclosing_mount_finish(res: PGAsyncResult; error: PPGError): PGMount; cdecl;
begin
  Result := CastleInternalGio2.g_file_find_enclosing_mount_finish(@self, res, error);
end;

function TGFile.get_basename: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_file_get_basename(@self);
end;

function TGFile.get_child(name: Pgchar): PGFile; cdecl;
begin
  Result := CastleInternalGio2.g_file_get_child(@self, name);
end;

function TGFile.get_child_for_display_name(display_name: Pgchar; error: PPGError): PGFile; cdecl;
begin
  Result := CastleInternalGio2.g_file_get_child_for_display_name(@self, display_name, error);
end;

function TGFile.get_parent: PGFile; cdecl;
begin
  Result := CastleInternalGio2.g_file_get_parent(@self);
end;

function TGFile.get_parse_name: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_file_get_parse_name(@self);
end;

function TGFile.get_path: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_file_get_path(@self);
end;

function TGFile.get_relative_path(descendant: PGFile): Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_file_get_relative_path(@self, descendant);
end;

function TGFile.get_uri: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_file_get_uri(@self);
end;

function TGFile.get_uri_scheme: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_file_get_uri_scheme(@self);
end;

function TGFile.has_parent(parent: PGFile): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_file_has_parent(@self, parent);
end;

function TGFile.has_prefix(prefix: PGFile): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_file_has_prefix(@self, prefix);
end;

function TGFile.has_uri_scheme(uri_scheme: Pgchar): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_file_has_uri_scheme(@self, uri_scheme);
end;

function TGFile.hash: guint; cdecl;
begin
  Result := CastleInternalGio2.g_file_hash(@self);
end;

function TGFile.is_native: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_file_is_native(@self);
end;

function TGFile.load_bytes(cancellable: PGCancellable; etag_out: PPgchar; error: PPGError): PGBytes; cdecl;
begin
  Result := CastleInternalGio2.g_file_load_bytes(@self, cancellable, etag_out, error);
end;

procedure TGFile.load_bytes_async(cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_file_load_bytes_async(@self, cancellable, callback, user_data);
end;

function TGFile.load_bytes_finish(result_: PGAsyncResult; etag_out: PPgchar; error: PPGError): PGBytes; cdecl;
begin
  Result := CastleInternalGio2.g_file_load_bytes_finish(@self, result_, etag_out, error);
end;

function TGFile.load_contents(cancellable: PGCancellable; contents: PPgchar; length: Pgsize; etag_out: PPgchar; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_file_load_contents(@self, cancellable, contents, length, etag_out, error);
end;

procedure TGFile.load_contents_async(cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_file_load_contents_async(@self, cancellable, callback, user_data);
end;

function TGFile.load_contents_finish(res: PGAsyncResult; contents: PPgchar; length: Pgsize; etag_out: PPgchar; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_file_load_contents_finish(@self, res, contents, length, etag_out, error);
end;

procedure TGFile.load_partial_contents_async(cancellable: PGCancellable; read_more_callback: TGFileReadMoreCallback; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_file_load_partial_contents_async(@self, cancellable, read_more_callback, callback, user_data);
end;

function TGFile.load_partial_contents_finish(res: PGAsyncResult; contents: PPgchar; length: Pgsize; etag_out: PPgchar; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_file_load_partial_contents_finish(@self, res, contents, length, etag_out, error);
end;

function TGFile.make_directory(cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_file_make_directory(@self, cancellable, error);
end;

procedure TGFile.make_directory_async(io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_file_make_directory_async(@self, io_priority, cancellable, callback, user_data);
end;

function TGFile.make_directory_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_file_make_directory_finish(@self, result_, error);
end;

function TGFile.make_directory_with_parents(cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_file_make_directory_with_parents(@self, cancellable, error);
end;

function TGFile.make_symbolic_link(symlink_value: Pgchar; cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_file_make_symbolic_link(@self, symlink_value, cancellable, error);
end;

function TGFile.measure_disk_usage(flags: TGFileMeasureFlags; cancellable: PGCancellable; progress_callback: TGFileMeasureProgressCallback; progress_data: gpointer; disk_usage: Pguint64; num_dirs: Pguint64; num_files: Pguint64; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_file_measure_disk_usage(@self, flags, cancellable, progress_callback, progress_data, disk_usage, num_dirs, num_files, error);
end;

procedure TGFile.measure_disk_usage_async(flags: TGFileMeasureFlags; io_priority: gint; cancellable: PGCancellable; progress_callback: TGFileMeasureProgressCallback; progress_data: gpointer; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_file_measure_disk_usage_async(@self, flags, io_priority, cancellable, progress_callback, progress_data, callback, user_data);
end;

function TGFile.measure_disk_usage_finish(result_: PGAsyncResult; disk_usage: Pguint64; num_dirs: Pguint64; num_files: Pguint64; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_file_measure_disk_usage_finish(@self, result_, disk_usage, num_dirs, num_files, error);
end;

function TGFile.monitor(flags: TGFileMonitorFlags; cancellable: PGCancellable; error: PPGError): PGFileMonitor; cdecl;
begin
  Result := CastleInternalGio2.g_file_monitor(@self, flags, cancellable, error);
end;

function TGFile.monitor_directory(flags: TGFileMonitorFlags; cancellable: PGCancellable; error: PPGError): PGFileMonitor; cdecl;
begin
  Result := CastleInternalGio2.g_file_monitor_directory(@self, flags, cancellable, error);
end;

function TGFile.monitor_file(flags: TGFileMonitorFlags; cancellable: PGCancellable; error: PPGError): PGFileMonitor; cdecl;
begin
  Result := CastleInternalGio2.g_file_monitor_file(@self, flags, cancellable, error);
end;

procedure TGFile.mount_enclosing_volume(flags: TGMountMountFlags; mount_operation: PGMountOperation; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_file_mount_enclosing_volume(@self, flags, mount_operation, cancellable, callback, user_data);
end;

function TGFile.mount_enclosing_volume_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_file_mount_enclosing_volume_finish(@self, result_, error);
end;

procedure TGFile.mount_mountable(flags: TGMountMountFlags; mount_operation: PGMountOperation; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_file_mount_mountable(@self, flags, mount_operation, cancellable, callback, user_data);
end;

function TGFile.mount_mountable_finish(result_: PGAsyncResult; error: PPGError): PGFile; cdecl;
begin
  Result := CastleInternalGio2.g_file_mount_mountable_finish(@self, result_, error);
end;

function TGFile.move(destination: PGFile; flags: TGFileCopyFlags; cancellable: PGCancellable; progress_callback: TGFileProgressCallback; progress_callback_data: gpointer; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_file_move(@self, destination, flags, cancellable, progress_callback, progress_callback_data, error);
end;

function TGFile.open_readwrite(cancellable: PGCancellable; error: PPGError): PGFileIOStream; cdecl;
begin
  Result := CastleInternalGio2.g_file_open_readwrite(@self, cancellable, error);
end;

procedure TGFile.open_readwrite_async(io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_file_open_readwrite_async(@self, io_priority, cancellable, callback, user_data);
end;

function TGFile.open_readwrite_finish(res: PGAsyncResult; error: PPGError): PGFileIOStream; cdecl;
begin
  Result := CastleInternalGio2.g_file_open_readwrite_finish(@self, res, error);
end;

function TGFile.peek_path: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_file_peek_path(@self);
end;

procedure TGFile.poll_mountable(cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_file_poll_mountable(@self, cancellable, callback, user_data);
end;

function TGFile.poll_mountable_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_file_poll_mountable_finish(@self, result_, error);
end;

function TGFile.query_default_handler(cancellable: PGCancellable; error: PPGError): PGAppInfo; cdecl;
begin
  Result := CastleInternalGio2.g_file_query_default_handler(@self, cancellable, error);
end;

procedure TGFile.query_default_handler_async(io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_file_query_default_handler_async(@self, io_priority, cancellable, callback, user_data);
end;

function TGFile.query_default_handler_finish(result_: PGAsyncResult; error: PPGError): PGAppInfo; cdecl;
begin
  Result := CastleInternalGio2.g_file_query_default_handler_finish(@self, result_, error);
end;

function TGFile.query_exists(cancellable: PGCancellable): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_file_query_exists(@self, cancellable);
end;

function TGFile.query_file_type(flags: TGFileQueryInfoFlags; cancellable: PGCancellable): TGFileType; cdecl;
begin
  Result := CastleInternalGio2.g_file_query_file_type(@self, flags, cancellable);
end;

function TGFile.query_filesystem_info(attributes: Pgchar; cancellable: PGCancellable; error: PPGError): PGFileInfo; cdecl;
begin
  Result := CastleInternalGio2.g_file_query_filesystem_info(@self, attributes, cancellable, error);
end;

procedure TGFile.query_filesystem_info_async(attributes: Pgchar; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_file_query_filesystem_info_async(@self, attributes, io_priority, cancellable, callback, user_data);
end;

function TGFile.query_filesystem_info_finish(res: PGAsyncResult; error: PPGError): PGFileInfo; cdecl;
begin
  Result := CastleInternalGio2.g_file_query_filesystem_info_finish(@self, res, error);
end;

function TGFile.query_info(attributes: Pgchar; flags: TGFileQueryInfoFlags; cancellable: PGCancellable; error: PPGError): PGFileInfo; cdecl;
begin
  Result := CastleInternalGio2.g_file_query_info(@self, attributes, flags, cancellable, error);
end;

procedure TGFile.query_info_async(attributes: Pgchar; flags: TGFileQueryInfoFlags; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_file_query_info_async(@self, attributes, flags, io_priority, cancellable, callback, user_data);
end;

function TGFile.query_info_finish(res: PGAsyncResult; error: PPGError): PGFileInfo; cdecl;
begin
  Result := CastleInternalGio2.g_file_query_info_finish(@self, res, error);
end;

function TGFile.query_settable_attributes(cancellable: PGCancellable; error: PPGError): PGFileAttributeInfoList; cdecl;
begin
  Result := CastleInternalGio2.g_file_query_settable_attributes(@self, cancellable, error);
end;

function TGFile.query_writable_namespaces(cancellable: PGCancellable; error: PPGError): PGFileAttributeInfoList; cdecl;
begin
  Result := CastleInternalGio2.g_file_query_writable_namespaces(@self, cancellable, error);
end;

function TGFile.read(cancellable: PGCancellable; error: PPGError): PGFileInputStream; cdecl;
begin
  Result := CastleInternalGio2.g_file_read(@self, cancellable, error);
end;

procedure TGFile.read_async(io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_file_read_async(@self, io_priority, cancellable, callback, user_data);
end;

function TGFile.read_finish(res: PGAsyncResult; error: PPGError): PGFileInputStream; cdecl;
begin
  Result := CastleInternalGio2.g_file_read_finish(@self, res, error);
end;

function TGFile.replace(etag: Pgchar; make_backup: gboolean; flags: TGFileCreateFlags; cancellable: PGCancellable; error: PPGError): PGFileOutputStream; cdecl;
begin
  Result := CastleInternalGio2.g_file_replace(@self, etag, make_backup, flags, cancellable, error);
end;

procedure TGFile.replace_async(etag: Pgchar; make_backup: gboolean; flags: TGFileCreateFlags; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_file_replace_async(@self, etag, make_backup, flags, io_priority, cancellable, callback, user_data);
end;

function TGFile.replace_contents(contents: Pgchar; length: gsize; etag: Pgchar; make_backup: gboolean; flags: TGFileCreateFlags; new_etag: PPgchar; cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_file_replace_contents(@self, contents, length, etag, make_backup, flags, new_etag, cancellable, error);
end;

procedure TGFile.replace_contents_async(contents: Pgchar; length: gsize; etag: Pgchar; make_backup: gboolean; flags: TGFileCreateFlags; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_file_replace_contents_async(@self, contents, length, etag, make_backup, flags, cancellable, callback, user_data);
end;

procedure TGFile.replace_contents_bytes_async(contents: PGBytes; etag: Pgchar; make_backup: gboolean; flags: TGFileCreateFlags; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_file_replace_contents_bytes_async(@self, contents, etag, make_backup, flags, cancellable, callback, user_data);
end;

function TGFile.replace_contents_finish(res: PGAsyncResult; new_etag: PPgchar; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_file_replace_contents_finish(@self, res, new_etag, error);
end;

function TGFile.replace_finish(res: PGAsyncResult; error: PPGError): PGFileOutputStream; cdecl;
begin
  Result := CastleInternalGio2.g_file_replace_finish(@self, res, error);
end;

function TGFile.replace_readwrite(etag: Pgchar; make_backup: gboolean; flags: TGFileCreateFlags; cancellable: PGCancellable; error: PPGError): PGFileIOStream; cdecl;
begin
  Result := CastleInternalGio2.g_file_replace_readwrite(@self, etag, make_backup, flags, cancellable, error);
end;

procedure TGFile.replace_readwrite_async(etag: Pgchar; make_backup: gboolean; flags: TGFileCreateFlags; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_file_replace_readwrite_async(@self, etag, make_backup, flags, io_priority, cancellable, callback, user_data);
end;

function TGFile.replace_readwrite_finish(res: PGAsyncResult; error: PPGError): PGFileIOStream; cdecl;
begin
  Result := CastleInternalGio2.g_file_replace_readwrite_finish(@self, res, error);
end;

function TGFile.resolve_relative_path(relative_path: Pgchar): PGFile; cdecl;
begin
  Result := CastleInternalGio2.g_file_resolve_relative_path(@self, relative_path);
end;

function TGFile.set_attribute(attribute: Pgchar; type_: TGFileAttributeType; value_p: gpointer; flags: TGFileQueryInfoFlags; cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_file_set_attribute(@self, attribute, type_, value_p, flags, cancellable, error);
end;

function TGFile.set_attribute_byte_string(attribute: Pgchar; value: Pgchar; flags: TGFileQueryInfoFlags; cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_file_set_attribute_byte_string(@self, attribute, value, flags, cancellable, error);
end;

function TGFile.set_attribute_int32(attribute: Pgchar; value: gint32; flags: TGFileQueryInfoFlags; cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_file_set_attribute_int32(@self, attribute, value, flags, cancellable, error);
end;

function TGFile.set_attribute_int64(attribute: Pgchar; value: gint64; flags: TGFileQueryInfoFlags; cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_file_set_attribute_int64(@self, attribute, value, flags, cancellable, error);
end;

function TGFile.set_attribute_string(attribute: Pgchar; value: Pgchar; flags: TGFileQueryInfoFlags; cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_file_set_attribute_string(@self, attribute, value, flags, cancellable, error);
end;

function TGFile.set_attribute_uint32(attribute: Pgchar; value: guint32; flags: TGFileQueryInfoFlags; cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_file_set_attribute_uint32(@self, attribute, value, flags, cancellable, error);
end;

function TGFile.set_attribute_uint64(attribute: Pgchar; value: guint64; flags: TGFileQueryInfoFlags; cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_file_set_attribute_uint64(@self, attribute, value, flags, cancellable, error);
end;

procedure TGFile.set_attributes_async(info: PGFileInfo; flags: TGFileQueryInfoFlags; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_file_set_attributes_async(@self, info, flags, io_priority, cancellable, callback, user_data);
end;

function TGFile.set_attributes_finish(result_: PGAsyncResult; info: PPGFileInfo; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_file_set_attributes_finish(@self, result_, info, error);
end;

function TGFile.set_attributes_from_info(info: PGFileInfo; flags: TGFileQueryInfoFlags; cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_file_set_attributes_from_info(@self, info, flags, cancellable, error);
end;

function TGFile.set_display_name(display_name: Pgchar; cancellable: PGCancellable; error: PPGError): PGFile; cdecl;
begin
  Result := CastleInternalGio2.g_file_set_display_name(@self, display_name, cancellable, error);
end;

procedure TGFile.set_display_name_async(display_name: Pgchar; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_file_set_display_name_async(@self, display_name, io_priority, cancellable, callback, user_data);
end;

function TGFile.set_display_name_finish(res: PGAsyncResult; error: PPGError): PGFile; cdecl;
begin
  Result := CastleInternalGio2.g_file_set_display_name_finish(@self, res, error);
end;

procedure TGFile.start_mountable(flags: TGDriveStartFlags; start_operation: PGMountOperation; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_file_start_mountable(@self, flags, start_operation, cancellable, callback, user_data);
end;

function TGFile.start_mountable_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_file_start_mountable_finish(@self, result_, error);
end;

procedure TGFile.stop_mountable(flags: TGMountUnmountFlags; mount_operation: PGMountOperation; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_file_stop_mountable(@self, flags, mount_operation, cancellable, callback, user_data);
end;

function TGFile.stop_mountable_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_file_stop_mountable_finish(@self, result_, error);
end;

function TGFile.supports_thread_contexts: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_file_supports_thread_contexts(@self);
end;

function TGFile.trash(cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_file_trash(@self, cancellable, error);
end;

procedure TGFile.trash_async(io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_file_trash_async(@self, io_priority, cancellable, callback, user_data);
end;

function TGFile.trash_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_file_trash_finish(@self, result_, error);
end;

procedure TGFile.unmount_mountable_with_operation(flags: TGMountUnmountFlags; mount_operation: PGMountOperation; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_file_unmount_mountable_with_operation(@self, flags, mount_operation, cancellable, callback, user_data);
end;

function TGFile.unmount_mountable_with_operation_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_file_unmount_mountable_with_operation_finish(@self, result_, error);
end;

function TGNotification.new(title: Pgchar): PGNotification; cdecl;
begin
  Result := CastleInternalGio2.g_notification_new(title);
end;

procedure TGNotification.add_button(label_: Pgchar; detailed_action: Pgchar); cdecl;
begin
  CastleInternalGio2.g_notification_add_button(@self, label_, detailed_action);
end;

procedure TGNotification.add_button_with_target_value(label_: Pgchar; action: Pgchar; target: PGVariant); cdecl;
begin
  CastleInternalGio2.g_notification_add_button_with_target_value(@self, label_, action, target);
end;

procedure TGNotification.set_body(body: Pgchar); cdecl;
begin
  CastleInternalGio2.g_notification_set_body(@self, body);
end;

procedure TGNotification.set_default_action(detailed_action: Pgchar); cdecl;
begin
  CastleInternalGio2.g_notification_set_default_action(@self, detailed_action);
end;

procedure TGNotification.set_default_action_and_target_value(action: Pgchar; target: PGVariant); cdecl;
begin
  CastleInternalGio2.g_notification_set_default_action_and_target_value(@self, action, target);
end;

procedure TGNotification.set_icon(icon: PGIcon); cdecl;
begin
  CastleInternalGio2.g_notification_set_icon(@self, icon);
end;

procedure TGNotification.set_priority(priority: TGNotificationPriority); cdecl;
begin
  CastleInternalGio2.g_notification_set_priority(@self, priority);
end;

procedure TGNotification.set_title(title: Pgchar); cdecl;
begin
  CastleInternalGio2.g_notification_set_title(@self, title);
end;

procedure TGInputStream.clear_pending; cdecl;
begin
  CastleInternalGio2.g_input_stream_clear_pending(@self);
end;

function TGInputStream.close(cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_input_stream_close(@self, cancellable, error);
end;

procedure TGInputStream.close_async(io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_input_stream_close_async(@self, io_priority, cancellable, callback, user_data);
end;

function TGInputStream.close_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_input_stream_close_finish(@self, result_, error);
end;

function TGInputStream.has_pending: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_input_stream_has_pending(@self);
end;

function TGInputStream.is_closed: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_input_stream_is_closed(@self);
end;

function TGInputStream.read(buffer: Pguint8; count: gsize; cancellable: PGCancellable; error: PPGError): gssize; cdecl;
begin
  Result := CastleInternalGio2.g_input_stream_read(@self, buffer, count, cancellable, error);
end;

function TGInputStream.read_all(buffer: Pguint8; count: gsize; bytes_read: Pgsize; cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_input_stream_read_all(@self, buffer, count, bytes_read, cancellable, error);
end;

procedure TGInputStream.read_all_async(buffer: Pguint8; count: gsize; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_input_stream_read_all_async(@self, buffer, count, io_priority, cancellable, callback, user_data);
end;

function TGInputStream.read_all_finish(result_: PGAsyncResult; bytes_read: Pgsize; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_input_stream_read_all_finish(@self, result_, bytes_read, error);
end;

procedure TGInputStream.read_async(buffer: Pguint8; count: gsize; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_input_stream_read_async(@self, buffer, count, io_priority, cancellable, callback, user_data);
end;

function TGInputStream.read_bytes(count: gsize; cancellable: PGCancellable; error: PPGError): PGBytes; cdecl;
begin
  Result := CastleInternalGio2.g_input_stream_read_bytes(@self, count, cancellable, error);
end;

procedure TGInputStream.read_bytes_async(count: gsize; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_input_stream_read_bytes_async(@self, count, io_priority, cancellable, callback, user_data);
end;

function TGInputStream.read_bytes_finish(result_: PGAsyncResult; error: PPGError): PGBytes; cdecl;
begin
  Result := CastleInternalGio2.g_input_stream_read_bytes_finish(@self, result_, error);
end;

function TGInputStream.read_finish(result_: PGAsyncResult; error: PPGError): gssize; cdecl;
begin
  Result := CastleInternalGio2.g_input_stream_read_finish(@self, result_, error);
end;

function TGInputStream.set_pending(error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_input_stream_set_pending(@self, error);
end;

function TGInputStream.skip(count: gsize; cancellable: PGCancellable; error: PPGError): gssize; cdecl;
begin
  Result := CastleInternalGio2.g_input_stream_skip(@self, count, cancellable, error);
end;

procedure TGInputStream.skip_async(count: gsize; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_input_stream_skip_async(@self, count, io_priority, cancellable, callback, user_data);
end;

function TGInputStream.skip_finish(result_: PGAsyncResult; error: PPGError): gssize; cdecl;
begin
  Result := CastleInternalGio2.g_input_stream_skip_finish(@self, result_, error);
end;

procedure TGAsyncInitable.init_async(io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_async_initable_init_async(@self, io_priority, cancellable, callback, user_data);
end;

function TGAsyncInitable.init_finish(res: PGAsyncResult; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_async_initable_init_finish(@self, res, error);
end;

function TGAsyncInitable.new_finish(res: PGAsyncResult; error: PPGError): PGObject; cdecl;
begin
  Result := CastleInternalGio2.g_async_initable_new_finish(@self, res, error);
end;

function TGSeekable.can_seek: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_seekable_can_seek(@self);
end;

function TGSeekable.can_truncate: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_seekable_can_truncate(@self);
end;

function TGSeekable.seek(offset: gint64; type_: TGSeekType; cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_seekable_seek(@self, offset, type_, cancellable, error);
end;

function TGSeekable.tell: gint64; cdecl;
begin
  Result := CastleInternalGio2.g_seekable_tell(@self);
end;

function TGSeekable.truncate(offset: gint64; cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_seekable_truncate(@self, offset, cancellable, error);
end;

function TGFilterInputStream.get_base_stream: PGInputStream; cdecl;
begin
  Result := CastleInternalGio2.g_filter_input_stream_get_base_stream(@self);
end;

function TGFilterInputStream.get_close_base_stream: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_filter_input_stream_get_close_base_stream(@self);
end;

procedure TGFilterInputStream.set_close_base_stream(close_base: gboolean); cdecl;
begin
  CastleInternalGio2.g_filter_input_stream_set_close_base_stream(@self, close_base);
end;

function TGBufferedInputStream.new(base_stream: PGInputStream): PGBufferedInputStream; cdecl;
begin
  Result := CastleInternalGio2.g_buffered_input_stream_new(base_stream);
end;

function TGBufferedInputStream.new_sized(base_stream: PGInputStream; size: gsize): PGBufferedInputStream; cdecl;
begin
  Result := CastleInternalGio2.g_buffered_input_stream_new_sized(base_stream, size);
end;

function TGBufferedInputStream.fill(count: gssize; cancellable: PGCancellable; error: PPGError): gssize; cdecl;
begin
  Result := CastleInternalGio2.g_buffered_input_stream_fill(@self, count, cancellable, error);
end;

procedure TGBufferedInputStream.fill_async(count: gssize; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_buffered_input_stream_fill_async(@self, count, io_priority, cancellable, callback, user_data);
end;

function TGBufferedInputStream.fill_finish(result_: PGAsyncResult; error: PPGError): gssize; cdecl;
begin
  Result := CastleInternalGio2.g_buffered_input_stream_fill_finish(@self, result_, error);
end;

function TGBufferedInputStream.get_available: gsize; cdecl;
begin
  Result := CastleInternalGio2.g_buffered_input_stream_get_available(@self);
end;

function TGBufferedInputStream.get_buffer_size: gsize; cdecl;
begin
  Result := CastleInternalGio2.g_buffered_input_stream_get_buffer_size(@self);
end;

function TGBufferedInputStream.peek(buffer: Pguint8; offset: gsize; count: gsize): gsize; cdecl;
begin
  Result := CastleInternalGio2.g_buffered_input_stream_peek(@self, buffer, offset, count);
end;

function TGBufferedInputStream.peek_buffer(count: Pgsize): Pguint8; cdecl;
begin
  Result := CastleInternalGio2.g_buffered_input_stream_peek_buffer(@self, count);
end;

function TGBufferedInputStream.read_byte(cancellable: PGCancellable; error: PPGError): gint; cdecl;
begin
  Result := CastleInternalGio2.g_buffered_input_stream_read_byte(@self, cancellable, error);
end;

procedure TGBufferedInputStream.set_buffer_size(size: gsize); cdecl;
begin
  CastleInternalGio2.g_buffered_input_stream_set_buffer_size(@self, size);
end;

procedure TGOutputStream.clear_pending; cdecl;
begin
  CastleInternalGio2.g_output_stream_clear_pending(@self);
end;

function TGOutputStream.close(cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_output_stream_close(@self, cancellable, error);
end;

procedure TGOutputStream.close_async(io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_output_stream_close_async(@self, io_priority, cancellable, callback, user_data);
end;

function TGOutputStream.close_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_output_stream_close_finish(@self, result_, error);
end;

function TGOutputStream.flush(cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_output_stream_flush(@self, cancellable, error);
end;

procedure TGOutputStream.flush_async(io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_output_stream_flush_async(@self, io_priority, cancellable, callback, user_data);
end;

function TGOutputStream.flush_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_output_stream_flush_finish(@self, result_, error);
end;

function TGOutputStream.has_pending: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_output_stream_has_pending(@self);
end;

function TGOutputStream.is_closed: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_output_stream_is_closed(@self);
end;

function TGOutputStream.is_closing: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_output_stream_is_closing(@self);
end;

function TGOutputStream.set_pending(error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_output_stream_set_pending(@self, error);
end;

function TGOutputStream.splice(source: PGInputStream; flags: TGOutputStreamSpliceFlags; cancellable: PGCancellable; error: PPGError): gssize; cdecl;
begin
  Result := CastleInternalGio2.g_output_stream_splice(@self, source, flags, cancellable, error);
end;

procedure TGOutputStream.splice_async(source: PGInputStream; flags: TGOutputStreamSpliceFlags; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_output_stream_splice_async(@self, source, flags, io_priority, cancellable, callback, user_data);
end;

function TGOutputStream.splice_finish(result_: PGAsyncResult; error: PPGError): gssize; cdecl;
begin
  Result := CastleInternalGio2.g_output_stream_splice_finish(@self, result_, error);
end;

function TGOutputStream.write(buffer: Pguint8; count: gsize; cancellable: PGCancellable; error: PPGError): gssize; cdecl;
begin
  Result := CastleInternalGio2.g_output_stream_write(@self, buffer, count, cancellable, error);
end;

function TGOutputStream.write_all(buffer: Pguint8; count: gsize; bytes_written: Pgsize; cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_output_stream_write_all(@self, buffer, count, bytes_written, cancellable, error);
end;

procedure TGOutputStream.write_all_async(buffer: Pguint8; count: gsize; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_output_stream_write_all_async(@self, buffer, count, io_priority, cancellable, callback, user_data);
end;

function TGOutputStream.write_all_finish(result_: PGAsyncResult; bytes_written: Pgsize; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_output_stream_write_all_finish(@self, result_, bytes_written, error);
end;

procedure TGOutputStream.write_async(buffer: Pguint8; count: gsize; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_output_stream_write_async(@self, buffer, count, io_priority, cancellable, callback, user_data);
end;

function TGOutputStream.write_bytes(bytes: PGBytes; cancellable: PGCancellable; error: PPGError): gssize; cdecl;
begin
  Result := CastleInternalGio2.g_output_stream_write_bytes(@self, bytes, cancellable, error);
end;

procedure TGOutputStream.write_bytes_async(bytes: PGBytes; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_output_stream_write_bytes_async(@self, bytes, io_priority, cancellable, callback, user_data);
end;

function TGOutputStream.write_bytes_finish(result_: PGAsyncResult; error: PPGError): gssize; cdecl;
begin
  Result := CastleInternalGio2.g_output_stream_write_bytes_finish(@self, result_, error);
end;

function TGOutputStream.write_finish(result_: PGAsyncResult; error: PPGError): gssize; cdecl;
begin
  Result := CastleInternalGio2.g_output_stream_write_finish(@self, result_, error);
end;

function TGOutputStream.writev(vectors: PGOutputVector; n_vectors: gsize; bytes_written: Pgsize; cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_output_stream_writev(@self, vectors, n_vectors, bytes_written, cancellable, error);
end;

function TGOutputStream.writev_all(vectors: PGOutputVector; n_vectors: gsize; bytes_written: Pgsize; cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_output_stream_writev_all(@self, vectors, n_vectors, bytes_written, cancellable, error);
end;

procedure TGOutputStream.writev_all_async(vectors: PGOutputVector; n_vectors: gsize; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_output_stream_writev_all_async(@self, vectors, n_vectors, io_priority, cancellable, callback, user_data);
end;

function TGOutputStream.writev_all_finish(result_: PGAsyncResult; bytes_written: Pgsize; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_output_stream_writev_all_finish(@self, result_, bytes_written, error);
end;

procedure TGOutputStream.writev_async(vectors: PGOutputVector; n_vectors: gsize; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_output_stream_writev_async(@self, vectors, n_vectors, io_priority, cancellable, callback, user_data);
end;

function TGOutputStream.writev_finish(result_: PGAsyncResult; bytes_written: Pgsize; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_output_stream_writev_finish(@self, result_, bytes_written, error);
end;

function TGFilterOutputStream.get_base_stream: PGOutputStream; cdecl;
begin
  Result := CastleInternalGio2.g_filter_output_stream_get_base_stream(@self);
end;

function TGFilterOutputStream.get_close_base_stream: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_filter_output_stream_get_close_base_stream(@self);
end;

procedure TGFilterOutputStream.set_close_base_stream(close_base: gboolean); cdecl;
begin
  CastleInternalGio2.g_filter_output_stream_set_close_base_stream(@self, close_base);
end;

function TGBufferedOutputStream.new(base_stream: PGOutputStream): PGBufferedOutputStream; cdecl;
begin
  Result := CastleInternalGio2.g_buffered_output_stream_new(base_stream);
end;

function TGBufferedOutputStream.new_sized(base_stream: PGOutputStream; size: gsize): PGBufferedOutputStream; cdecl;
begin
  Result := CastleInternalGio2.g_buffered_output_stream_new_sized(base_stream, size);
end;

function TGBufferedOutputStream.get_auto_grow: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_buffered_output_stream_get_auto_grow(@self);
end;

function TGBufferedOutputStream.get_buffer_size: gsize; cdecl;
begin
  Result := CastleInternalGio2.g_buffered_output_stream_get_buffer_size(@self);
end;

procedure TGBufferedOutputStream.set_auto_grow(auto_grow: gboolean); cdecl;
begin
  CastleInternalGio2.g_buffered_output_stream_set_auto_grow(@self, auto_grow);
end;

procedure TGBufferedOutputStream.set_buffer_size(size: gsize); cdecl;
begin
  CastleInternalGio2.g_buffered_output_stream_set_buffer_size(@self, size);
end;

function TGLoadableIcon.load(size: gint; type_: PPgchar; cancellable: PGCancellable; error: PPGError): PGInputStream; cdecl;
begin
  Result := CastleInternalGio2.g_loadable_icon_load(@self, size, type_, cancellable, error);
end;

procedure TGLoadableIcon.load_async(size: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_loadable_icon_load_async(@self, size, cancellable, callback, user_data);
end;

function TGLoadableIcon.load_finish(res: PGAsyncResult; type_: PPgchar; error: PPGError): PGInputStream; cdecl;
begin
  Result := CastleInternalGio2.g_loadable_icon_load_finish(@self, res, type_, error);
end;

function TGBytesIcon.new(bytes: PGBytes): PGBytesIcon; cdecl;
begin
  Result := CastleInternalGio2.g_bytes_icon_new(bytes);
end;

function TGBytesIcon.get_bytes: PGBytes; cdecl;
begin
  Result := CastleInternalGio2.g_bytes_icon_get_bytes(@self);
end;

function TGConverter.convert(inbuf: Pguint8; inbuf_size: gsize; outbuf: Pguint8; outbuf_size: gsize; flags: TGConverterFlags; bytes_read: Pgsize; bytes_written: Pgsize; error: PPGError): TGConverterResult; cdecl;
begin
  Result := CastleInternalGio2.g_converter_convert(@self, inbuf, inbuf_size, outbuf, outbuf_size, flags, bytes_read, bytes_written, error);
end;

procedure TGConverter.reset; cdecl;
begin
  CastleInternalGio2.g_converter_reset(@self);
end;

function TGInitable.init(cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_initable_init(@self, cancellable, error);
end;

function TGCharsetConverter.new(to_charset: Pgchar; from_charset: Pgchar; error: PPGError): PGCharsetConverter; cdecl;
begin
  Result := CastleInternalGio2.g_charset_converter_new(to_charset, from_charset, error);
end;

function TGCharsetConverter.get_num_fallbacks: guint; cdecl;
begin
  Result := CastleInternalGio2.g_charset_converter_get_num_fallbacks(@self);
end;

function TGCharsetConverter.get_use_fallback: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_charset_converter_get_use_fallback(@self);
end;

procedure TGCharsetConverter.set_use_fallback(use_fallback: gboolean); cdecl;
begin
  CastleInternalGio2.g_charset_converter_set_use_fallback(@self, use_fallback);
end;

function TGPollableInputStream.can_poll: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_pollable_input_stream_can_poll(@self);
end;

function TGPollableInputStream.create_source(cancellable: PGCancellable): PGSource; cdecl;
begin
  Result := CastleInternalGio2.g_pollable_input_stream_create_source(@self, cancellable);
end;

function TGPollableInputStream.is_readable: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_pollable_input_stream_is_readable(@self);
end;

function TGPollableInputStream.read_nonblocking(buffer: Pguint8; count: gsize; cancellable: PGCancellable; error: PPGError): gssize; cdecl;
begin
  Result := CastleInternalGio2.g_pollable_input_stream_read_nonblocking(@self, buffer, count, cancellable, error);
end;

function TGConverterInputStream.new(base_stream: PGInputStream; converter: PGConverter): PGConverterInputStream; cdecl;
begin
  Result := CastleInternalGio2.g_converter_input_stream_new(base_stream, converter);
end;

function TGConverterInputStream.get_converter: PGConverter; cdecl;
begin
  Result := CastleInternalGio2.g_converter_input_stream_get_converter(@self);
end;

function TGPollableOutputStream.can_poll: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_pollable_output_stream_can_poll(@self);
end;

function TGPollableOutputStream.create_source(cancellable: PGCancellable): PGSource; cdecl;
begin
  Result := CastleInternalGio2.g_pollable_output_stream_create_source(@self, cancellable);
end;

function TGPollableOutputStream.is_writable: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_pollable_output_stream_is_writable(@self);
end;

function TGPollableOutputStream.write_nonblocking(buffer: Pguint8; count: gsize; cancellable: PGCancellable; error: PPGError): gssize; cdecl;
begin
  Result := CastleInternalGio2.g_pollable_output_stream_write_nonblocking(@self, buffer, count, cancellable, error);
end;

function TGPollableOutputStream.writev_nonblocking(vectors: PGOutputVector; n_vectors: gsize; bytes_written: Pgsize; cancellable: PGCancellable; error: PPGError): TGPollableReturn; cdecl;
begin
  Result := CastleInternalGio2.g_pollable_output_stream_writev_nonblocking(@self, vectors, n_vectors, bytes_written, cancellable, error);
end;

function TGConverterOutputStream.new(base_stream: PGOutputStream; converter: PGConverter): PGConverterOutputStream; cdecl;
begin
  Result := CastleInternalGio2.g_converter_output_stream_new(base_stream, converter);
end;

function TGConverterOutputStream.get_converter: PGConverter; cdecl;
begin
  Result := CastleInternalGio2.g_converter_output_stream_get_converter(@self);
end;

function TGCredentials.new: PGCredentials; cdecl;
begin
  Result := CastleInternalGio2.g_credentials_new();
end;

function TGCredentials.get_native(native_type: TGCredentialsType): gpointer; cdecl;
begin
  Result := CastleInternalGio2.g_credentials_get_native(@self, native_type);
end;

function TGCredentials.get_unix_pid(error: PPGError): gint; cdecl;
begin
  Result := CastleInternalGio2.g_credentials_get_unix_pid(@self, error);
end;

function TGCredentials.get_unix_user(error: PPGError): guint; cdecl;
begin
  Result := CastleInternalGio2.g_credentials_get_unix_user(@self, error);
end;

function TGCredentials.is_same_user(other_credentials: PGCredentials; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_credentials_is_same_user(@self, other_credentials, error);
end;

procedure TGCredentials.set_native(native_type: TGCredentialsType; native: gpointer); cdecl;
begin
  CastleInternalGio2.g_credentials_set_native(@self, native_type, native);
end;

function TGCredentials.set_unix_user(uid: guint; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_credentials_set_unix_user(@self, uid, error);
end;

function TGCredentials.to_string: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_credentials_to_string(@self);
end;

procedure TGRemoteActionGroup.activate_action_full(action_name: Pgchar; parameter: PGVariant; platform_data: PGVariant); cdecl;
begin
  CastleInternalGio2.g_remote_action_group_activate_action_full(@self, action_name, parameter, platform_data);
end;

procedure TGRemoteActionGroup.change_action_state_full(action_name: Pgchar; value: PGVariant; platform_data: PGVariant); cdecl;
begin
  CastleInternalGio2.g_remote_action_group_change_action_state_full(@self, action_name, value, platform_data);
end;

function TGDBusActionGroup.get(connection: PGDBusConnection; bus_name: Pgchar; object_path: Pgchar): PGDBusActionGroup; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_action_group_get(connection, bus_name, object_path);
end;

function TGDBusAnnotationInfo.ref: PGDBusAnnotationInfo; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_annotation_info_ref(@self);
end;

procedure TGDBusAnnotationInfo.unref; cdecl;
begin
  CastleInternalGio2.g_dbus_annotation_info_unref(@self);
end;

function TGDBusAnnotationInfo.lookup(annotations: PPGDBusAnnotationInfo; name: Pgchar): Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_annotation_info_lookup(annotations, name);
end;

function TGDBusArgInfo.ref: PGDBusArgInfo; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_arg_info_ref(@self);
end;

procedure TGDBusArgInfo.unref; cdecl;
begin
  CastleInternalGio2.g_dbus_arg_info_unref(@self);
end;

function TGDBusAuthObserver.new: PGDBusAuthObserver; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_auth_observer_new();
end;

function TGDBusAuthObserver.allow_mechanism(mechanism: Pgchar): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_auth_observer_allow_mechanism(@self, mechanism);
end;

function TGDBusAuthObserver.authorize_authenticated_peer(stream: PGIOStream; credentials: PGCredentials): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_auth_observer_authorize_authenticated_peer(@self, stream, credentials);
end;

function TGIOStream.splice_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_io_stream_splice_finish(result_, error);
end;

procedure TGIOStream.clear_pending; cdecl;
begin
  CastleInternalGio2.g_io_stream_clear_pending(@self);
end;

function TGIOStream.close(cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_io_stream_close(@self, cancellable, error);
end;

procedure TGIOStream.close_async(io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_io_stream_close_async(@self, io_priority, cancellable, callback, user_data);
end;

function TGIOStream.close_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_io_stream_close_finish(@self, result_, error);
end;

function TGIOStream.get_input_stream: PGInputStream; cdecl;
begin
  Result := CastleInternalGio2.g_io_stream_get_input_stream(@self);
end;

function TGIOStream.get_output_stream: PGOutputStream; cdecl;
begin
  Result := CastleInternalGio2.g_io_stream_get_output_stream(@self);
end;

function TGIOStream.has_pending: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_io_stream_has_pending(@self);
end;

function TGIOStream.is_closed: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_io_stream_is_closed(@self);
end;

function TGIOStream.set_pending(error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_io_stream_set_pending(@self, error);
end;

procedure TGIOStream.splice_async(stream2: PGIOStream; flags: TGIOStreamSpliceFlags; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_io_stream_splice_async(@self, stream2, flags, io_priority, cancellable, callback, user_data);
end;

function TGUnixFDList.new: PGUnixFDList; cdecl;
begin
  Result := CastleInternalGio2.g_unix_fd_list_new();
end;

function TGUnixFDList.new_from_array(fds: Pgint; n_fds: gint): PGUnixFDList; cdecl;
begin
  Result := CastleInternalGio2.g_unix_fd_list_new_from_array(fds, n_fds);
end;

function TGUnixFDList.append(fd: gint; error: PPGError): gint; cdecl;
begin
  Result := CastleInternalGio2.g_unix_fd_list_append(@self, fd, error);
end;

function TGUnixFDList.get(index_: gint; error: PPGError): gint; cdecl;
begin
  Result := CastleInternalGio2.g_unix_fd_list_get(@self, index_, error);
end;

function TGUnixFDList.get_length: gint; cdecl;
begin
  Result := CastleInternalGio2.g_unix_fd_list_get_length(@self);
end;

function TGUnixFDList.peek_fds(length: Pgint): Pgint; cdecl;
begin
  Result := CastleInternalGio2.g_unix_fd_list_peek_fds(@self, length);
end;

function TGUnixFDList.steal_fds(length: Pgint): Pgint; cdecl;
begin
  Result := CastleInternalGio2.g_unix_fd_list_steal_fds(@self, length);
end;

function TGMenuModel.get_item_attribute_value(item_index: gint; attribute: Pgchar; expected_type: PGVariantType): PGVariant; cdecl;
begin
  Result := CastleInternalGio2.g_menu_model_get_item_attribute_value(@self, item_index, attribute, expected_type);
end;

function TGMenuModel.get_item_link(item_index: gint; link: Pgchar): PGMenuModel; cdecl;
begin
  Result := CastleInternalGio2.g_menu_model_get_item_link(@self, item_index, link);
end;

function TGMenuModel.get_n_items: gint; cdecl;
begin
  Result := CastleInternalGio2.g_menu_model_get_n_items(@self);
end;

function TGMenuModel.is_mutable: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_menu_model_is_mutable(@self);
end;

procedure TGMenuModel.items_changed(position: gint; removed: gint; added: gint); cdecl;
begin
  CastleInternalGio2.g_menu_model_items_changed(@self, position, removed, added);
end;

function TGMenuModel.iterate_item_attributes(item_index: gint): PGMenuAttributeIter; cdecl;
begin
  Result := CastleInternalGio2.g_menu_model_iterate_item_attributes(@self, item_index);
end;

function TGMenuModel.iterate_item_links(item_index: gint): PGMenuLinkIter; cdecl;
begin
  Result := CastleInternalGio2.g_menu_model_iterate_item_links(@self, item_index);
end;

procedure TGDBusInterfaceInfo.cache_build; cdecl;
begin
  CastleInternalGio2.g_dbus_interface_info_cache_build(@self);
end;

procedure TGDBusInterfaceInfo.cache_release; cdecl;
begin
  CastleInternalGio2.g_dbus_interface_info_cache_release(@self);
end;

procedure TGDBusInterfaceInfo.generate_xml(indent: guint; string_builder: PGString); cdecl;
begin
  CastleInternalGio2.g_dbus_interface_info_generate_xml(@self, indent, string_builder);
end;

function TGDBusInterfaceInfo.lookup_method(name: Pgchar): PGDBusMethodInfo; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_interface_info_lookup_method(@self, name);
end;

function TGDBusInterfaceInfo.lookup_property(name: Pgchar): PGDBusPropertyInfo; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_interface_info_lookup_property(@self, name);
end;

function TGDBusInterfaceInfo.lookup_signal(name: Pgchar): PGDBusSignalInfo; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_interface_info_lookup_signal(@self, name);
end;

function TGDBusInterfaceInfo.ref: PGDBusInterfaceInfo; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_interface_info_ref(@self);
end;

procedure TGDBusInterfaceInfo.unref; cdecl;
begin
  CastleInternalGio2.g_dbus_interface_info_unref(@self);
end;

function TGDBusMessage.new: PGDBusMessage; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_message_new();
end;

function TGDBusMessage.new_from_blob(blob: Pguint8; blob_len: gsize; capabilities: TGDBusCapabilityFlags; error: PPGError): PGDBusMessage; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_message_new_from_blob(blob, blob_len, capabilities, error);
end;

function TGDBusMessage.new_method_call(name: Pgchar; path: Pgchar; interface_: Pgchar; method: Pgchar): PGDBusMessage; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_message_new_method_call(name, path, interface_, method);
end;

function TGDBusMessage.new_signal(path: Pgchar; interface_: Pgchar; signal: Pgchar): PGDBusMessage; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_message_new_signal(path, interface_, signal);
end;

function TGDBusMessage.bytes_needed(blob: Pguint8; blob_len: gsize; error: PPGError): gssize; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_message_bytes_needed(blob, blob_len, error);
end;

function TGDBusMessage.copy(error: PPGError): PGDBusMessage; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_message_copy(@self, error);
end;

function TGDBusMessage.get_arg0: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_message_get_arg0(@self);
end;

function TGDBusMessage.get_body: PGVariant; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_message_get_body(@self);
end;

function TGDBusMessage.get_byte_order: TGDBusMessageByteOrder; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_message_get_byte_order(@self);
end;

function TGDBusMessage.get_destination: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_message_get_destination(@self);
end;

function TGDBusMessage.get_error_name: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_message_get_error_name(@self);
end;

function TGDBusMessage.get_flags: TGDBusMessageFlags; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_message_get_flags(@self);
end;

function TGDBusMessage.get_header(header_field: TGDBusMessageHeaderField): PGVariant; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_message_get_header(@self, header_field);
end;

function TGDBusMessage.get_header_fields: Pguint8; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_message_get_header_fields(@self);
end;

function TGDBusMessage.get_interface: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_message_get_interface(@self);
end;

function TGDBusMessage.get_locked: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_message_get_locked(@self);
end;

function TGDBusMessage.get_member: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_message_get_member(@self);
end;

function TGDBusMessage.get_message_type: TGDBusMessageType; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_message_get_message_type(@self);
end;

function TGDBusMessage.get_num_unix_fds: guint32; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_message_get_num_unix_fds(@self);
end;

function TGDBusMessage.get_path: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_message_get_path(@self);
end;

function TGDBusMessage.get_reply_serial: guint32; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_message_get_reply_serial(@self);
end;

function TGDBusMessage.get_sender: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_message_get_sender(@self);
end;

function TGDBusMessage.get_serial: guint32; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_message_get_serial(@self);
end;

function TGDBusMessage.get_signature: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_message_get_signature(@self);
end;

function TGDBusMessage.get_unix_fd_list: PGUnixFDList; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_message_get_unix_fd_list(@self);
end;

procedure TGDBusMessage.lock; cdecl;
begin
  CastleInternalGio2.g_dbus_message_lock(@self);
end;

function TGDBusMessage.new_method_error_literal(error_name: Pgchar; error_message: Pgchar): PGDBusMessage; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_message_new_method_error_literal(@self, error_name, error_message);
end;

function TGDBusMessage.new_method_reply: PGDBusMessage; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_message_new_method_reply(@self);
end;

function TGDBusMessage.print(indent: guint): Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_message_print(@self, indent);
end;

procedure TGDBusMessage.set_body(body: PGVariant); cdecl;
begin
  CastleInternalGio2.g_dbus_message_set_body(@self, body);
end;

procedure TGDBusMessage.set_byte_order(byte_order: TGDBusMessageByteOrder); cdecl;
begin
  CastleInternalGio2.g_dbus_message_set_byte_order(@self, byte_order);
end;

procedure TGDBusMessage.set_destination(value: Pgchar); cdecl;
begin
  CastleInternalGio2.g_dbus_message_set_destination(@self, value);
end;

procedure TGDBusMessage.set_error_name(value: Pgchar); cdecl;
begin
  CastleInternalGio2.g_dbus_message_set_error_name(@self, value);
end;

procedure TGDBusMessage.set_flags(flags: TGDBusMessageFlags); cdecl;
begin
  CastleInternalGio2.g_dbus_message_set_flags(@self, flags);
end;

procedure TGDBusMessage.set_header(header_field: TGDBusMessageHeaderField; value: PGVariant); cdecl;
begin
  CastleInternalGio2.g_dbus_message_set_header(@self, header_field, value);
end;

procedure TGDBusMessage.set_interface(value: Pgchar); cdecl;
begin
  CastleInternalGio2.g_dbus_message_set_interface(@self, value);
end;

procedure TGDBusMessage.set_member(value: Pgchar); cdecl;
begin
  CastleInternalGio2.g_dbus_message_set_member(@self, value);
end;

procedure TGDBusMessage.set_message_type(type_: TGDBusMessageType); cdecl;
begin
  CastleInternalGio2.g_dbus_message_set_message_type(@self, type_);
end;

procedure TGDBusMessage.set_num_unix_fds(value: guint32); cdecl;
begin
  CastleInternalGio2.g_dbus_message_set_num_unix_fds(@self, value);
end;

procedure TGDBusMessage.set_path(value: Pgchar); cdecl;
begin
  CastleInternalGio2.g_dbus_message_set_path(@self, value);
end;

procedure TGDBusMessage.set_reply_serial(value: guint32); cdecl;
begin
  CastleInternalGio2.g_dbus_message_set_reply_serial(@self, value);
end;

procedure TGDBusMessage.set_sender(value: Pgchar); cdecl;
begin
  CastleInternalGio2.g_dbus_message_set_sender(@self, value);
end;

procedure TGDBusMessage.set_serial(serial: guint32); cdecl;
begin
  CastleInternalGio2.g_dbus_message_set_serial(@self, serial);
end;

procedure TGDBusMessage.set_signature(value: Pgchar); cdecl;
begin
  CastleInternalGio2.g_dbus_message_set_signature(@self, value);
end;

procedure TGDBusMessage.set_unix_fd_list(fd_list: PGUnixFDList); cdecl;
begin
  CastleInternalGio2.g_dbus_message_set_unix_fd_list(@self, fd_list);
end;

function TGDBusMessage.to_blob(out_size: Pgsize; capabilities: TGDBusCapabilityFlags; error: PPGError): Pguint8; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_message_to_blob(@self, out_size, capabilities, error);
end;

function TGDBusMessage.to_gerror(error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_message_to_gerror(@self, error);
end;

function TGDBusObject.get_interface(interface_name: Pgchar): PGDBusInterface; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_object_get_interface(@self, interface_name);
end;

function TGDBusObject.get_interfaces: PGList; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_object_get_interfaces(@self);
end;

function TGDBusObject.get_object_path: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_object_get_object_path(@self);
end;

function TGDBusInterface.dup_object: PGDBusObject; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_interface_dup_object(@self);
end;

function TGDBusInterface.get_info: PGDBusInterfaceInfo; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_interface_get_info(@self);
end;

function TGDBusInterface.get_object: PGDBusObject; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_interface_get_object(@self);
end;

procedure TGDBusInterface.set_object(object_: PGDBusObject); cdecl;
begin
  CastleInternalGio2.g_dbus_interface_set_object(@self, object_);
end;

function TGDBusMethodInfo.ref: PGDBusMethodInfo; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_method_info_ref(@self);
end;

procedure TGDBusMethodInfo.unref; cdecl;
begin
  CastleInternalGio2.g_dbus_method_info_unref(@self);
end;

function TGDBusSignalInfo.ref: PGDBusSignalInfo; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_signal_info_ref(@self);
end;

procedure TGDBusSignalInfo.unref; cdecl;
begin
  CastleInternalGio2.g_dbus_signal_info_unref(@self);
end;

function TGDBusPropertyInfo.ref: PGDBusPropertyInfo; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_property_info_ref(@self);
end;

procedure TGDBusPropertyInfo.unref; cdecl;
begin
  CastleInternalGio2.g_dbus_property_info_unref(@self);
end;

function TGDBusMethodInvocation.get_connection: PGDBusConnection; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_method_invocation_get_connection(@self);
end;

function TGDBusMethodInvocation.get_interface_name: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_method_invocation_get_interface_name(@self);
end;

function TGDBusMethodInvocation.get_message: PGDBusMessage; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_method_invocation_get_message(@self);
end;

function TGDBusMethodInvocation.get_method_info: PGDBusMethodInfo; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_method_invocation_get_method_info(@self);
end;

function TGDBusMethodInvocation.get_method_name: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_method_invocation_get_method_name(@self);
end;

function TGDBusMethodInvocation.get_object_path: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_method_invocation_get_object_path(@self);
end;

function TGDBusMethodInvocation.get_parameters: PGVariant; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_method_invocation_get_parameters(@self);
end;

function TGDBusMethodInvocation.get_property_info: PGDBusPropertyInfo; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_method_invocation_get_property_info(@self);
end;

function TGDBusMethodInvocation.get_sender: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_method_invocation_get_sender(@self);
end;

function TGDBusMethodInvocation.get_user_data: gpointer; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_method_invocation_get_user_data(@self);
end;

procedure TGDBusMethodInvocation.return_dbus_error(error_name: Pgchar; error_message: Pgchar); cdecl;
begin
  CastleInternalGio2.g_dbus_method_invocation_return_dbus_error(@self, error_name, error_message);
end;

procedure TGDBusMethodInvocation.return_error_literal(domain: TGQuark; code: gint; message: Pgchar); cdecl;
begin
  CastleInternalGio2.g_dbus_method_invocation_return_error_literal(@self, domain, code, message);
end;

procedure TGDBusMethodInvocation.return_gerror(error: PGError); cdecl;
begin
  CastleInternalGio2.g_dbus_method_invocation_return_gerror(@self, error);
end;

procedure TGDBusMethodInvocation.return_value(parameters: PGVariant); cdecl;
begin
  CastleInternalGio2.g_dbus_method_invocation_return_value(@self, parameters);
end;

procedure TGDBusMethodInvocation.return_value_with_unix_fd_list(parameters: PGVariant; fd_list: PGUnixFDList); cdecl;
begin
  CastleInternalGio2.g_dbus_method_invocation_return_value_with_unix_fd_list(@self, parameters, fd_list);
end;

procedure TGDBusMethodInvocation.take_error(error: PGError); cdecl;
begin
  CastleInternalGio2.g_dbus_method_invocation_take_error(@self, error);
end;

function TGDBusInterfaceSkeleton.export(connection: PGDBusConnection; object_path: Pgchar; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_interface_skeleton_export(@self, connection, object_path, error);
end;

procedure TGDBusInterfaceSkeleton.flush; cdecl;
begin
  CastleInternalGio2.g_dbus_interface_skeleton_flush(@self);
end;

function TGDBusInterfaceSkeleton.get_connection: PGDBusConnection; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_interface_skeleton_get_connection(@self);
end;

function TGDBusInterfaceSkeleton.get_connections: PGList; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_interface_skeleton_get_connections(@self);
end;

function TGDBusInterfaceSkeleton.get_flags: TGDBusInterfaceSkeletonFlags; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_interface_skeleton_get_flags(@self);
end;

function TGDBusInterfaceSkeleton.get_info: PGDBusInterfaceInfo; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_interface_skeleton_get_info(@self);
end;

function TGDBusInterfaceSkeleton.get_object_path: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_interface_skeleton_get_object_path(@self);
end;

function TGDBusInterfaceSkeleton.get_properties: PGVariant; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_interface_skeleton_get_properties(@self);
end;

function TGDBusInterfaceSkeleton.get_vtable: PGDBusInterfaceVTable; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_interface_skeleton_get_vtable(@self);
end;

function TGDBusInterfaceSkeleton.has_connection(connection: PGDBusConnection): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_interface_skeleton_has_connection(@self, connection);
end;

procedure TGDBusInterfaceSkeleton.set_flags(flags: TGDBusInterfaceSkeletonFlags); cdecl;
begin
  CastleInternalGio2.g_dbus_interface_skeleton_set_flags(@self, flags);
end;

procedure TGDBusInterfaceSkeleton.unexport; cdecl;
begin
  CastleInternalGio2.g_dbus_interface_skeleton_unexport(@self);
end;

procedure TGDBusInterfaceSkeleton.unexport_from_connection(connection: PGDBusConnection); cdecl;
begin
  CastleInternalGio2.g_dbus_interface_skeleton_unexport_from_connection(@self, connection);
end;

function TGDBusMenuModel.get(connection: PGDBusConnection; bus_name: Pgchar; object_path: Pgchar): PGDBusMenuModel; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_menu_model_get(connection, bus_name, object_path);
end;

function TGDBusNodeInfo.new_for_xml(xml_data: Pgchar; error: PPGError): PGDBusNodeInfo; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_node_info_new_for_xml(xml_data, error);
end;

procedure TGDBusNodeInfo.generate_xml(indent: guint; string_builder: PGString); cdecl;
begin
  CastleInternalGio2.g_dbus_node_info_generate_xml(@self, indent, string_builder);
end;

function TGDBusNodeInfo.lookup_interface(name: Pgchar): PGDBusInterfaceInfo; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_node_info_lookup_interface(@self, name);
end;

function TGDBusNodeInfo.ref: PGDBusNodeInfo; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_node_info_ref(@self);
end;

procedure TGDBusNodeInfo.unref; cdecl;
begin
  CastleInternalGio2.g_dbus_node_info_unref(@self);
end;

function TGDBusObjectManager.get_interface(object_path: Pgchar; interface_name: Pgchar): PGDBusInterface; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_object_manager_get_interface(@self, object_path, interface_name);
end;

function TGDBusObjectManager.get_object(object_path: Pgchar): PGDBusObject; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_object_manager_get_object(@self, object_path);
end;

function TGDBusObjectManager.get_object_path: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_object_manager_get_object_path(@self);
end;

function TGDBusObjectManager.get_objects: PGList; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_object_manager_get_objects(@self);
end;

function TGDBusObjectManagerClient.new_finish(res: PGAsyncResult; error: PPGError): PGDBusObjectManagerClient; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_object_manager_client_new_finish(res, error);
end;

function TGDBusObjectManagerClient.new_for_bus_finish(res: PGAsyncResult; error: PPGError): PGDBusObjectManagerClient; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_object_manager_client_new_for_bus_finish(res, error);
end;

function TGDBusObjectManagerClient.new_for_bus_sync(bus_type: TGBusType; flags: TGDBusObjectManagerClientFlags; name: Pgchar; object_path: Pgchar; get_proxy_type_func: TGDBusProxyTypeFunc; get_proxy_type_user_data: gpointer; get_proxy_type_destroy_notify: TGDestroyNotify; cancellable: PGCancellable; error: PPGError): PGDBusObjectManagerClient; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_object_manager_client_new_for_bus_sync(bus_type, flags, name, object_path, get_proxy_type_func, get_proxy_type_user_data, get_proxy_type_destroy_notify, cancellable, error);
end;

function TGDBusObjectManagerClient.new_sync(connection: PGDBusConnection; flags: TGDBusObjectManagerClientFlags; name: Pgchar; object_path: Pgchar; get_proxy_type_func: TGDBusProxyTypeFunc; get_proxy_type_user_data: gpointer; get_proxy_type_destroy_notify: TGDestroyNotify; cancellable: PGCancellable; error: PPGError): PGDBusObjectManagerClient; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_object_manager_client_new_sync(connection, flags, name, object_path, get_proxy_type_func, get_proxy_type_user_data, get_proxy_type_destroy_notify, cancellable, error);
end;

procedure TGDBusObjectManagerClient.new(connection: PGDBusConnection; flags: TGDBusObjectManagerClientFlags; name: Pgchar; object_path: Pgchar; get_proxy_type_func: TGDBusProxyTypeFunc; get_proxy_type_user_data: gpointer; get_proxy_type_destroy_notify: TGDestroyNotify; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_dbus_object_manager_client_new(connection, flags, name, object_path, get_proxy_type_func, get_proxy_type_user_data, get_proxy_type_destroy_notify, cancellable, callback, user_data);
end;

procedure TGDBusObjectManagerClient.new_for_bus(bus_type: TGBusType; flags: TGDBusObjectManagerClientFlags; name: Pgchar; object_path: Pgchar; get_proxy_type_func: TGDBusProxyTypeFunc; get_proxy_type_user_data: gpointer; get_proxy_type_destroy_notify: TGDestroyNotify; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_dbus_object_manager_client_new_for_bus(bus_type, flags, name, object_path, get_proxy_type_func, get_proxy_type_user_data, get_proxy_type_destroy_notify, cancellable, callback, user_data);
end;

function TGDBusObjectManagerClient.get_connection: PGDBusConnection; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_object_manager_client_get_connection(@self);
end;

function TGDBusObjectManagerClient.get_flags: TGDBusObjectManagerClientFlags; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_object_manager_client_get_flags(@self);
end;

function TGDBusObjectManagerClient.get_name: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_object_manager_client_get_name(@self);
end;

function TGDBusObjectManagerClient.get_name_owner: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_object_manager_client_get_name_owner(@self);
end;

function TGDBusObjectProxy.new(connection: PGDBusConnection; object_path: Pgchar): PGDBusObjectProxy; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_object_proxy_new(connection, object_path);
end;

function TGDBusObjectProxy.get_connection: PGDBusConnection; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_object_proxy_get_connection(@self);
end;

function TGDBusProxy.new_finish(res: PGAsyncResult; error: PPGError): PGDBusProxy; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_proxy_new_finish(res, error);
end;

function TGDBusProxy.new_for_bus_finish(res: PGAsyncResult; error: PPGError): PGDBusProxy; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_proxy_new_for_bus_finish(res, error);
end;

function TGDBusProxy.new_for_bus_sync(bus_type: TGBusType; flags: TGDBusProxyFlags; info: PGDBusInterfaceInfo; name: Pgchar; object_path: Pgchar; interface_name: Pgchar; cancellable: PGCancellable; error: PPGError): PGDBusProxy; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_proxy_new_for_bus_sync(bus_type, flags, info, name, object_path, interface_name, cancellable, error);
end;

function TGDBusProxy.new_sync(connection: PGDBusConnection; flags: TGDBusProxyFlags; info: PGDBusInterfaceInfo; name: Pgchar; object_path: Pgchar; interface_name: Pgchar; cancellable: PGCancellable; error: PPGError): PGDBusProxy; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_proxy_new_sync(connection, flags, info, name, object_path, interface_name, cancellable, error);
end;

procedure TGDBusProxy.new(connection: PGDBusConnection; flags: TGDBusProxyFlags; info: PGDBusInterfaceInfo; name: Pgchar; object_path: Pgchar; interface_name: Pgchar; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_dbus_proxy_new(connection, flags, info, name, object_path, interface_name, cancellable, callback, user_data);
end;

procedure TGDBusProxy.new_for_bus(bus_type: TGBusType; flags: TGDBusProxyFlags; info: PGDBusInterfaceInfo; name: Pgchar; object_path: Pgchar; interface_name: Pgchar; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_dbus_proxy_new_for_bus(bus_type, flags, info, name, object_path, interface_name, cancellable, callback, user_data);
end;

procedure TGDBusProxy.call(method_name: Pgchar; parameters: PGVariant; flags: TGDBusCallFlags; timeout_msec: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_dbus_proxy_call(@self, method_name, parameters, flags, timeout_msec, cancellable, callback, user_data);
end;

function TGDBusProxy.call_finish(res: PGAsyncResult; error: PPGError): PGVariant; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_proxy_call_finish(@self, res, error);
end;

function TGDBusProxy.call_sync(method_name: Pgchar; parameters: PGVariant; flags: TGDBusCallFlags; timeout_msec: gint; cancellable: PGCancellable; error: PPGError): PGVariant; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_proxy_call_sync(@self, method_name, parameters, flags, timeout_msec, cancellable, error);
end;

procedure TGDBusProxy.call_with_unix_fd_list(method_name: Pgchar; parameters: PGVariant; flags: TGDBusCallFlags; timeout_msec: gint; fd_list: PGUnixFDList; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_dbus_proxy_call_with_unix_fd_list(@self, method_name, parameters, flags, timeout_msec, fd_list, cancellable, callback, user_data);
end;

function TGDBusProxy.call_with_unix_fd_list_finish(out_fd_list: PPGUnixFDList; res: PGAsyncResult; error: PPGError): PGVariant; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_proxy_call_with_unix_fd_list_finish(@self, out_fd_list, res, error);
end;

function TGDBusProxy.call_with_unix_fd_list_sync(method_name: Pgchar; parameters: PGVariant; flags: TGDBusCallFlags; timeout_msec: gint; fd_list: PGUnixFDList; out_fd_list: PPGUnixFDList; cancellable: PGCancellable; error: PPGError): PGVariant; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_proxy_call_with_unix_fd_list_sync(@self, method_name, parameters, flags, timeout_msec, fd_list, out_fd_list, cancellable, error);
end;

function TGDBusProxy.get_cached_property(property_name: Pgchar): PGVariant; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_proxy_get_cached_property(@self, property_name);
end;

function TGDBusProxy.get_cached_property_names: PPgchar; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_proxy_get_cached_property_names(@self);
end;

function TGDBusProxy.get_connection: PGDBusConnection; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_proxy_get_connection(@self);
end;

function TGDBusProxy.get_default_timeout: gint; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_proxy_get_default_timeout(@self);
end;

function TGDBusProxy.get_flags: TGDBusProxyFlags; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_proxy_get_flags(@self);
end;

function TGDBusProxy.get_interface_info: PGDBusInterfaceInfo; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_proxy_get_interface_info(@self);
end;

function TGDBusProxy.get_interface_name: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_proxy_get_interface_name(@self);
end;

function TGDBusProxy.get_name: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_proxy_get_name(@self);
end;

function TGDBusProxy.get_name_owner: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_proxy_get_name_owner(@self);
end;

function TGDBusProxy.get_object_path: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_proxy_get_object_path(@self);
end;

procedure TGDBusProxy.set_cached_property(property_name: Pgchar; value: PGVariant); cdecl;
begin
  CastleInternalGio2.g_dbus_proxy_set_cached_property(@self, property_name, value);
end;

procedure TGDBusProxy.set_default_timeout(timeout_msec: gint); cdecl;
begin
  CastleInternalGio2.g_dbus_proxy_set_default_timeout(@self, timeout_msec);
end;

procedure TGDBusProxy.set_interface_info(info: PGDBusInterfaceInfo); cdecl;
begin
  CastleInternalGio2.g_dbus_proxy_set_interface_info(@self, info);
end;

function TGDBusObjectManagerServer.new(object_path: Pgchar): PGDBusObjectManagerServer; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_object_manager_server_new(object_path);
end;

procedure TGDBusObjectManagerServer.export(object_: PGDBusObjectSkeleton); cdecl;
begin
  CastleInternalGio2.g_dbus_object_manager_server_export(@self, object_);
end;

procedure TGDBusObjectManagerServer.export_uniquely(object_: PGDBusObjectSkeleton); cdecl;
begin
  CastleInternalGio2.g_dbus_object_manager_server_export_uniquely(@self, object_);
end;

function TGDBusObjectManagerServer.get_connection: PGDBusConnection; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_object_manager_server_get_connection(@self);
end;

function TGDBusObjectManagerServer.is_exported(object_: PGDBusObjectSkeleton): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_object_manager_server_is_exported(@self, object_);
end;

procedure TGDBusObjectManagerServer.set_connection(connection: PGDBusConnection); cdecl;
begin
  CastleInternalGio2.g_dbus_object_manager_server_set_connection(@self, connection);
end;

function TGDBusObjectManagerServer.unexport(object_path: Pgchar): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_object_manager_server_unexport(@self, object_path);
end;

function TGDBusObjectSkeleton.new(object_path: Pgchar): PGDBusObjectSkeleton; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_object_skeleton_new(object_path);
end;

procedure TGDBusObjectSkeleton.add_interface(interface_: PGDBusInterfaceSkeleton); cdecl;
begin
  CastleInternalGio2.g_dbus_object_skeleton_add_interface(@self, interface_);
end;

procedure TGDBusObjectSkeleton.flush; cdecl;
begin
  CastleInternalGio2.g_dbus_object_skeleton_flush(@self);
end;

procedure TGDBusObjectSkeleton.remove_interface(interface_: PGDBusInterfaceSkeleton); cdecl;
begin
  CastleInternalGio2.g_dbus_object_skeleton_remove_interface(@self, interface_);
end;

procedure TGDBusObjectSkeleton.remove_interface_by_name(interface_name: Pgchar); cdecl;
begin
  CastleInternalGio2.g_dbus_object_skeleton_remove_interface_by_name(@self, interface_name);
end;

procedure TGDBusObjectSkeleton.set_object_path(object_path: Pgchar); cdecl;
begin
  CastleInternalGio2.g_dbus_object_skeleton_set_object_path(@self, object_path);
end;

function TGDBusServer.new_sync(address: Pgchar; flags: TGDBusServerFlags; guid: Pgchar; observer: PGDBusAuthObserver; cancellable: PGCancellable; error: PPGError): PGDBusServer; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_server_new_sync(address, flags, guid, observer, cancellable, error);
end;

function TGDBusServer.get_client_address: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_server_get_client_address(@self);
end;

function TGDBusServer.get_flags: TGDBusServerFlags; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_server_get_flags(@self);
end;

function TGDBusServer.get_guid: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_server_get_guid(@self);
end;

function TGDBusServer.is_active: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_dbus_server_is_active(@self);
end;

procedure TGDBusServer.start; cdecl;
begin
  CastleInternalGio2.g_dbus_server_start(@self);
end;

procedure TGDBusServer.stop; cdecl;
begin
  CastleInternalGio2.g_dbus_server_stop(@self);
end;

function TGDataInputStream.new(base_stream: PGInputStream): PGDataInputStream; cdecl;
begin
  Result := CastleInternalGio2.g_data_input_stream_new(base_stream);
end;

function TGDataInputStream.get_byte_order: TGDataStreamByteOrder; cdecl;
begin
  Result := CastleInternalGio2.g_data_input_stream_get_byte_order(@self);
end;

function TGDataInputStream.get_newline_type: TGDataStreamNewlineType; cdecl;
begin
  Result := CastleInternalGio2.g_data_input_stream_get_newline_type(@self);
end;

function TGDataInputStream.read_byte(cancellable: PGCancellable; error: PPGError): guint8; cdecl;
begin
  Result := CastleInternalGio2.g_data_input_stream_read_byte(@self, cancellable, error);
end;

function TGDataInputStream.read_int16(cancellable: PGCancellable; error: PPGError): gint16; cdecl;
begin
  Result := CastleInternalGio2.g_data_input_stream_read_int16(@self, cancellable, error);
end;

function TGDataInputStream.read_int32(cancellable: PGCancellable; error: PPGError): gint32; cdecl;
begin
  Result := CastleInternalGio2.g_data_input_stream_read_int32(@self, cancellable, error);
end;

function TGDataInputStream.read_int64(cancellable: PGCancellable; error: PPGError): gint64; cdecl;
begin
  Result := CastleInternalGio2.g_data_input_stream_read_int64(@self, cancellable, error);
end;

function TGDataInputStream.read_line(length: Pgsize; cancellable: PGCancellable; error: PPGError): Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_data_input_stream_read_line(@self, length, cancellable, error);
end;

procedure TGDataInputStream.read_line_async(io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_data_input_stream_read_line_async(@self, io_priority, cancellable, callback, user_data);
end;

function TGDataInputStream.read_line_finish(result_: PGAsyncResult; length: Pgsize; error: PPGError): Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_data_input_stream_read_line_finish(@self, result_, length, error);
end;

function TGDataInputStream.read_line_finish_utf8(result_: PGAsyncResult; length: Pgsize; error: PPGError): Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_data_input_stream_read_line_finish_utf8(@self, result_, length, error);
end;

function TGDataInputStream.read_line_utf8(length: Pgsize; cancellable: PGCancellable; error: PPGError): Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_data_input_stream_read_line_utf8(@self, length, cancellable, error);
end;

function TGDataInputStream.read_uint16(cancellable: PGCancellable; error: PPGError): guint16; cdecl;
begin
  Result := CastleInternalGio2.g_data_input_stream_read_uint16(@self, cancellable, error);
end;

function TGDataInputStream.read_uint32(cancellable: PGCancellable; error: PPGError): guint32; cdecl;
begin
  Result := CastleInternalGio2.g_data_input_stream_read_uint32(@self, cancellable, error);
end;

function TGDataInputStream.read_uint64(cancellable: PGCancellable; error: PPGError): guint64; cdecl;
begin
  Result := CastleInternalGio2.g_data_input_stream_read_uint64(@self, cancellable, error);
end;

function TGDataInputStream.read_upto(stop_chars: Pgchar; stop_chars_len: gssize; length: Pgsize; cancellable: PGCancellable; error: PPGError): Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_data_input_stream_read_upto(@self, stop_chars, stop_chars_len, length, cancellable, error);
end;

procedure TGDataInputStream.read_upto_async(stop_chars: Pgchar; stop_chars_len: gssize; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_data_input_stream_read_upto_async(@self, stop_chars, stop_chars_len, io_priority, cancellable, callback, user_data);
end;

function TGDataInputStream.read_upto_finish(result_: PGAsyncResult; length: Pgsize; error: PPGError): Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_data_input_stream_read_upto_finish(@self, result_, length, error);
end;

procedure TGDataInputStream.set_byte_order(order: TGDataStreamByteOrder); cdecl;
begin
  CastleInternalGio2.g_data_input_stream_set_byte_order(@self, order);
end;

procedure TGDataInputStream.set_newline_type(type_: TGDataStreamNewlineType); cdecl;
begin
  CastleInternalGio2.g_data_input_stream_set_newline_type(@self, type_);
end;

function TGDataOutputStream.new(base_stream: PGOutputStream): PGDataOutputStream; cdecl;
begin
  Result := CastleInternalGio2.g_data_output_stream_new(base_stream);
end;

function TGDataOutputStream.get_byte_order: TGDataStreamByteOrder; cdecl;
begin
  Result := CastleInternalGio2.g_data_output_stream_get_byte_order(@self);
end;

function TGDataOutputStream.put_byte(data: guint8; cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_data_output_stream_put_byte(@self, data, cancellable, error);
end;

function TGDataOutputStream.put_int16(data: gint16; cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_data_output_stream_put_int16(@self, data, cancellable, error);
end;

function TGDataOutputStream.put_int32(data: gint32; cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_data_output_stream_put_int32(@self, data, cancellable, error);
end;

function TGDataOutputStream.put_int64(data: gint64; cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_data_output_stream_put_int64(@self, data, cancellable, error);
end;

function TGDataOutputStream.put_string(str: Pgchar; cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_data_output_stream_put_string(@self, str, cancellable, error);
end;

function TGDataOutputStream.put_uint16(data: guint16; cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_data_output_stream_put_uint16(@self, data, cancellable, error);
end;

function TGDataOutputStream.put_uint32(data: guint32; cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_data_output_stream_put_uint32(@self, data, cancellable, error);
end;

function TGDataOutputStream.put_uint64(data: guint64; cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_data_output_stream_put_uint64(@self, data, cancellable, error);
end;

procedure TGDataOutputStream.set_byte_order(order: TGDataStreamByteOrder); cdecl;
begin
  CastleInternalGio2.g_data_output_stream_set_byte_order(@self, order);
end;

function TGDatagramBased.condition_check(condition: TGIOCondition): TGIOCondition; cdecl;
begin
  Result := CastleInternalGio2.g_datagram_based_condition_check(@self, condition);
end;

function TGDatagramBased.condition_wait(condition: TGIOCondition; timeout: gint64; cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_datagram_based_condition_wait(@self, condition, timeout, cancellable, error);
end;

function TGDatagramBased.create_source(condition: TGIOCondition; cancellable: PGCancellable): PGSource; cdecl;
begin
  Result := CastleInternalGio2.g_datagram_based_create_source(@self, condition, cancellable);
end;

function TGDatagramBased.receive_messages(messages: PGInputMessage; num_messages: guint; flags: gint; timeout: gint64; cancellable: PGCancellable; error: PPGError): gint; cdecl;
begin
  Result := CastleInternalGio2.g_datagram_based_receive_messages(@self, messages, num_messages, flags, timeout, cancellable, error);
end;

function TGDatagramBased.send_messages(messages: PGOutputMessage; num_messages: guint; flags: gint; timeout: gint64; cancellable: PGCancellable; error: PPGError): gint; cdecl;
begin
  Result := CastleInternalGio2.g_datagram_based_send_messages(@self, messages, num_messages, flags, timeout, cancellable, error);
end;

function TGDesktopAppInfo.new(desktop_id: Pgchar): PGDesktopAppInfo; cdecl;
begin
  Result := CastleInternalGio2.g_desktop_app_info_new(desktop_id);
end;

function TGDesktopAppInfo.new_from_filename(filename: Pgchar): PGDesktopAppInfo; cdecl;
begin
  Result := CastleInternalGio2.g_desktop_app_info_new_from_filename(filename);
end;

function TGDesktopAppInfo.new_from_keyfile(key_file: PGKeyFile): PGDesktopAppInfo; cdecl;
begin
  Result := CastleInternalGio2.g_desktop_app_info_new_from_keyfile(key_file);
end;

function TGDesktopAppInfo.get_implementations(interface_: Pgchar): PGList; cdecl;
begin
  Result := CastleInternalGio2.g_desktop_app_info_get_implementations(interface_);
end;

function TGDesktopAppInfo.search(search_string: Pgchar): PPPgchar; cdecl;
begin
  Result := CastleInternalGio2.g_desktop_app_info_search(search_string);
end;

function TGDesktopAppInfo.get_action_name(action_name: Pgchar): Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_desktop_app_info_get_action_name(@self, action_name);
end;

function TGDesktopAppInfo.get_boolean(key: Pgchar): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_desktop_app_info_get_boolean(@self, key);
end;

function TGDesktopAppInfo.get_categories: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_desktop_app_info_get_categories(@self);
end;

function TGDesktopAppInfo.get_filename: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_desktop_app_info_get_filename(@self);
end;

function TGDesktopAppInfo.get_generic_name: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_desktop_app_info_get_generic_name(@self);
end;

function TGDesktopAppInfo.get_is_hidden: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_desktop_app_info_get_is_hidden(@self);
end;

function TGDesktopAppInfo.get_keywords: PPgchar; cdecl;
begin
  Result := CastleInternalGio2.g_desktop_app_info_get_keywords(@self);
end;

function TGDesktopAppInfo.get_locale_string(key: Pgchar): Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_desktop_app_info_get_locale_string(@self, key);
end;

function TGDesktopAppInfo.get_nodisplay: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_desktop_app_info_get_nodisplay(@self);
end;

function TGDesktopAppInfo.get_show_in(desktop_env: Pgchar): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_desktop_app_info_get_show_in(@self, desktop_env);
end;

function TGDesktopAppInfo.get_startup_wm_class: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_desktop_app_info_get_startup_wm_class(@self);
end;

function TGDesktopAppInfo.get_string(key: Pgchar): Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_desktop_app_info_get_string(@self, key);
end;

function TGDesktopAppInfo.get_string_list(key: Pgchar; length: Pgsize): PPgchar; cdecl;
begin
  Result := CastleInternalGio2.g_desktop_app_info_get_string_list(@self, key, length);
end;

function TGDesktopAppInfo.has_key(key: Pgchar): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_desktop_app_info_has_key(@self, key);
end;

procedure TGDesktopAppInfo.launch_action(action_name: Pgchar; launch_context: PGAppLaunchContext); cdecl;
begin
  CastleInternalGio2.g_desktop_app_info_launch_action(@self, action_name, launch_context);
end;

function TGDesktopAppInfo.launch_uris_as_manager(uris: PGList; launch_context: PGAppLaunchContext; spawn_flags: TGSpawnFlags; user_setup: TGSpawnChildSetupFunc; user_setup_data: gpointer; pid_callback: TGDesktopAppLaunchCallback; pid_callback_data: gpointer; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_desktop_app_info_launch_uris_as_manager(@self, uris, launch_context, spawn_flags, user_setup, user_setup_data, pid_callback, pid_callback_data, error);
end;

function TGDesktopAppInfo.launch_uris_as_manager_with_fds(uris: PGList; launch_context: PGAppLaunchContext; spawn_flags: TGSpawnFlags; user_setup: TGSpawnChildSetupFunc; user_setup_data: gpointer; pid_callback: TGDesktopAppLaunchCallback; pid_callback_data: gpointer; stdin_fd: gint; stdout_fd: gint; stderr_fd: gint; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_desktop_app_info_launch_uris_as_manager_with_fds(@self, uris, launch_context, spawn_flags, user_setup, user_setup_data, pid_callback, pid_callback_data, stdin_fd, stdout_fd, stderr_fd, error);
end;

function TGDesktopAppInfo.list_actions: PPgchar; cdecl;
begin
  Result := CastleInternalGio2.g_desktop_app_info_list_actions(@self);
end;

function TGDrive.can_eject: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_drive_can_eject(@self);
end;

function TGDrive.can_poll_for_media: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_drive_can_poll_for_media(@self);
end;

function TGDrive.can_start: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_drive_can_start(@self);
end;

function TGDrive.can_start_degraded: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_drive_can_start_degraded(@self);
end;

function TGDrive.can_stop: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_drive_can_stop(@self);
end;

procedure TGDrive.eject_with_operation(flags: TGMountUnmountFlags; mount_operation: PGMountOperation; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_drive_eject_with_operation(@self, flags, mount_operation, cancellable, callback, user_data);
end;

function TGDrive.eject_with_operation_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_drive_eject_with_operation_finish(@self, result_, error);
end;

function TGDrive.enumerate_identifiers: PPgchar; cdecl;
begin
  Result := CastleInternalGio2.g_drive_enumerate_identifiers(@self);
end;

function TGDrive.get_icon: PGIcon; cdecl;
begin
  Result := CastleInternalGio2.g_drive_get_icon(@self);
end;

function TGDrive.get_identifier(kind: Pgchar): Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_drive_get_identifier(@self, kind);
end;

function TGDrive.get_name: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_drive_get_name(@self);
end;

function TGDrive.get_sort_key: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_drive_get_sort_key(@self);
end;

function TGDrive.get_start_stop_type: TGDriveStartStopType; cdecl;
begin
  Result := CastleInternalGio2.g_drive_get_start_stop_type(@self);
end;

function TGDrive.get_symbolic_icon: PGIcon; cdecl;
begin
  Result := CastleInternalGio2.g_drive_get_symbolic_icon(@self);
end;

function TGDrive.get_volumes: PGList; cdecl;
begin
  Result := CastleInternalGio2.g_drive_get_volumes(@self);
end;

function TGDrive.has_media: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_drive_has_media(@self);
end;

function TGDrive.has_volumes: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_drive_has_volumes(@self);
end;

function TGDrive.is_media_check_automatic: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_drive_is_media_check_automatic(@self);
end;

function TGDrive.is_media_removable: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_drive_is_media_removable(@self);
end;

function TGDrive.is_removable: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_drive_is_removable(@self);
end;

procedure TGDrive.poll_for_media(cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_drive_poll_for_media(@self, cancellable, callback, user_data);
end;

function TGDrive.poll_for_media_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_drive_poll_for_media_finish(@self, result_, error);
end;

procedure TGDrive.start(flags: TGDriveStartFlags; mount_operation: PGMountOperation; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_drive_start(@self, flags, mount_operation, cancellable, callback, user_data);
end;

function TGDrive.start_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_drive_start_finish(@self, result_, error);
end;

procedure TGDrive.stop(flags: TGMountUnmountFlags; mount_operation: PGMountOperation; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_drive_stop(@self, flags, mount_operation, cancellable, callback, user_data);
end;

function TGDrive.stop_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_drive_stop_finish(@self, result_, error);
end;

function TGMountOperation.new: PGMountOperation; cdecl;
begin
  Result := CastleInternalGio2.g_mount_operation_new();
end;

function TGMountOperation.get_anonymous: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_mount_operation_get_anonymous(@self);
end;

function TGMountOperation.get_choice: gint; cdecl;
begin
  Result := CastleInternalGio2.g_mount_operation_get_choice(@self);
end;

function TGMountOperation.get_domain: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_mount_operation_get_domain(@self);
end;

function TGMountOperation.get_is_tcrypt_hidden_volume: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_mount_operation_get_is_tcrypt_hidden_volume(@self);
end;

function TGMountOperation.get_is_tcrypt_system_volume: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_mount_operation_get_is_tcrypt_system_volume(@self);
end;

function TGMountOperation.get_password: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_mount_operation_get_password(@self);
end;

function TGMountOperation.get_password_save: TGPasswordSave; cdecl;
begin
  Result := CastleInternalGio2.g_mount_operation_get_password_save(@self);
end;

function TGMountOperation.get_pim: guint; cdecl;
begin
  Result := CastleInternalGio2.g_mount_operation_get_pim(@self);
end;

function TGMountOperation.get_username: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_mount_operation_get_username(@self);
end;

procedure TGMountOperation.reply(result_: TGMountOperationResult); cdecl;
begin
  CastleInternalGio2.g_mount_operation_reply(@self, result_);
end;

procedure TGMountOperation.set_anonymous(anonymous: gboolean); cdecl;
begin
  CastleInternalGio2.g_mount_operation_set_anonymous(@self, anonymous);
end;

procedure TGMountOperation.set_choice(choice: gint); cdecl;
begin
  CastleInternalGio2.g_mount_operation_set_choice(@self, choice);
end;

procedure TGMountOperation.set_domain(domain: Pgchar); cdecl;
begin
  CastleInternalGio2.g_mount_operation_set_domain(@self, domain);
end;

procedure TGMountOperation.set_is_tcrypt_hidden_volume(hidden_volume: gboolean); cdecl;
begin
  CastleInternalGio2.g_mount_operation_set_is_tcrypt_hidden_volume(@self, hidden_volume);
end;

procedure TGMountOperation.set_is_tcrypt_system_volume(system_volume: gboolean); cdecl;
begin
  CastleInternalGio2.g_mount_operation_set_is_tcrypt_system_volume(@self, system_volume);
end;

procedure TGMountOperation.set_password(password: Pgchar); cdecl;
begin
  CastleInternalGio2.g_mount_operation_set_password(@self, password);
end;

procedure TGMountOperation.set_password_save(save: TGPasswordSave); cdecl;
begin
  CastleInternalGio2.g_mount_operation_set_password_save(@self, save);
end;

procedure TGMountOperation.set_pim(pim: guint); cdecl;
begin
  CastleInternalGio2.g_mount_operation_set_pim(@self, pim);
end;

procedure TGMountOperation.set_username(username: Pgchar); cdecl;
begin
  CastleInternalGio2.g_mount_operation_set_username(@self, username);
end;

function TGDtlsClientConnection.new(base_socket: PGDatagramBased; server_identity: PGSocketConnectable; error: PPGError): PGDtlsClientConnection; cdecl;
begin
  Result := CastleInternalGio2.g_dtls_client_connection_new(base_socket, server_identity, error);
end;

function TGDtlsClientConnection.get_accepted_cas: PGList; cdecl;
begin
  Result := CastleInternalGio2.g_dtls_client_connection_get_accepted_cas(@self);
end;

function TGDtlsClientConnection.get_server_identity: PGSocketConnectable; cdecl;
begin
  Result := CastleInternalGio2.g_dtls_client_connection_get_server_identity(@self);
end;

function TGDtlsClientConnection.get_validation_flags: TGTlsCertificateFlags; cdecl;
begin
  Result := CastleInternalGio2.g_dtls_client_connection_get_validation_flags(@self);
end;

procedure TGDtlsClientConnection.set_server_identity(identity: PGSocketConnectable); cdecl;
begin
  CastleInternalGio2.g_dtls_client_connection_set_server_identity(@self, identity);
end;

procedure TGDtlsClientConnection.set_validation_flags(flags: TGTlsCertificateFlags); cdecl;
begin
  CastleInternalGio2.g_dtls_client_connection_set_validation_flags(@self, flags);
end;

function TGSocketConnectable.enumerate: PGSocketAddressEnumerator; cdecl;
begin
  Result := CastleInternalGio2.g_socket_connectable_enumerate(@self);
end;

function TGSocketConnectable.proxy_enumerate: PGSocketAddressEnumerator; cdecl;
begin
  Result := CastleInternalGio2.g_socket_connectable_proxy_enumerate(@self);
end;

function TGSocketConnectable.to_string: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_socket_connectable_to_string(@self);
end;

function TGDtlsConnection.close(cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_dtls_connection_close(@self, cancellable, error);
end;

procedure TGDtlsConnection.close_async(io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_dtls_connection_close_async(@self, io_priority, cancellable, callback, user_data);
end;

function TGDtlsConnection.close_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_dtls_connection_close_finish(@self, result_, error);
end;

function TGDtlsConnection.emit_accept_certificate(peer_cert: PGTlsCertificate; errors: TGTlsCertificateFlags): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_dtls_connection_emit_accept_certificate(@self, peer_cert, errors);
end;

function TGDtlsConnection.get_certificate: PGTlsCertificate; cdecl;
begin
  Result := CastleInternalGio2.g_dtls_connection_get_certificate(@self);
end;

{$IFDEF USEGTK3LATESTBINDINGS}
function TGDtlsConnection.get_channel_binding_data(type_: TGTlsChannelBindingType; data: Pguint8; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_dtls_connection_get_channel_binding_data(@self, type_, data, error);
end;
{$ENDIF}

function TGDtlsConnection.get_database: PGTlsDatabase; cdecl;
begin
  Result := CastleInternalGio2.g_dtls_connection_get_database(@self);
end;

function TGDtlsConnection.get_interaction: PGTlsInteraction; cdecl;
begin
  Result := CastleInternalGio2.g_dtls_connection_get_interaction(@self);
end;

function TGDtlsConnection.get_negotiated_protocol: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_dtls_connection_get_negotiated_protocol(@self);
end;

function TGDtlsConnection.get_peer_certificate: PGTlsCertificate; cdecl;
begin
  Result := CastleInternalGio2.g_dtls_connection_get_peer_certificate(@self);
end;

function TGDtlsConnection.get_peer_certificate_errors: TGTlsCertificateFlags; cdecl;
begin
  Result := CastleInternalGio2.g_dtls_connection_get_peer_certificate_errors(@self);
end;

function TGDtlsConnection.get_require_close_notify: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_dtls_connection_get_require_close_notify(@self);
end;

function TGDtlsConnection.handshake(cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_dtls_connection_handshake(@self, cancellable, error);
end;

procedure TGDtlsConnection.handshake_async(io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_dtls_connection_handshake_async(@self, io_priority, cancellable, callback, user_data);
end;

function TGDtlsConnection.handshake_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_dtls_connection_handshake_finish(@self, result_, error);
end;

procedure TGDtlsConnection.set_advertised_protocols(protocols: PPgchar); cdecl;
begin
  CastleInternalGio2.g_dtls_connection_set_advertised_protocols(@self, protocols);
end;

procedure TGDtlsConnection.set_certificate(certificate: PGTlsCertificate); cdecl;
begin
  CastleInternalGio2.g_dtls_connection_set_certificate(@self, certificate);
end;

procedure TGDtlsConnection.set_database(database: PGTlsDatabase); cdecl;
begin
  CastleInternalGio2.g_dtls_connection_set_database(@self, database);
end;

procedure TGDtlsConnection.set_interaction(interaction: PGTlsInteraction); cdecl;
begin
  CastleInternalGio2.g_dtls_connection_set_interaction(@self, interaction);
end;

procedure TGDtlsConnection.set_require_close_notify(require_close_notify: gboolean); cdecl;
begin
  CastleInternalGio2.g_dtls_connection_set_require_close_notify(@self, require_close_notify);
end;

function TGDtlsConnection.shutdown(shutdown_read: gboolean; shutdown_write: gboolean; cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_dtls_connection_shutdown(@self, shutdown_read, shutdown_write, cancellable, error);
end;

procedure TGDtlsConnection.shutdown_async(shutdown_read: gboolean; shutdown_write: gboolean; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_dtls_connection_shutdown_async(@self, shutdown_read, shutdown_write, io_priority, cancellable, callback, user_data);
end;

function TGDtlsConnection.shutdown_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_dtls_connection_shutdown_finish(@self, result_, error);
end;

function TGTlsCertificate.new_from_file(file_: Pgchar; error: PPGError): PGTlsCertificate; cdecl;
begin
  Result := CastleInternalGio2.g_tls_certificate_new_from_file(file_, error);
end;

function TGTlsCertificate.new_from_files(cert_file: Pgchar; key_file: Pgchar; error: PPGError): PGTlsCertificate; cdecl;
begin
  Result := CastleInternalGio2.g_tls_certificate_new_from_files(cert_file, key_file, error);
end;

function TGTlsCertificate.new_from_pem(data: Pgchar; length: gssize; error: PPGError): PGTlsCertificate; cdecl;
begin
  Result := CastleInternalGio2.g_tls_certificate_new_from_pem(data, length, error);
end;

function TGTlsCertificate.list_new_from_file(file_: Pgchar; error: PPGError): PGList; cdecl;
begin
  Result := CastleInternalGio2.g_tls_certificate_list_new_from_file(file_, error);
end;

function TGTlsCertificate.get_issuer: PGTlsCertificate; cdecl;
begin
  Result := CastleInternalGio2.g_tls_certificate_get_issuer(@self);
end;

function TGTlsCertificate.is_same(cert_two: PGTlsCertificate): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_tls_certificate_is_same(@self, cert_two);
end;

function TGTlsCertificate.verify(identity: PGSocketConnectable; trusted_ca: PGTlsCertificate): TGTlsCertificateFlags; cdecl;
begin
  Result := CastleInternalGio2.g_tls_certificate_verify(@self, identity, trusted_ca);
end;

function TGTlsDatabase.create_certificate_handle(certificate: PGTlsCertificate): Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_tls_database_create_certificate_handle(@self, certificate);
end;

function TGTlsDatabase.lookup_certificate_for_handle(handle: Pgchar; interaction: PGTlsInteraction; flags: TGTlsDatabaseLookupFlags; cancellable: PGCancellable; error: PPGError): PGTlsCertificate; cdecl;
begin
  Result := CastleInternalGio2.g_tls_database_lookup_certificate_for_handle(@self, handle, interaction, flags, cancellable, error);
end;

procedure TGTlsDatabase.lookup_certificate_for_handle_async(handle: Pgchar; interaction: PGTlsInteraction; flags: TGTlsDatabaseLookupFlags; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_tls_database_lookup_certificate_for_handle_async(@self, handle, interaction, flags, cancellable, callback, user_data);
end;

function TGTlsDatabase.lookup_certificate_for_handle_finish(result_: PGAsyncResult; error: PPGError): PGTlsCertificate; cdecl;
begin
  Result := CastleInternalGio2.g_tls_database_lookup_certificate_for_handle_finish(@self, result_, error);
end;

function TGTlsDatabase.lookup_certificate_issuer(certificate: PGTlsCertificate; interaction: PGTlsInteraction; flags: TGTlsDatabaseLookupFlags; cancellable: PGCancellable; error: PPGError): PGTlsCertificate; cdecl;
begin
  Result := CastleInternalGio2.g_tls_database_lookup_certificate_issuer(@self, certificate, interaction, flags, cancellable, error);
end;

procedure TGTlsDatabase.lookup_certificate_issuer_async(certificate: PGTlsCertificate; interaction: PGTlsInteraction; flags: TGTlsDatabaseLookupFlags; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_tls_database_lookup_certificate_issuer_async(@self, certificate, interaction, flags, cancellable, callback, user_data);
end;

function TGTlsDatabase.lookup_certificate_issuer_finish(result_: PGAsyncResult; error: PPGError): PGTlsCertificate; cdecl;
begin
  Result := CastleInternalGio2.g_tls_database_lookup_certificate_issuer_finish(@self, result_, error);
end;

function TGTlsDatabase.lookup_certificates_issued_by(issuer_raw_dn: Pguint8; interaction: PGTlsInteraction; flags: TGTlsDatabaseLookupFlags; cancellable: PGCancellable; error: PPGError): PGList; cdecl;
begin
  Result := CastleInternalGio2.g_tls_database_lookup_certificates_issued_by(@self, issuer_raw_dn, interaction, flags, cancellable, error);
end;

procedure TGTlsDatabase.lookup_certificates_issued_by_async(issuer_raw_dn: Pguint8; interaction: PGTlsInteraction; flags: TGTlsDatabaseLookupFlags; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_tls_database_lookup_certificates_issued_by_async(@self, issuer_raw_dn, interaction, flags, cancellable, callback, user_data);
end;

function TGTlsDatabase.lookup_certificates_issued_by_finish(result_: PGAsyncResult; error: PPGError): PGList; cdecl;
begin
  Result := CastleInternalGio2.g_tls_database_lookup_certificates_issued_by_finish(@self, result_, error);
end;

function TGTlsDatabase.verify_chain(chain: PGTlsCertificate; purpose: Pgchar; identity: PGSocketConnectable; interaction: PGTlsInteraction; flags: TGTlsDatabaseVerifyFlags; cancellable: PGCancellable; error: PPGError): TGTlsCertificateFlags; cdecl;
begin
  Result := CastleInternalGio2.g_tls_database_verify_chain(@self, chain, purpose, identity, interaction, flags, cancellable, error);
end;

procedure TGTlsDatabase.verify_chain_async(chain: PGTlsCertificate; purpose: Pgchar; identity: PGSocketConnectable; interaction: PGTlsInteraction; flags: TGTlsDatabaseVerifyFlags; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_tls_database_verify_chain_async(@self, chain, purpose, identity, interaction, flags, cancellable, callback, user_data);
end;

function TGTlsDatabase.verify_chain_finish(result_: PGAsyncResult; error: PPGError): TGTlsCertificateFlags; cdecl;
begin
  Result := CastleInternalGio2.g_tls_database_verify_chain_finish(@self, result_, error);
end;

function TGTlsInteraction.ask_password(password: PGTlsPassword; cancellable: PGCancellable; error: PPGError): TGTlsInteractionResult; cdecl;
begin
  Result := CastleInternalGio2.g_tls_interaction_ask_password(@self, password, cancellable, error);
end;

procedure TGTlsInteraction.ask_password_async(password: PGTlsPassword; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_tls_interaction_ask_password_async(@self, password, cancellable, callback, user_data);
end;

function TGTlsInteraction.ask_password_finish(result_: PGAsyncResult; error: PPGError): TGTlsInteractionResult; cdecl;
begin
  Result := CastleInternalGio2.g_tls_interaction_ask_password_finish(@self, result_, error);
end;

function TGTlsInteraction.invoke_ask_password(password: PGTlsPassword; cancellable: PGCancellable; error: PPGError): TGTlsInteractionResult; cdecl;
begin
  Result := CastleInternalGio2.g_tls_interaction_invoke_ask_password(@self, password, cancellable, error);
end;

function TGTlsInteraction.invoke_request_certificate(connection: PGTlsConnection; flags: TGTlsCertificateRequestFlags; cancellable: PGCancellable; error: PPGError): TGTlsInteractionResult; cdecl;
begin
  Result := CastleInternalGio2.g_tls_interaction_invoke_request_certificate(@self, connection, flags, cancellable, error);
end;

function TGTlsInteraction.request_certificate(connection: PGTlsConnection; flags: TGTlsCertificateRequestFlags; cancellable: PGCancellable; error: PPGError): TGTlsInteractionResult; cdecl;
begin
  Result := CastleInternalGio2.g_tls_interaction_request_certificate(@self, connection, flags, cancellable, error);
end;

procedure TGTlsInteraction.request_certificate_async(connection: PGTlsConnection; flags: TGTlsCertificateRequestFlags; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_tls_interaction_request_certificate_async(@self, connection, flags, cancellable, callback, user_data);
end;

function TGTlsInteraction.request_certificate_finish(result_: PGAsyncResult; error: PPGError): TGTlsInteractionResult; cdecl;
begin
  Result := CastleInternalGio2.g_tls_interaction_request_certificate_finish(@self, result_, error);
end;

function TGDtlsServerConnection.new(base_socket: PGDatagramBased; certificate: PGTlsCertificate; error: PPGError): PGDtlsServerConnection; cdecl;
begin
  Result := CastleInternalGio2.g_dtls_server_connection_new(base_socket, certificate, error);
end;

function TGEmblem.new(icon: PGIcon): PGEmblem; cdecl;
begin
  Result := CastleInternalGio2.g_emblem_new(icon);
end;

function TGEmblem.new_with_origin(icon: PGIcon; origin: TGEmblemOrigin): PGEmblem; cdecl;
begin
  Result := CastleInternalGio2.g_emblem_new_with_origin(icon, origin);
end;

function TGEmblem.get_icon: PGIcon; cdecl;
begin
  Result := CastleInternalGio2.g_emblem_get_icon(@self);
end;

function TGEmblem.get_origin: TGEmblemOrigin; cdecl;
begin
  Result := CastleInternalGio2.g_emblem_get_origin(@self);
end;

function TGEmblemedIcon.new(icon: PGIcon; emblem: PGEmblem): PGEmblemedIcon; cdecl;
begin
  Result := CastleInternalGio2.g_emblemed_icon_new(icon, emblem);
end;

procedure TGEmblemedIcon.add_emblem(emblem: PGEmblem); cdecl;
begin
  CastleInternalGio2.g_emblemed_icon_add_emblem(@self, emblem);
end;

procedure TGEmblemedIcon.clear_emblems; cdecl;
begin
  CastleInternalGio2.g_emblemed_icon_clear_emblems(@self);
end;

function TGEmblemedIcon.get_emblems: PGList; cdecl;
begin
  Result := CastleInternalGio2.g_emblemed_icon_get_emblems(@self);
end;

function TGEmblemedIcon.get_icon: PGIcon; cdecl;
begin
  Result := CastleInternalGio2.g_emblemed_icon_get_icon(@self);
end;

function TGFileIOStream.get_etag: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_file_io_stream_get_etag(@self);
end;

function TGFileIOStream.query_info(attributes: Pgchar; cancellable: PGCancellable; error: PPGError): PGFileInfo; cdecl;
begin
  Result := CastleInternalGio2.g_file_io_stream_query_info(@self, attributes, cancellable, error);
end;

procedure TGFileIOStream.query_info_async(attributes: Pgchar; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_file_io_stream_query_info_async(@self, attributes, io_priority, cancellable, callback, user_data);
end;

function TGFileIOStream.query_info_finish(result_: PGAsyncResult; error: PPGError): PGFileInfo; cdecl;
begin
  Result := CastleInternalGio2.g_file_io_stream_query_info_finish(@self, result_, error);
end;

function TGFileOutputStream.get_etag: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_file_output_stream_get_etag(@self);
end;

function TGFileOutputStream.query_info(attributes: Pgchar; cancellable: PGCancellable; error: PPGError): PGFileInfo; cdecl;
begin
  Result := CastleInternalGio2.g_file_output_stream_query_info(@self, attributes, cancellable, error);
end;

procedure TGFileOutputStream.query_info_async(attributes: Pgchar; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_file_output_stream_query_info_async(@self, attributes, io_priority, cancellable, callback, user_data);
end;

function TGFileOutputStream.query_info_finish(result_: PGAsyncResult; error: PPGError): PGFileInfo; cdecl;
begin
  Result := CastleInternalGio2.g_file_output_stream_query_info_finish(@self, result_, error);
end;

function TGFileEnumerator.close(cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_file_enumerator_close(@self, cancellable, error);
end;

procedure TGFileEnumerator.close_async(io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_file_enumerator_close_async(@self, io_priority, cancellable, callback, user_data);
end;

function TGFileEnumerator.close_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_file_enumerator_close_finish(@self, result_, error);
end;

function TGFileEnumerator.get_child(info: PGFileInfo): PGFile; cdecl;
begin
  Result := CastleInternalGio2.g_file_enumerator_get_child(@self, info);
end;

function TGFileEnumerator.get_container: PGFile; cdecl;
begin
  Result := CastleInternalGio2.g_file_enumerator_get_container(@self);
end;

function TGFileEnumerator.has_pending: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_file_enumerator_has_pending(@self);
end;

function TGFileEnumerator.is_closed: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_file_enumerator_is_closed(@self);
end;

function TGFileEnumerator.iterate(out_info: PPGFileInfo; out_child: PPGFile; cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_file_enumerator_iterate(@self, out_info, out_child, cancellable, error);
end;

function TGFileEnumerator.next_file(cancellable: PGCancellable; error: PPGError): PGFileInfo; cdecl;
begin
  Result := CastleInternalGio2.g_file_enumerator_next_file(@self, cancellable, error);
end;

procedure TGFileEnumerator.next_files_async(num_files: gint; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_file_enumerator_next_files_async(@self, num_files, io_priority, cancellable, callback, user_data);
end;

function TGFileEnumerator.next_files_finish(result_: PGAsyncResult; error: PPGError): PGList; cdecl;
begin
  Result := CastleInternalGio2.g_file_enumerator_next_files_finish(@self, result_, error);
end;

procedure TGFileEnumerator.set_pending(pending: gboolean); cdecl;
begin
  CastleInternalGio2.g_file_enumerator_set_pending(@self, pending);
end;

function TGMount.can_eject: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_mount_can_eject(@self);
end;

function TGMount.can_unmount: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_mount_can_unmount(@self);
end;

procedure TGMount.eject_with_operation(flags: TGMountUnmountFlags; mount_operation: PGMountOperation; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_mount_eject_with_operation(@self, flags, mount_operation, cancellable, callback, user_data);
end;

function TGMount.eject_with_operation_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_mount_eject_with_operation_finish(@self, result_, error);
end;

function TGMount.get_default_location: PGFile; cdecl;
begin
  Result := CastleInternalGio2.g_mount_get_default_location(@self);
end;

function TGMount.get_drive: PGDrive; cdecl;
begin
  Result := CastleInternalGio2.g_mount_get_drive(@self);
end;

function TGMount.get_icon: PGIcon; cdecl;
begin
  Result := CastleInternalGio2.g_mount_get_icon(@self);
end;

function TGMount.get_name: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_mount_get_name(@self);
end;

function TGMount.get_root: PGFile; cdecl;
begin
  Result := CastleInternalGio2.g_mount_get_root(@self);
end;

function TGMount.get_sort_key: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_mount_get_sort_key(@self);
end;

function TGMount.get_symbolic_icon: PGIcon; cdecl;
begin
  Result := CastleInternalGio2.g_mount_get_symbolic_icon(@self);
end;

function TGMount.get_uuid: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_mount_get_uuid(@self);
end;

function TGMount.get_volume: PGVolume; cdecl;
begin
  Result := CastleInternalGio2.g_mount_get_volume(@self);
end;

procedure TGMount.guess_content_type(force_rescan: gboolean; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_mount_guess_content_type(@self, force_rescan, cancellable, callback, user_data);
end;

function TGMount.guess_content_type_finish(result_: PGAsyncResult; error: PPGError): PPgchar; cdecl;
begin
  Result := CastleInternalGio2.g_mount_guess_content_type_finish(@self, result_, error);
end;

function TGMount.guess_content_type_sync(force_rescan: gboolean; cancellable: PGCancellable; error: PPGError): PPgchar; cdecl;
begin
  Result := CastleInternalGio2.g_mount_guess_content_type_sync(@self, force_rescan, cancellable, error);
end;

function TGMount.is_shadowed: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_mount_is_shadowed(@self);
end;

procedure TGMount.remount(flags: TGMountMountFlags; mount_operation: PGMountOperation; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_mount_remount(@self, flags, mount_operation, cancellable, callback, user_data);
end;

function TGMount.remount_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_mount_remount_finish(@self, result_, error);
end;

procedure TGMount.shadow; cdecl;
begin
  CastleInternalGio2.g_mount_shadow(@self);
end;

procedure TGMount.unmount_with_operation(flags: TGMountUnmountFlags; mount_operation: PGMountOperation; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_mount_unmount_with_operation(@self, flags, mount_operation, cancellable, callback, user_data);
end;

function TGMount.unmount_with_operation_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_mount_unmount_with_operation_finish(@self, result_, error);
end;

procedure TGMount.unshadow; cdecl;
begin
  CastleInternalGio2.g_mount_unshadow(@self);
end;

function TGFileMonitor.cancel: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_file_monitor_cancel(@self);
end;

procedure TGFileMonitor.emit_event(child: PGFile; other_file: PGFile; event_type: TGFileMonitorEvent); cdecl;
begin
  CastleInternalGio2.g_file_monitor_emit_event(@self, child, other_file, event_type);
end;

function TGFileMonitor.is_cancelled: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_file_monitor_is_cancelled(@self);
end;

procedure TGFileMonitor.set_rate_limit(limit_msecs: gint); cdecl;
begin
  CastleInternalGio2.g_file_monitor_set_rate_limit(@self, limit_msecs);
end;

function TGFileInfo.new: PGFileInfo; cdecl;
begin
  Result := CastleInternalGio2.g_file_info_new();
end;

procedure TGFileInfo.clear_status; cdecl;
begin
  CastleInternalGio2.g_file_info_clear_status(@self);
end;

procedure TGFileInfo.copy_into(dest_info: PGFileInfo); cdecl;
begin
  CastleInternalGio2.g_file_info_copy_into(@self, dest_info);
end;

function TGFileInfo.dup: PGFileInfo; cdecl;
begin
  Result := CastleInternalGio2.g_file_info_dup(@self);
end;

function TGFileInfo.get_attribute_as_string(attribute: Pgchar): Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_file_info_get_attribute_as_string(@self, attribute);
end;

function TGFileInfo.get_attribute_boolean(attribute: Pgchar): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_file_info_get_attribute_boolean(@self, attribute);
end;

function TGFileInfo.get_attribute_byte_string(attribute: Pgchar): Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_file_info_get_attribute_byte_string(@self, attribute);
end;

function TGFileInfo.get_attribute_data(attribute: Pgchar; type_: PGFileAttributeType; value_pp: Pgpointer; status: PGFileAttributeStatus): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_file_info_get_attribute_data(@self, attribute, type_, value_pp, status);
end;

function TGFileInfo.get_attribute_int32(attribute: Pgchar): gint32; cdecl;
begin
  Result := CastleInternalGio2.g_file_info_get_attribute_int32(@self, attribute);
end;

function TGFileInfo.get_attribute_int64(attribute: Pgchar): gint64; cdecl;
begin
  Result := CastleInternalGio2.g_file_info_get_attribute_int64(@self, attribute);
end;

function TGFileInfo.get_attribute_object(attribute: Pgchar): PGObject; cdecl;
begin
  Result := CastleInternalGio2.g_file_info_get_attribute_object(@self, attribute);
end;

function TGFileInfo.get_attribute_status(attribute: Pgchar): TGFileAttributeStatus; cdecl;
begin
  Result := CastleInternalGio2.g_file_info_get_attribute_status(@self, attribute);
end;

function TGFileInfo.get_attribute_string(attribute: Pgchar): Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_file_info_get_attribute_string(@self, attribute);
end;

function TGFileInfo.get_attribute_stringv(attribute: Pgchar): PPgchar; cdecl;
begin
  Result := CastleInternalGio2.g_file_info_get_attribute_stringv(@self, attribute);
end;

function TGFileInfo.get_attribute_type(attribute: Pgchar): TGFileAttributeType; cdecl;
begin
  Result := CastleInternalGio2.g_file_info_get_attribute_type(@self, attribute);
end;

function TGFileInfo.get_attribute_uint32(attribute: Pgchar): guint32; cdecl;
begin
  Result := CastleInternalGio2.g_file_info_get_attribute_uint32(@self, attribute);
end;

function TGFileInfo.get_attribute_uint64(attribute: Pgchar): guint64; cdecl;
begin
  Result := CastleInternalGio2.g_file_info_get_attribute_uint64(@self, attribute);
end;

function TGFileInfo.get_content_type: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_file_info_get_content_type(@self);
end;

function TGFileInfo.get_deletion_date: PGDateTime; cdecl;
begin
  Result := CastleInternalGio2.g_file_info_get_deletion_date(@self);
end;

function TGFileInfo.get_display_name: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_file_info_get_display_name(@self);
end;

function TGFileInfo.get_edit_name: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_file_info_get_edit_name(@self);
end;

function TGFileInfo.get_etag: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_file_info_get_etag(@self);
end;

function TGFileInfo.get_file_type: TGFileType; cdecl;
begin
  Result := CastleInternalGio2.g_file_info_get_file_type(@self);
end;

function TGFileInfo.get_icon: PGIcon; cdecl;
begin
  Result := CastleInternalGio2.g_file_info_get_icon(@self);
end;

function TGFileInfo.get_is_backup: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_file_info_get_is_backup(@self);
end;

function TGFileInfo.get_is_hidden: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_file_info_get_is_hidden(@self);
end;

function TGFileInfo.get_is_symlink: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_file_info_get_is_symlink(@self);
end;

function TGFileInfo.get_modification_date_time: PGDateTime; cdecl;
begin
  Result := CastleInternalGio2.g_file_info_get_modification_date_time(@self);
end;

function TGFileInfo.get_name: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_file_info_get_name(@self);
end;

function TGFileInfo.get_size: gint64; cdecl;
begin
  Result := CastleInternalGio2.g_file_info_get_size(@self);
end;

function TGFileInfo.get_sort_order: gint32; cdecl;
begin
  Result := CastleInternalGio2.g_file_info_get_sort_order(@self);
end;

function TGFileInfo.get_symbolic_icon: PGIcon; cdecl;
begin
  Result := CastleInternalGio2.g_file_info_get_symbolic_icon(@self);
end;

function TGFileInfo.get_symlink_target: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_file_info_get_symlink_target(@self);
end;

function TGFileInfo.has_attribute(attribute: Pgchar): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_file_info_has_attribute(@self, attribute);
end;

function TGFileInfo.has_namespace(name_space: Pgchar): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_file_info_has_namespace(@self, name_space);
end;

function TGFileInfo.list_attributes(name_space: Pgchar): PPgchar; cdecl;
begin
  Result := CastleInternalGio2.g_file_info_list_attributes(@self, name_space);
end;

procedure TGFileInfo.remove_attribute(attribute: Pgchar); cdecl;
begin
  CastleInternalGio2.g_file_info_remove_attribute(@self, attribute);
end;

procedure TGFileInfo.set_attribute(attribute: Pgchar; type_: TGFileAttributeType; value_p: gpointer); cdecl;
begin
  CastleInternalGio2.g_file_info_set_attribute(@self, attribute, type_, value_p);
end;

procedure TGFileInfo.set_attribute_boolean(attribute: Pgchar; attr_value: gboolean); cdecl;
begin
  CastleInternalGio2.g_file_info_set_attribute_boolean(@self, attribute, attr_value);
end;

procedure TGFileInfo.set_attribute_byte_string(attribute: Pgchar; attr_value: Pgchar); cdecl;
begin
  CastleInternalGio2.g_file_info_set_attribute_byte_string(@self, attribute, attr_value);
end;

procedure TGFileInfo.set_attribute_int32(attribute: Pgchar; attr_value: gint32); cdecl;
begin
  CastleInternalGio2.g_file_info_set_attribute_int32(@self, attribute, attr_value);
end;

procedure TGFileInfo.set_attribute_int64(attribute: Pgchar; attr_value: gint64); cdecl;
begin
  CastleInternalGio2.g_file_info_set_attribute_int64(@self, attribute, attr_value);
end;

procedure TGFileInfo.set_attribute_mask(mask: PGFileAttributeMatcher); cdecl;
begin
  CastleInternalGio2.g_file_info_set_attribute_mask(@self, mask);
end;

procedure TGFileInfo.set_attribute_object(attribute: Pgchar; attr_value: PGObject); cdecl;
begin
  CastleInternalGio2.g_file_info_set_attribute_object(@self, attribute, attr_value);
end;

function TGFileInfo.set_attribute_status(attribute: Pgchar; status: TGFileAttributeStatus): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_file_info_set_attribute_status(@self, attribute, status);
end;

procedure TGFileInfo.set_attribute_string(attribute: Pgchar; attr_value: Pgchar); cdecl;
begin
  CastleInternalGio2.g_file_info_set_attribute_string(@self, attribute, attr_value);
end;

procedure TGFileInfo.set_attribute_stringv(attribute: Pgchar; attr_value: PPgchar); cdecl;
begin
  CastleInternalGio2.g_file_info_set_attribute_stringv(@self, attribute, attr_value);
end;

procedure TGFileInfo.set_attribute_uint32(attribute: Pgchar; attr_value: guint32); cdecl;
begin
  CastleInternalGio2.g_file_info_set_attribute_uint32(@self, attribute, attr_value);
end;

procedure TGFileInfo.set_attribute_uint64(attribute: Pgchar; attr_value: guint64); cdecl;
begin
  CastleInternalGio2.g_file_info_set_attribute_uint64(@self, attribute, attr_value);
end;

procedure TGFileInfo.set_content_type(content_type: Pgchar); cdecl;
begin
  CastleInternalGio2.g_file_info_set_content_type(@self, content_type);
end;

procedure TGFileInfo.set_display_name(display_name: Pgchar); cdecl;
begin
  CastleInternalGio2.g_file_info_set_display_name(@self, display_name);
end;

procedure TGFileInfo.set_edit_name(edit_name: Pgchar); cdecl;
begin
  CastleInternalGio2.g_file_info_set_edit_name(@self, edit_name);
end;

procedure TGFileInfo.set_file_type(type_: TGFileType); cdecl;
begin
  CastleInternalGio2.g_file_info_set_file_type(@self, type_);
end;

procedure TGFileInfo.set_icon(icon: PGIcon); cdecl;
begin
  CastleInternalGio2.g_file_info_set_icon(@self, icon);
end;

procedure TGFileInfo.set_is_hidden(is_hidden: gboolean); cdecl;
begin
  CastleInternalGio2.g_file_info_set_is_hidden(@self, is_hidden);
end;

procedure TGFileInfo.set_is_symlink(is_symlink: gboolean); cdecl;
begin
  CastleInternalGio2.g_file_info_set_is_symlink(@self, is_symlink);
end;

procedure TGFileInfo.set_modification_date_time(mtime: PGDateTime); cdecl;
begin
  CastleInternalGio2.g_file_info_set_modification_date_time(@self, mtime);
end;

procedure TGFileInfo.set_name(name: Pgchar); cdecl;
begin
  CastleInternalGio2.g_file_info_set_name(@self, name);
end;

procedure TGFileInfo.set_size(size: gint64); cdecl;
begin
  CastleInternalGio2.g_file_info_set_size(@self, size);
end;

procedure TGFileInfo.set_sort_order(sort_order: gint32); cdecl;
begin
  CastleInternalGio2.g_file_info_set_sort_order(@self, sort_order);
end;

procedure TGFileInfo.set_symbolic_icon(icon: PGIcon); cdecl;
begin
  CastleInternalGio2.g_file_info_set_symbolic_icon(@self, icon);
end;

procedure TGFileInfo.set_symlink_target(symlink_target: Pgchar); cdecl;
begin
  CastleInternalGio2.g_file_info_set_symlink_target(@self, symlink_target);
end;

procedure TGFileInfo.unset_attribute_mask; cdecl;
begin
  CastleInternalGio2.g_file_info_unset_attribute_mask(@self);
end;

function TGFileAttributeInfoList.new: PGFileAttributeInfoList; cdecl;
begin
  Result := CastleInternalGio2.g_file_attribute_info_list_new();
end;

procedure TGFileAttributeInfoList.add(name: Pgchar; type_: TGFileAttributeType; flags: TGFileAttributeInfoFlags); cdecl;
begin
  CastleInternalGio2.g_file_attribute_info_list_add(@self, name, type_, flags);
end;

function TGFileAttributeInfoList.dup: PGFileAttributeInfoList; cdecl;
begin
  Result := CastleInternalGio2.g_file_attribute_info_list_dup(@self);
end;

function TGFileAttributeInfoList.lookup(name: Pgchar): PGFileAttributeInfo; cdecl;
begin
  Result := CastleInternalGio2.g_file_attribute_info_list_lookup(@self, name);
end;

function TGFileAttributeInfoList.ref: PGFileAttributeInfoList; cdecl;
begin
  Result := CastleInternalGio2.g_file_attribute_info_list_ref(@self);
end;

procedure TGFileAttributeInfoList.unref; cdecl;
begin
  CastleInternalGio2.g_file_attribute_info_list_unref(@self);
end;

function TGFileInputStream.query_info(attributes: Pgchar; cancellable: PGCancellable; error: PPGError): PGFileInfo; cdecl;
begin
  Result := CastleInternalGio2.g_file_input_stream_query_info(@self, attributes, cancellable, error);
end;

procedure TGFileInputStream.query_info_async(attributes: Pgchar; io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_file_input_stream_query_info_async(@self, attributes, io_priority, cancellable, callback, user_data);
end;

function TGFileInputStream.query_info_finish(result_: PGAsyncResult; error: PPGError): PGFileInfo; cdecl;
begin
  Result := CastleInternalGio2.g_file_input_stream_query_info_finish(@self, result_, error);
end;

function TGFileAttributeMatcher.new(attributes: Pgchar): PGFileAttributeMatcher; cdecl;
begin
  Result := CastleInternalGio2.g_file_attribute_matcher_new(attributes);
end;

function TGFileAttributeMatcher.enumerate_namespace(ns: Pgchar): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_file_attribute_matcher_enumerate_namespace(@self, ns);
end;

function TGFileAttributeMatcher.enumerate_next: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_file_attribute_matcher_enumerate_next(@self);
end;

function TGFileAttributeMatcher.matches(attribute: Pgchar): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_file_attribute_matcher_matches(@self, attribute);
end;

function TGFileAttributeMatcher.matches_only(attribute: Pgchar): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_file_attribute_matcher_matches_only(@self, attribute);
end;

function TGFileAttributeMatcher.ref: PGFileAttributeMatcher; cdecl;
begin
  Result := CastleInternalGio2.g_file_attribute_matcher_ref(@self);
end;

function TGFileAttributeMatcher.subtract(subtract: PGFileAttributeMatcher): PGFileAttributeMatcher; cdecl;
begin
  Result := CastleInternalGio2.g_file_attribute_matcher_subtract(@self, subtract);
end;

function TGFileAttributeMatcher.to_string: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_file_attribute_matcher_to_string(@self);
end;

procedure TGFileAttributeMatcher.unref; cdecl;
begin
  CastleInternalGio2.g_file_attribute_matcher_unref(@self);
end;

function TGFileDescriptorBased.get_fd: gint; cdecl;
begin
  Result := CastleInternalGio2.g_file_descriptor_based_get_fd(@self);
end;

function TGFileIcon.new(file_: PGFile): PGFileIcon; cdecl;
begin
  Result := CastleInternalGio2.g_file_icon_new(file_);
end;

function TGFileIcon.get_file: PGFile; cdecl;
begin
  Result := CastleInternalGio2.g_file_icon_get_file(@self);
end;

function TGFilenameCompleter.new: PGFilenameCompleter; cdecl;
begin
  Result := CastleInternalGio2.g_filename_completer_new();
end;

function TGFilenameCompleter.get_completion_suffix(initial_text: Pgchar): Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_filename_completer_get_completion_suffix(@self, initial_text);
end;

function TGFilenameCompleter.get_completions(initial_text: Pgchar): PPgchar; cdecl;
begin
  Result := CastleInternalGio2.g_filename_completer_get_completions(@self, initial_text);
end;

procedure TGFilenameCompleter.set_dirs_only(dirs_only: gboolean); cdecl;
begin
  CastleInternalGio2.g_filename_completer_set_dirs_only(@self, dirs_only);
end;

function TGIOExtension.get_name: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_io_extension_get_name(@self);
end;

function TGIOExtension.get_priority: gint; cdecl;
begin
  Result := CastleInternalGio2.g_io_extension_get_priority(@self);
end;

function TGIOExtension.get_type: TGType; cdecl;
begin
  Result := CastleInternalGio2.g_io_extension_get_type(@self);
end;

function TGIOExtension.ref_class: PGTypeClass; cdecl;
begin
  Result := CastleInternalGio2.g_io_extension_ref_class(@self);
end;

function TGIOExtensionPoint.get_extension_by_name(name: Pgchar): PGIOExtension; cdecl;
begin
  Result := CastleInternalGio2.g_io_extension_point_get_extension_by_name(@self, name);
end;

function TGIOExtensionPoint.get_extensions: PGList; cdecl;
begin
  Result := CastleInternalGio2.g_io_extension_point_get_extensions(@self);
end;

function TGIOExtensionPoint.get_required_type: TGType; cdecl;
begin
  Result := CastleInternalGio2.g_io_extension_point_get_required_type(@self);
end;

procedure TGIOExtensionPoint.set_required_type(type_: TGType); cdecl;
begin
  CastleInternalGio2.g_io_extension_point_set_required_type(@self, type_);
end;

function TGIOExtensionPoint.implement(extension_point_name: Pgchar; type_: TGType; extension_name: Pgchar; priority: gint): PGIOExtension; cdecl;
begin
  Result := CastleInternalGio2.g_io_extension_point_implement(extension_point_name, type_, extension_name, priority);
end;

function TGIOExtensionPoint.lookup(name: Pgchar): PGIOExtensionPoint; cdecl;
begin
  Result := CastleInternalGio2.g_io_extension_point_lookup(name);
end;

function TGIOExtensionPoint.register(name: Pgchar): PGIOExtensionPoint; cdecl;
begin
  Result := CastleInternalGio2.g_io_extension_point_register(name);
end;

function TGIOModule.new(filename: Pgchar): PGIOModule; cdecl;
begin
  Result := CastleInternalGio2.g_io_module_new(filename);
end;

procedure TGIOModuleScope.block(basename: Pgchar); cdecl;
begin
  CastleInternalGio2.g_io_module_scope_block(@self, basename);
end;

procedure TGIOModuleScope.free; cdecl;
begin
  CastleInternalGio2.g_io_module_scope_free(@self);
end;

function TGIOModuleScope.new(flags: TGIOModuleScopeFlags): PGIOModuleScope; cdecl;
begin
  Result := CastleInternalGio2.g_io_module_scope_new(flags);
end;

function TGInetAddress.new_any(family: TGSocketFamily): PGInetAddress; cdecl;
begin
  Result := CastleInternalGio2.g_inet_address_new_any(family);
end;

function TGInetAddress.new_from_bytes(bytes: Pguint8; family: TGSocketFamily): PGInetAddress; cdecl;
begin
  Result := CastleInternalGio2.g_inet_address_new_from_bytes(bytes, family);
end;

function TGInetAddress.new_from_string(string_: Pgchar): PGInetAddress; cdecl;
begin
  Result := CastleInternalGio2.g_inet_address_new_from_string(string_);
end;

function TGInetAddress.new_loopback(family: TGSocketFamily): PGInetAddress; cdecl;
begin
  Result := CastleInternalGio2.g_inet_address_new_loopback(family);
end;

function TGInetAddress.equal(other_address: PGInetAddress): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_inet_address_equal(@self, other_address);
end;

function TGInetAddress.get_family: TGSocketFamily; cdecl;
begin
  Result := CastleInternalGio2.g_inet_address_get_family(@self);
end;

function TGInetAddress.get_is_any: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_inet_address_get_is_any(@self);
end;

function TGInetAddress.get_is_link_local: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_inet_address_get_is_link_local(@self);
end;

function TGInetAddress.get_is_loopback: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_inet_address_get_is_loopback(@self);
end;

function TGInetAddress.get_is_mc_global: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_inet_address_get_is_mc_global(@self);
end;

function TGInetAddress.get_is_mc_link_local: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_inet_address_get_is_mc_link_local(@self);
end;

function TGInetAddress.get_is_mc_node_local: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_inet_address_get_is_mc_node_local(@self);
end;

function TGInetAddress.get_is_mc_org_local: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_inet_address_get_is_mc_org_local(@self);
end;

function TGInetAddress.get_is_mc_site_local: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_inet_address_get_is_mc_site_local(@self);
end;

function TGInetAddress.get_is_multicast: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_inet_address_get_is_multicast(@self);
end;

function TGInetAddress.get_is_site_local: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_inet_address_get_is_site_local(@self);
end;

function TGInetAddress.get_native_size: gsize; cdecl;
begin
  Result := CastleInternalGio2.g_inet_address_get_native_size(@self);
end;

function TGInetAddress.to_bytes: Pguint8; cdecl;
begin
  Result := CastleInternalGio2.g_inet_address_to_bytes(@self);
end;

function TGInetAddress.to_string: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_inet_address_to_string(@self);
end;

function TGInetAddressMask.new(addr: PGInetAddress; length: guint; error: PPGError): PGInetAddressMask; cdecl;
begin
  Result := CastleInternalGio2.g_inet_address_mask_new(addr, length, error);
end;

function TGInetAddressMask.new_from_string(mask_string: Pgchar; error: PPGError): PGInetAddressMask; cdecl;
begin
  Result := CastleInternalGio2.g_inet_address_mask_new_from_string(mask_string, error);
end;

function TGInetAddressMask.equal(mask2: PGInetAddressMask): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_inet_address_mask_equal(@self, mask2);
end;

function TGInetAddressMask.get_address: PGInetAddress; cdecl;
begin
  Result := CastleInternalGio2.g_inet_address_mask_get_address(@self);
end;

function TGInetAddressMask.get_family: TGSocketFamily; cdecl;
begin
  Result := CastleInternalGio2.g_inet_address_mask_get_family(@self);
end;

function TGInetAddressMask.get_length: guint; cdecl;
begin
  Result := CastleInternalGio2.g_inet_address_mask_get_length(@self);
end;

function TGInetAddressMask.matches(address: PGInetAddress): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_inet_address_mask_matches(@self, address);
end;

function TGInetAddressMask.to_string: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_inet_address_mask_to_string(@self);
end;

function TGSocketAddress.new_from_native(native: gpointer; len: gsize): PGSocketAddress; cdecl;
begin
  Result := CastleInternalGio2.g_socket_address_new_from_native(native, len);
end;

function TGSocketAddress.get_family: TGSocketFamily; cdecl;
begin
  Result := CastleInternalGio2.g_socket_address_get_family(@self);
end;

function TGSocketAddress.get_native_size: gssize; cdecl;
begin
  Result := CastleInternalGio2.g_socket_address_get_native_size(@self);
end;

function TGSocketAddress.to_native(dest: gpointer; destlen: gsize; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_socket_address_to_native(@self, dest, destlen, error);
end;

function TGInetSocketAddress.new(address: PGInetAddress; port: guint16): PGInetSocketAddress; cdecl;
begin
  Result := CastleInternalGio2.g_inet_socket_address_new(address, port);
end;

function TGInetSocketAddress.new_from_string(address: Pgchar; port: guint): PGInetSocketAddress; cdecl;
begin
  Result := CastleInternalGio2.g_inet_socket_address_new_from_string(address, port);
end;

function TGInetSocketAddress.get_address: PGInetAddress; cdecl;
begin
  Result := CastleInternalGio2.g_inet_socket_address_get_address(@self);
end;

function TGInetSocketAddress.get_flowinfo: guint32; cdecl;
begin
  Result := CastleInternalGio2.g_inet_socket_address_get_flowinfo(@self);
end;

function TGInetSocketAddress.get_port: guint16; cdecl;
begin
  Result := CastleInternalGio2.g_inet_socket_address_get_port(@self);
end;

function TGInetSocketAddress.get_scope_id: guint32; cdecl;
begin
  Result := CastleInternalGio2.g_inet_socket_address_get_scope_id(@self);
end;

function TGSocketControlMessage.deserialize(level: gint; type_: gint; size: gsize; data: guint8): PGSocketControlMessage; cdecl;
begin
  Result := CastleInternalGio2.g_socket_control_message_deserialize(level, type_, size, data);
end;

function TGSocketControlMessage.get_level: gint; cdecl;
begin
  Result := CastleInternalGio2.g_socket_control_message_get_level(@self);
end;

function TGSocketControlMessage.get_msg_type: gint; cdecl;
begin
  Result := CastleInternalGio2.g_socket_control_message_get_msg_type(@self);
end;

function TGSocketControlMessage.get_size: gsize; cdecl;
begin
  Result := CastleInternalGio2.g_socket_control_message_get_size(@self);
end;

procedure TGSocketControlMessage.serialize(data: gpointer); cdecl;
begin
  CastleInternalGio2.g_socket_control_message_serialize(@self, data);
end;

function TGListModel.get_item(position: guint): gpointer; cdecl;
begin
  Result := CastleInternalGio2.g_list_model_get_item(@self, position);
end;

function TGListModel.get_item_type: TGType; cdecl;
begin
  Result := CastleInternalGio2.g_list_model_get_item_type(@self);
end;

function TGListModel.get_n_items: guint; cdecl;
begin
  Result := CastleInternalGio2.g_list_model_get_n_items(@self);
end;

function TGListModel.get_object(position: guint): PGObject; cdecl;
begin
  Result := CastleInternalGio2.g_list_model_get_object(@self, position);
end;

procedure TGListModel.items_changed(position: guint; removed: guint; added: guint); cdecl;
begin
  CastleInternalGio2.g_list_model_items_changed(@self, position, removed, added);
end;

function TGListStore.new(item_type: TGType): PGListStore; cdecl;
begin
  Result := CastleInternalGio2.g_list_store_new(item_type);
end;

procedure TGListStore.append(item: PGObject); cdecl;
begin
  CastleInternalGio2.g_list_store_append(@self, item);
end;

function TGListStore.find(item: PGObject; position: Pguint): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_list_store_find(@self, item, position);
end;

function TGListStore.find_with_equal_func(item: PGObject; equal_func: TGEqualFunc; position: Pguint): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_list_store_find_with_equal_func(@self, item, equal_func, position);
end;

procedure TGListStore.insert(position: guint; item: PGObject); cdecl;
begin
  CastleInternalGio2.g_list_store_insert(@self, position, item);
end;

function TGListStore.insert_sorted(item: PGObject; compare_func: TGCompareDataFunc; user_data: gpointer): guint; cdecl;
begin
  Result := CastleInternalGio2.g_list_store_insert_sorted(@self, item, compare_func, user_data);
end;

procedure TGListStore.remove(position: guint); cdecl;
begin
  CastleInternalGio2.g_list_store_remove(@self, position);
end;

procedure TGListStore.remove_all; cdecl;
begin
  CastleInternalGio2.g_list_store_remove_all(@self);
end;

procedure TGListStore.sort(compare_func: TGCompareDataFunc; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_list_store_sort(@self, compare_func, user_data);
end;

procedure TGListStore.splice(position: guint; n_removals: guint; additions: PGObject; n_additions: guint); cdecl;
begin
  CastleInternalGio2.g_list_store_splice(@self, position, n_removals, additions, n_additions);
end;

function TGMemoryInputStream.new: PGMemoryInputStream; cdecl;
begin
  Result := CastleInternalGio2.g_memory_input_stream_new();
end;

function TGMemoryInputStream.new_from_bytes(bytes: PGBytes): PGMemoryInputStream; cdecl;
begin
  Result := CastleInternalGio2.g_memory_input_stream_new_from_bytes(bytes);
end;

function TGMemoryInputStream.new_from_data(data: Pguint8; len: gssize; destroy_: TGDestroyNotify): PGMemoryInputStream; cdecl;
begin
  Result := CastleInternalGio2.g_memory_input_stream_new_from_data(data, len, destroy_);
end;

procedure TGMemoryInputStream.add_bytes(bytes: PGBytes); cdecl;
begin
  CastleInternalGio2.g_memory_input_stream_add_bytes(@self, bytes);
end;

procedure TGMemoryInputStream.add_data(data: Pguint8; len: gssize; destroy_: TGDestroyNotify); cdecl;
begin
  CastleInternalGio2.g_memory_input_stream_add_data(@self, data, len, destroy_);
end;

function TGMemoryMonitor.dup_default: PGMemoryMonitor; cdecl;
begin
  Result := CastleInternalGio2.g_memory_monitor_dup_default();
end;

function TGMemoryOutputStream.new(data: gpointer; size: gsize; realloc_function: TGReallocFunc; destroy_function: TGDestroyNotify): PGMemoryOutputStream; cdecl;
begin
  Result := CastleInternalGio2.g_memory_output_stream_new(data, size, realloc_function, destroy_function);
end;

function TGMemoryOutputStream.new_resizable: PGMemoryOutputStream; cdecl;
begin
  Result := CastleInternalGio2.g_memory_output_stream_new_resizable();
end;

function TGMemoryOutputStream.get_data: gpointer; cdecl;
begin
  Result := CastleInternalGio2.g_memory_output_stream_get_data(@self);
end;

function TGMemoryOutputStream.get_data_size: gsize; cdecl;
begin
  Result := CastleInternalGio2.g_memory_output_stream_get_data_size(@self);
end;

function TGMemoryOutputStream.get_size: gsize; cdecl;
begin
  Result := CastleInternalGio2.g_memory_output_stream_get_size(@self);
end;

function TGMemoryOutputStream.steal_as_bytes: PGBytes; cdecl;
begin
  Result := CastleInternalGio2.g_memory_output_stream_steal_as_bytes(@self);
end;

function TGMemoryOutputStream.steal_data: gpointer; cdecl;
begin
  Result := CastleInternalGio2.g_memory_output_stream_steal_data(@self);
end;

function TGMenu.new: PGMenu; cdecl;
begin
  Result := CastleInternalGio2.g_menu_new();
end;

procedure TGMenu.append(label_: Pgchar; detailed_action: Pgchar); cdecl;
begin
  CastleInternalGio2.g_menu_append(@self, label_, detailed_action);
end;

procedure TGMenu.append_item(item: PGMenuItem); cdecl;
begin
  CastleInternalGio2.g_menu_append_item(@self, item);
end;

procedure TGMenu.append_section(label_: Pgchar; section: PGMenuModel); cdecl;
begin
  CastleInternalGio2.g_menu_append_section(@self, label_, section);
end;

procedure TGMenu.append_submenu(label_: Pgchar; submenu: PGMenuModel); cdecl;
begin
  CastleInternalGio2.g_menu_append_submenu(@self, label_, submenu);
end;

procedure TGMenu.freeze; cdecl;
begin
  CastleInternalGio2.g_menu_freeze(@self);
end;

procedure TGMenu.insert(position: gint; label_: Pgchar; detailed_action: Pgchar); cdecl;
begin
  CastleInternalGio2.g_menu_insert(@self, position, label_, detailed_action);
end;

procedure TGMenu.insert_item(position: gint; item: PGMenuItem); cdecl;
begin
  CastleInternalGio2.g_menu_insert_item(@self, position, item);
end;

procedure TGMenu.insert_section(position: gint; label_: Pgchar; section: PGMenuModel); cdecl;
begin
  CastleInternalGio2.g_menu_insert_section(@self, position, label_, section);
end;

procedure TGMenu.insert_submenu(position: gint; label_: Pgchar; submenu: PGMenuModel); cdecl;
begin
  CastleInternalGio2.g_menu_insert_submenu(@self, position, label_, submenu);
end;

procedure TGMenu.prepend(label_: Pgchar; detailed_action: Pgchar); cdecl;
begin
  CastleInternalGio2.g_menu_prepend(@self, label_, detailed_action);
end;

procedure TGMenu.prepend_item(item: PGMenuItem); cdecl;
begin
  CastleInternalGio2.g_menu_prepend_item(@self, item);
end;

procedure TGMenu.prepend_section(label_: Pgchar; section: PGMenuModel); cdecl;
begin
  CastleInternalGio2.g_menu_prepend_section(@self, label_, section);
end;

procedure TGMenu.prepend_submenu(label_: Pgchar; submenu: PGMenuModel); cdecl;
begin
  CastleInternalGio2.g_menu_prepend_submenu(@self, label_, submenu);
end;

procedure TGMenu.remove(position: gint); cdecl;
begin
  CastleInternalGio2.g_menu_remove(@self, position);
end;

procedure TGMenu.remove_all; cdecl;
begin
  CastleInternalGio2.g_menu_remove_all(@self);
end;

function TGMenuItem.new(label_: Pgchar; detailed_action: Pgchar): PGMenuItem; cdecl;
begin
  Result := CastleInternalGio2.g_menu_item_new(label_, detailed_action);
end;

function TGMenuItem.new_from_model(model: PGMenuModel; item_index: gint): PGMenuItem; cdecl;
begin
  Result := CastleInternalGio2.g_menu_item_new_from_model(model, item_index);
end;

function TGMenuItem.new_section(label_: Pgchar; section: PGMenuModel): PGMenuItem; cdecl;
begin
  Result := CastleInternalGio2.g_menu_item_new_section(label_, section);
end;

function TGMenuItem.new_submenu(label_: Pgchar; submenu: PGMenuModel): PGMenuItem; cdecl;
begin
  Result := CastleInternalGio2.g_menu_item_new_submenu(label_, submenu);
end;

function TGMenuItem.get_attribute_value(attribute: Pgchar; expected_type: PGVariantType): PGVariant; cdecl;
begin
  Result := CastleInternalGio2.g_menu_item_get_attribute_value(@self, attribute, expected_type);
end;

function TGMenuItem.get_link(link: Pgchar): PGMenuModel; cdecl;
begin
  Result := CastleInternalGio2.g_menu_item_get_link(@self, link);
end;

procedure TGMenuItem.set_action_and_target_value(action: Pgchar; target_value: PGVariant); cdecl;
begin
  CastleInternalGio2.g_menu_item_set_action_and_target_value(@self, action, target_value);
end;

procedure TGMenuItem.set_attribute_value(attribute: Pgchar; value: PGVariant); cdecl;
begin
  CastleInternalGio2.g_menu_item_set_attribute_value(@self, attribute, value);
end;

procedure TGMenuItem.set_detailed_action(detailed_action: Pgchar); cdecl;
begin
  CastleInternalGio2.g_menu_item_set_detailed_action(@self, detailed_action);
end;

procedure TGMenuItem.set_icon(icon: PGIcon); cdecl;
begin
  CastleInternalGio2.g_menu_item_set_icon(@self, icon);
end;

procedure TGMenuItem.set_label(label_: Pgchar); cdecl;
begin
  CastleInternalGio2.g_menu_item_set_label(@self, label_);
end;

procedure TGMenuItem.set_link(link: Pgchar; model: PGMenuModel); cdecl;
begin
  CastleInternalGio2.g_menu_item_set_link(@self, link, model);
end;

procedure TGMenuItem.set_section(section: PGMenuModel); cdecl;
begin
  CastleInternalGio2.g_menu_item_set_section(@self, section);
end;

procedure TGMenuItem.set_submenu(submenu: PGMenuModel); cdecl;
begin
  CastleInternalGio2.g_menu_item_set_submenu(@self, submenu);
end;

function TGMenuAttributeIter.get_name: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_menu_attribute_iter_get_name(@self);
end;

function TGMenuAttributeIter.get_next(out_name: PPgchar; value: PPGVariant): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_menu_attribute_iter_get_next(@self, out_name, value);
end;

function TGMenuAttributeIter.get_value: PGVariant; cdecl;
begin
  Result := CastleInternalGio2.g_menu_attribute_iter_get_value(@self);
end;

function TGMenuAttributeIter.next: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_menu_attribute_iter_next(@self);
end;

function TGMenuLinkIter.get_name: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_menu_link_iter_get_name(@self);
end;

function TGMenuLinkIter.get_next(out_link: PPgchar; value: PPGMenuModel): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_menu_link_iter_get_next(@self, out_link, value);
end;

function TGMenuLinkIter.get_value: PGMenuModel; cdecl;
begin
  Result := CastleInternalGio2.g_menu_link_iter_get_value(@self);
end;

function TGMenuLinkIter.next: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_menu_link_iter_next(@self);
end;

function TGVolume.can_eject: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_volume_can_eject(@self);
end;

function TGVolume.can_mount: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_volume_can_mount(@self);
end;

procedure TGVolume.eject_with_operation(flags: TGMountUnmountFlags; mount_operation: PGMountOperation; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_volume_eject_with_operation(@self, flags, mount_operation, cancellable, callback, user_data);
end;

function TGVolume.eject_with_operation_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_volume_eject_with_operation_finish(@self, result_, error);
end;

function TGVolume.enumerate_identifiers: PPgchar; cdecl;
begin
  Result := CastleInternalGio2.g_volume_enumerate_identifiers(@self);
end;

function TGVolume.get_activation_root: PGFile; cdecl;
begin
  Result := CastleInternalGio2.g_volume_get_activation_root(@self);
end;

function TGVolume.get_drive: PGDrive; cdecl;
begin
  Result := CastleInternalGio2.g_volume_get_drive(@self);
end;

function TGVolume.get_icon: PGIcon; cdecl;
begin
  Result := CastleInternalGio2.g_volume_get_icon(@self);
end;

function TGVolume.get_identifier(kind: Pgchar): Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_volume_get_identifier(@self, kind);
end;

function TGVolume.get_mount: PGMount; cdecl;
begin
  Result := CastleInternalGio2.g_volume_get_mount(@self);
end;

function TGVolume.get_name: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_volume_get_name(@self);
end;

function TGVolume.get_sort_key: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_volume_get_sort_key(@self);
end;

function TGVolume.get_symbolic_icon: PGIcon; cdecl;
begin
  Result := CastleInternalGio2.g_volume_get_symbolic_icon(@self);
end;

function TGVolume.get_uuid: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_volume_get_uuid(@self);
end;

procedure TGVolume.mount(flags: TGMountMountFlags; mount_operation: PGMountOperation; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_volume_mount(@self, flags, mount_operation, cancellable, callback, user_data);
end;

function TGVolume.mount_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_volume_mount_finish(@self, result_, error);
end;

function TGVolume.should_automount: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_volume_should_automount(@self);
end;

function TGNativeSocketAddress.new(native: gpointer; len: gsize): PGNativeSocketAddress; cdecl;
begin
  Result := CastleInternalGio2.g_native_socket_address_new(native, len);
end;

function TGVolumeMonitor.get: PGVolumeMonitor; cdecl;
begin
  Result := CastleInternalGio2.g_volume_monitor_get();
end;

function TGVolumeMonitor.get_connected_drives: PGList; cdecl;
begin
  Result := CastleInternalGio2.g_volume_monitor_get_connected_drives(@self);
end;

function TGVolumeMonitor.get_mount_for_uuid(uuid: Pgchar): PGMount; cdecl;
begin
  Result := CastleInternalGio2.g_volume_monitor_get_mount_for_uuid(@self, uuid);
end;

function TGVolumeMonitor.get_mounts: PGList; cdecl;
begin
  Result := CastleInternalGio2.g_volume_monitor_get_mounts(@self);
end;

function TGVolumeMonitor.get_volume_for_uuid(uuid: Pgchar): PGVolume; cdecl;
begin
  Result := CastleInternalGio2.g_volume_monitor_get_volume_for_uuid(@self, uuid);
end;

function TGVolumeMonitor.get_volumes: PGList; cdecl;
begin
  Result := CastleInternalGio2.g_volume_monitor_get_volumes(@self);
end;

function TGNetworkAddress.new(hostname: Pgchar; port: guint16): PGNetworkAddress; cdecl;
begin
  Result := CastleInternalGio2.g_network_address_new(hostname, port);
end;

function TGNetworkAddress.new_loopback(port: guint16): PGNetworkAddress; cdecl;
begin
  Result := CastleInternalGio2.g_network_address_new_loopback(port);
end;

function TGNetworkAddress.parse(host_and_port: Pgchar; default_port: guint16; error: PPGError): PGNetworkAddress; cdecl;
begin
  Result := CastleInternalGio2.g_network_address_parse(host_and_port, default_port, error);
end;

function TGNetworkAddress.parse_uri(uri: Pgchar; default_port: guint16; error: PPGError): PGNetworkAddress; cdecl;
begin
  Result := CastleInternalGio2.g_network_address_parse_uri(uri, default_port, error);
end;

function TGNetworkAddress.get_hostname: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_network_address_get_hostname(@self);
end;

function TGNetworkAddress.get_port: guint16; cdecl;
begin
  Result := CastleInternalGio2.g_network_address_get_port(@self);
end;

function TGNetworkAddress.get_scheme: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_network_address_get_scheme(@self);
end;

function TGNetworkMonitor.get_default: PGNetworkMonitor; cdecl;
begin
  Result := CastleInternalGio2.g_network_monitor_get_default();
end;

function TGNetworkMonitor.can_reach(connectable: PGSocketConnectable; cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_network_monitor_can_reach(@self, connectable, cancellable, error);
end;

procedure TGNetworkMonitor.can_reach_async(connectable: PGSocketConnectable; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_network_monitor_can_reach_async(@self, connectable, cancellable, callback, user_data);
end;

function TGNetworkMonitor.can_reach_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_network_monitor_can_reach_finish(@self, result_, error);
end;

function TGNetworkMonitor.get_connectivity: TGNetworkConnectivity; cdecl;
begin
  Result := CastleInternalGio2.g_network_monitor_get_connectivity(@self);
end;

function TGNetworkMonitor.get_network_available: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_network_monitor_get_network_available(@self);
end;

function TGNetworkMonitor.get_network_metered: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_network_monitor_get_network_metered(@self);
end;

function TGNetworkService.new(service: Pgchar; protocol: Pgchar; domain: Pgchar): PGNetworkService; cdecl;
begin
  Result := CastleInternalGio2.g_network_service_new(service, protocol, domain);
end;

function TGNetworkService.get_domain: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_network_service_get_domain(@self);
end;

function TGNetworkService.get_protocol: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_network_service_get_protocol(@self);
end;

function TGNetworkService.get_scheme: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_network_service_get_scheme(@self);
end;

function TGNetworkService.get_service: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_network_service_get_service(@self);
end;

procedure TGNetworkService.set_scheme(scheme: Pgchar); cdecl;
begin
  CastleInternalGio2.g_network_service_set_scheme(@self, scheme);
end;

function TGPermission.acquire(cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_permission_acquire(@self, cancellable, error);
end;

procedure TGPermission.acquire_async(cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_permission_acquire_async(@self, cancellable, callback, user_data);
end;

function TGPermission.acquire_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_permission_acquire_finish(@self, result_, error);
end;

function TGPermission.get_allowed: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_permission_get_allowed(@self);
end;

function TGPermission.get_can_acquire: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_permission_get_can_acquire(@self);
end;

function TGPermission.get_can_release: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_permission_get_can_release(@self);
end;

procedure TGPermission.impl_update(allowed: gboolean; can_acquire: gboolean; can_release: gboolean); cdecl;
begin
  CastleInternalGio2.g_permission_impl_update(@self, allowed, can_acquire, can_release);
end;

function TGPermission.release(cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_permission_release(@self, cancellable, error);
end;

procedure TGPermission.release_async(cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_permission_release_async(@self, cancellable, callback, user_data);
end;

function TGPermission.release_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_permission_release_finish(@self, result_, error);
end;

function TGPropertyAction.new(name: Pgchar; object_: PGObject; property_name: Pgchar): PGPropertyAction; cdecl;
begin
  Result := CastleInternalGio2.g_property_action_new(name, object_, property_name);
end;

function TGProxy.get_default_for_protocol(protocol: Pgchar): PGProxy; cdecl;
begin
  Result := CastleInternalGio2.g_proxy_get_default_for_protocol(protocol);
end;

function TGProxy.connect(connection: PGIOStream; proxy_address: PGProxyAddress; cancellable: PGCancellable; error: PPGError): PGIOStream; cdecl;
begin
  Result := CastleInternalGio2.g_proxy_connect(@self, connection, proxy_address, cancellable, error);
end;

procedure TGProxy.connect_async(connection: PGIOStream; proxy_address: PGProxyAddress; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_proxy_connect_async(@self, connection, proxy_address, cancellable, callback, user_data);
end;

function TGProxy.connect_finish(result_: PGAsyncResult; error: PPGError): PGIOStream; cdecl;
begin
  Result := CastleInternalGio2.g_proxy_connect_finish(@self, result_, error);
end;

function TGProxy.supports_hostname: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_proxy_supports_hostname(@self);
end;

function TGProxyAddress.new(inetaddr: PGInetAddress; port: guint16; protocol: Pgchar; dest_hostname: Pgchar; dest_port: guint16; username: Pgchar; password: Pgchar): PGProxyAddress; cdecl;
begin
  Result := CastleInternalGio2.g_proxy_address_new(inetaddr, port, protocol, dest_hostname, dest_port, username, password);
end;

function TGProxyAddress.get_destination_hostname: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_proxy_address_get_destination_hostname(@self);
end;

function TGProxyAddress.get_destination_port: guint16; cdecl;
begin
  Result := CastleInternalGio2.g_proxy_address_get_destination_port(@self);
end;

function TGProxyAddress.get_destination_protocol: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_proxy_address_get_destination_protocol(@self);
end;

function TGProxyAddress.get_password: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_proxy_address_get_password(@self);
end;

function TGProxyAddress.get_protocol: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_proxy_address_get_protocol(@self);
end;

function TGProxyAddress.get_uri: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_proxy_address_get_uri(@self);
end;

function TGProxyAddress.get_username: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_proxy_address_get_username(@self);
end;

function TGProxyResolver.get_default: PGProxyResolver; cdecl;
begin
  Result := CastleInternalGio2.g_proxy_resolver_get_default();
end;

function TGProxyResolver.is_supported: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_proxy_resolver_is_supported(@self);
end;

function TGProxyResolver.lookup(uri: Pgchar; cancellable: PGCancellable; error: PPGError): PPgchar; cdecl;
begin
  Result := CastleInternalGio2.g_proxy_resolver_lookup(@self, uri, cancellable, error);
end;

procedure TGProxyResolver.lookup_async(uri: Pgchar; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_proxy_resolver_lookup_async(@self, uri, cancellable, callback, user_data);
end;

function TGProxyResolver.lookup_finish(result_: PGAsyncResult; error: PPGError): PPgchar; cdecl;
begin
  Result := CastleInternalGio2.g_proxy_resolver_lookup_finish(@self, result_, error);
end;

function TGSocketAddressEnumerator.next(cancellable: PGCancellable; error: PPGError): PGSocketAddress; cdecl;
begin
  Result := CastleInternalGio2.g_socket_address_enumerator_next(@self, cancellable, error);
end;

procedure TGSocketAddressEnumerator.next_async(cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_socket_address_enumerator_next_async(@self, cancellable, callback, user_data);
end;

function TGSocketAddressEnumerator.next_finish(result_: PGAsyncResult; error: PPGError): PGSocketAddress; cdecl;
begin
  Result := CastleInternalGio2.g_socket_address_enumerator_next_finish(@self, result_, error);
end;

procedure TGResolver.free_addresses(addresses: PGList); cdecl;
begin
  CastleInternalGio2.g_resolver_free_addresses(addresses);
end;

procedure TGResolver.free_targets(targets: PGList); cdecl;
begin
  CastleInternalGio2.g_resolver_free_targets(targets);
end;

function TGResolver.get_default: PGResolver; cdecl;
begin
  Result := CastleInternalGio2.g_resolver_get_default();
end;

function TGResolver.lookup_by_address(address: PGInetAddress; cancellable: PGCancellable; error: PPGError): Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_resolver_lookup_by_address(@self, address, cancellable, error);
end;

procedure TGResolver.lookup_by_address_async(address: PGInetAddress; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_resolver_lookup_by_address_async(@self, address, cancellable, callback, user_data);
end;

function TGResolver.lookup_by_address_finish(result_: PGAsyncResult; error: PPGError): Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_resolver_lookup_by_address_finish(@self, result_, error);
end;

function TGResolver.lookup_by_name(hostname: Pgchar; cancellable: PGCancellable; error: PPGError): PGList; cdecl;
begin
  Result := CastleInternalGio2.g_resolver_lookup_by_name(@self, hostname, cancellable, error);
end;

procedure TGResolver.lookup_by_name_async(hostname: Pgchar; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_resolver_lookup_by_name_async(@self, hostname, cancellable, callback, user_data);
end;

function TGResolver.lookup_by_name_finish(result_: PGAsyncResult; error: PPGError): PGList; cdecl;
begin
  Result := CastleInternalGio2.g_resolver_lookup_by_name_finish(@self, result_, error);
end;

function TGResolver.lookup_by_name_with_flags(hostname: Pgchar; flags: TGResolverNameLookupFlags; cancellable: PGCancellable; error: PPGError): PGList; cdecl;
begin
  Result := CastleInternalGio2.g_resolver_lookup_by_name_with_flags(@self, hostname, flags, cancellable, error);
end;

procedure TGResolver.lookup_by_name_with_flags_async(hostname: Pgchar; flags: TGResolverNameLookupFlags; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_resolver_lookup_by_name_with_flags_async(@self, hostname, flags, cancellable, callback, user_data);
end;

function TGResolver.lookup_by_name_with_flags_finish(result_: PGAsyncResult; error: PPGError): PGList; cdecl;
begin
  Result := CastleInternalGio2.g_resolver_lookup_by_name_with_flags_finish(@self, result_, error);
end;

function TGResolver.lookup_records(rrname: Pgchar; record_type: TGResolverRecordType; cancellable: PGCancellable; error: PPGError): PGList; cdecl;
begin
  Result := CastleInternalGio2.g_resolver_lookup_records(@self, rrname, record_type, cancellable, error);
end;

procedure TGResolver.lookup_records_async(rrname: Pgchar; record_type: TGResolverRecordType; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_resolver_lookup_records_async(@self, rrname, record_type, cancellable, callback, user_data);
end;

function TGResolver.lookup_records_finish(result_: PGAsyncResult; error: PPGError): PGList; cdecl;
begin
  Result := CastleInternalGio2.g_resolver_lookup_records_finish(@self, result_, error);
end;

function TGResolver.lookup_service(service: Pgchar; protocol: Pgchar; domain: Pgchar; cancellable: PGCancellable; error: PPGError): PGList; cdecl;
begin
  Result := CastleInternalGio2.g_resolver_lookup_service(@self, service, protocol, domain, cancellable, error);
end;

procedure TGResolver.lookup_service_async(service: Pgchar; protocol: Pgchar; domain: Pgchar; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_resolver_lookup_service_async(@self, service, protocol, domain, cancellable, callback, user_data);
end;

function TGResolver.lookup_service_finish(result_: PGAsyncResult; error: PPGError): PGList; cdecl;
begin
  Result := CastleInternalGio2.g_resolver_lookup_service_finish(@self, result_, error);
end;

procedure TGResolver.set_default; cdecl;
begin
  CastleInternalGio2.g_resolver_set_default(@self);
end;

function TGResource.new_from_data(data: PGBytes; error: PPGError): PGResource; cdecl;
begin
  Result := CastleInternalGio2.g_resource_new_from_data(data, error);
end;

procedure TGResource._register; cdecl;
begin
  CastleInternalGio2.g_resources_register(@self);
end;

procedure TGResource._unregister; cdecl;
begin
  CastleInternalGio2.g_resources_unregister(@self);
end;

function TGResource.enumerate_children(path: Pgchar; lookup_flags: TGResourceLookupFlags; error: PPGError): PPgchar; cdecl;
begin
  Result := CastleInternalGio2.g_resource_enumerate_children(@self, path, lookup_flags, error);
end;

function TGResource.get_info(path: Pgchar; lookup_flags: TGResourceLookupFlags; size: Pgsize; flags: Pguint32; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_resource_get_info(@self, path, lookup_flags, size, flags, error);
end;

function TGResource.lookup_data(path: Pgchar; lookup_flags: TGResourceLookupFlags; error: PPGError): PGBytes; cdecl;
begin
  Result := CastleInternalGio2.g_resource_lookup_data(@self, path, lookup_flags, error);
end;

function TGResource.open_stream(path: Pgchar; lookup_flags: TGResourceLookupFlags; error: PPGError): PGInputStream; cdecl;
begin
  Result := CastleInternalGio2.g_resource_open_stream(@self, path, lookup_flags, error);
end;

function TGResource.ref: PGResource; cdecl;
begin
  Result := CastleInternalGio2.g_resource_ref(@self);
end;

procedure TGResource.unref; cdecl;
begin
  CastleInternalGio2.g_resource_unref(@self);
end;

function TGResource.load(filename: Pgchar; error: PPGError): PGResource; cdecl;
begin
  Result := CastleInternalGio2.g_resource_load(filename, error);
end;

function TGSettings.new(schema_id: Pgchar): PGSettings; cdecl;
begin
  Result := CastleInternalGio2.g_settings_new(schema_id);
end;

function TGSettings.new_full(schema: PGSettingsSchema; backend: PGSettingsBackend; path: Pgchar): PGSettings; cdecl;
begin
  Result := CastleInternalGio2.g_settings_new_full(schema, backend, path);
end;

function TGSettings.new_with_backend(schema_id: Pgchar; backend: PGSettingsBackend): PGSettings; cdecl;
begin
  Result := CastleInternalGio2.g_settings_new_with_backend(schema_id, backend);
end;

function TGSettings.new_with_backend_and_path(schema_id: Pgchar; backend: PGSettingsBackend; path: Pgchar): PGSettings; cdecl;
begin
  Result := CastleInternalGio2.g_settings_new_with_backend_and_path(schema_id, backend, path);
end;

function TGSettings.new_with_path(schema_id: Pgchar; path: Pgchar): PGSettings; cdecl;
begin
  Result := CastleInternalGio2.g_settings_new_with_path(schema_id, path);
end;

procedure TGSettings.sync; cdecl;
begin
  CastleInternalGio2.g_settings_sync();
end;

procedure TGSettings.unbind(object_: PGObject; property_: Pgchar); cdecl;
begin
  CastleInternalGio2.g_settings_unbind(object_, property_);
end;

procedure TGSettings.apply; cdecl;
begin
  CastleInternalGio2.g_settings_apply(@self);
end;

procedure TGSettings.bind(key: Pgchar; object_: PGObject; property_: Pgchar; flags: TGSettingsBindFlags); cdecl;
begin
  CastleInternalGio2.g_settings_bind(@self, key, object_, property_, flags);
end;

procedure TGSettings.bind_with_mapping(key: Pgchar; object_: PGObject; property_: Pgchar; flags: TGSettingsBindFlags; get_mapping: TGSettingsBindGetMapping; set_mapping: TGSettingsBindSetMapping; user_data: gpointer; destroy_: TGDestroyNotify); cdecl;
begin
  CastleInternalGio2.g_settings_bind_with_mapping(@self, key, object_, property_, flags, get_mapping, set_mapping, user_data, destroy_);
end;

procedure TGSettings.bind_writable(key: Pgchar; object_: PGObject; property_: Pgchar; inverted: gboolean); cdecl;
begin
  CastleInternalGio2.g_settings_bind_writable(@self, key, object_, property_, inverted);
end;

function TGSettings.create_action(key: Pgchar): PGAction; cdecl;
begin
  Result := CastleInternalGio2.g_settings_create_action(@self, key);
end;

procedure TGSettings.delay; cdecl;
begin
  CastleInternalGio2.g_settings_delay(@self);
end;

function TGSettings.get_boolean(key: Pgchar): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_settings_get_boolean(@self, key);
end;

function TGSettings.get_child(name: Pgchar): PGSettings; cdecl;
begin
  Result := CastleInternalGio2.g_settings_get_child(@self, name);
end;

function TGSettings.get_default_value(key: Pgchar): PGVariant; cdecl;
begin
  Result := CastleInternalGio2.g_settings_get_default_value(@self, key);
end;

function TGSettings.get_double(key: Pgchar): gdouble; cdecl;
begin
  Result := CastleInternalGio2.g_settings_get_double(@self, key);
end;

function TGSettings.get_enum(key: Pgchar): gint; cdecl;
begin
  Result := CastleInternalGio2.g_settings_get_enum(@self, key);
end;

function TGSettings.get_flags(key: Pgchar): guint; cdecl;
begin
  Result := CastleInternalGio2.g_settings_get_flags(@self, key);
end;

function TGSettings.get_has_unapplied: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_settings_get_has_unapplied(@self);
end;

function TGSettings.get_int(key: Pgchar): gint; cdecl;
begin
  Result := CastleInternalGio2.g_settings_get_int(@self, key);
end;

function TGSettings.get_int64(key: Pgchar): gint64; cdecl;
begin
  Result := CastleInternalGio2.g_settings_get_int64(@self, key);
end;

function TGSettings.get_mapped(key: Pgchar; mapping: TGSettingsGetMapping; user_data: gpointer): gpointer; cdecl;
begin
  Result := CastleInternalGio2.g_settings_get_mapped(@self, key, mapping, user_data);
end;

function TGSettings.get_string(key: Pgchar): Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_settings_get_string(@self, key);
end;

function TGSettings.get_strv(key: Pgchar): PPgchar; cdecl;
begin
  Result := CastleInternalGio2.g_settings_get_strv(@self, key);
end;

function TGSettings.get_uint(key: Pgchar): guint; cdecl;
begin
  Result := CastleInternalGio2.g_settings_get_uint(@self, key);
end;

function TGSettings.get_uint64(key: Pgchar): guint64; cdecl;
begin
  Result := CastleInternalGio2.g_settings_get_uint64(@self, key);
end;

function TGSettings.get_user_value(key: Pgchar): PGVariant; cdecl;
begin
  Result := CastleInternalGio2.g_settings_get_user_value(@self, key);
end;

function TGSettings.get_value(key: Pgchar): PGVariant; cdecl;
begin
  Result := CastleInternalGio2.g_settings_get_value(@self, key);
end;

function TGSettings.is_writable(name: Pgchar): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_settings_is_writable(@self, name);
end;

function TGSettings.list_children: PPgchar; cdecl;
begin
  Result := CastleInternalGio2.g_settings_list_children(@self);
end;

procedure TGSettings.reset(key: Pgchar); cdecl;
begin
  CastleInternalGio2.g_settings_reset(@self, key);
end;

procedure TGSettings.revert; cdecl;
begin
  CastleInternalGio2.g_settings_revert(@self);
end;

function TGSettings.set_boolean(key: Pgchar; value: gboolean): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_settings_set_boolean(@self, key, value);
end;

function TGSettings.set_double(key: Pgchar; value: gdouble): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_settings_set_double(@self, key, value);
end;

function TGSettings.set_enum(key: Pgchar; value: gint): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_settings_set_enum(@self, key, value);
end;

function TGSettings.set_flags(key: Pgchar; value: guint): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_settings_set_flags(@self, key, value);
end;

function TGSettings.set_int(key: Pgchar; value: gint): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_settings_set_int(@self, key, value);
end;

function TGSettings.set_int64(key: Pgchar; value: gint64): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_settings_set_int64(@self, key, value);
end;

function TGSettings.set_string(key: Pgchar; value: Pgchar): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_settings_set_string(@self, key, value);
end;

function TGSettings.set_strv(key: Pgchar; value: PPgchar): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_settings_set_strv(@self, key, value);
end;

function TGSettings.set_uint(key: Pgchar; value: guint): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_settings_set_uint(@self, key, value);
end;

function TGSettings.set_uint64(key: Pgchar; value: guint64): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_settings_set_uint64(@self, key, value);
end;

function TGSettings.set_value(key: Pgchar; value: PGVariant): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_settings_set_value(@self, key, value);
end;

function TGSettingsSchema.get_id: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_settings_schema_get_id(@self);
end;

function TGSettingsSchema.get_key(name: Pgchar): PGSettingsSchemaKey; cdecl;
begin
  Result := CastleInternalGio2.g_settings_schema_get_key(@self, name);
end;

function TGSettingsSchema.get_path: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_settings_schema_get_path(@self);
end;

function TGSettingsSchema.has_key(name: Pgchar): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_settings_schema_has_key(@self, name);
end;

function TGSettingsSchema.list_children: PPgchar; cdecl;
begin
  Result := CastleInternalGio2.g_settings_schema_list_children(@self);
end;

function TGSettingsSchema.list_keys: PPgchar; cdecl;
begin
  Result := CastleInternalGio2.g_settings_schema_list_keys(@self);
end;

function TGSettingsSchema.ref: PGSettingsSchema; cdecl;
begin
  Result := CastleInternalGio2.g_settings_schema_ref(@self);
end;

procedure TGSettingsSchema.unref; cdecl;
begin
  CastleInternalGio2.g_settings_schema_unref(@self);
end;

procedure TGSettingsBackend.flatten_tree(tree: PGTree; path: PPgchar; keys: PPPgchar; values: PPPGVariant); cdecl;
begin
  CastleInternalGio2.g_settings_backend_flatten_tree(tree, path, keys, values);
end;

function TGSettingsBackend.get_default: PGSettingsBackend; cdecl;
begin
  Result := CastleInternalGio2.g_settings_backend_get_default();
end;

procedure TGSettingsBackend.changed(key: Pgchar; origin_tag: gpointer); cdecl;
begin
  CastleInternalGio2.g_settings_backend_changed(@self, key, origin_tag);
end;

procedure TGSettingsBackend.changed_tree(tree: PGTree; origin_tag: gpointer); cdecl;
begin
  CastleInternalGio2.g_settings_backend_changed_tree(@self, tree, origin_tag);
end;

procedure TGSettingsBackend.keys_changed(path: Pgchar; items: PPgchar; origin_tag: gpointer); cdecl;
begin
  CastleInternalGio2.g_settings_backend_keys_changed(@self, path, items, origin_tag);
end;

procedure TGSettingsBackend.path_changed(path: Pgchar; origin_tag: gpointer); cdecl;
begin
  CastleInternalGio2.g_settings_backend_path_changed(@self, path, origin_tag);
end;

procedure TGSettingsBackend.path_writable_changed(path: Pgchar); cdecl;
begin
  CastleInternalGio2.g_settings_backend_path_writable_changed(@self, path);
end;

procedure TGSettingsBackend.writable_changed(key: Pgchar); cdecl;
begin
  CastleInternalGio2.g_settings_backend_writable_changed(@self, key);
end;

function TGSettingsSchemaKey.get_default_value: PGVariant; cdecl;
begin
  Result := CastleInternalGio2.g_settings_schema_key_get_default_value(@self);
end;

function TGSettingsSchemaKey.get_description: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_settings_schema_key_get_description(@self);
end;

function TGSettingsSchemaKey.get_name: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_settings_schema_key_get_name(@self);
end;

function TGSettingsSchemaKey.get_range: PGVariant; cdecl;
begin
  Result := CastleInternalGio2.g_settings_schema_key_get_range(@self);
end;

function TGSettingsSchemaKey.get_summary: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_settings_schema_key_get_summary(@self);
end;

function TGSettingsSchemaKey.get_value_type: PGVariantType; cdecl;
begin
  Result := CastleInternalGio2.g_settings_schema_key_get_value_type(@self);
end;

function TGSettingsSchemaKey.range_check(value: PGVariant): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_settings_schema_key_range_check(@self, value);
end;

function TGSettingsSchemaKey.ref: PGSettingsSchemaKey; cdecl;
begin
  Result := CastleInternalGio2.g_settings_schema_key_ref(@self);
end;

procedure TGSettingsSchemaKey.unref; cdecl;
begin
  CastleInternalGio2.g_settings_schema_key_unref(@self);
end;

function TGSettingsSchemaSource.new_from_directory(directory: Pgchar; parent: PGSettingsSchemaSource; trusted: gboolean; error: PPGError): PGSettingsSchemaSource; cdecl;
begin
  Result := CastleInternalGio2.g_settings_schema_source_new_from_directory(directory, parent, trusted, error);
end;

procedure TGSettingsSchemaSource.list_schemas(recursive: gboolean; non_relocatable: PPPgchar; relocatable: PPPgchar); cdecl;
begin
  CastleInternalGio2.g_settings_schema_source_list_schemas(@self, recursive, non_relocatable, relocatable);
end;

function TGSettingsSchemaSource.lookup(schema_id: Pgchar; recursive: gboolean): PGSettingsSchema; cdecl;
begin
  Result := CastleInternalGio2.g_settings_schema_source_lookup(@self, schema_id, recursive);
end;

function TGSettingsSchemaSource.ref: PGSettingsSchemaSource; cdecl;
begin
  Result := CastleInternalGio2.g_settings_schema_source_ref(@self);
end;

procedure TGSettingsSchemaSource.unref; cdecl;
begin
  CastleInternalGio2.g_settings_schema_source_unref(@self);
end;

function TGSettingsSchemaSource.get_default: PGSettingsSchemaSource; cdecl;
begin
  Result := CastleInternalGio2.g_settings_schema_source_get_default();
end;

function TGSimpleActionGroup.new: PGSimpleActionGroup; cdecl;
begin
  Result := CastleInternalGio2.g_simple_action_group_new();
end;

function TGSimpleIOStream.new(input_stream: PGInputStream; output_stream: PGOutputStream): PGSimpleIOStream; cdecl;
begin
  Result := CastleInternalGio2.g_simple_io_stream_new(input_stream, output_stream);
end;

function TGSimplePermission.new(allowed: gboolean): PGSimplePermission; cdecl;
begin
  Result := CastleInternalGio2.g_simple_permission_new(allowed);
end;

function TGSimpleProxyResolver.new(default_proxy: Pgchar; ignore_hosts: PPgchar): PGProxyResolver; cdecl;
begin
  Result := CastleInternalGio2.g_simple_proxy_resolver_new(default_proxy, ignore_hosts);
end;

procedure TGSimpleProxyResolver.set_default_proxy(default_proxy: Pgchar); cdecl;
begin
  CastleInternalGio2.g_simple_proxy_resolver_set_default_proxy(@self, default_proxy);
end;

procedure TGSimpleProxyResolver.set_ignore_hosts(ignore_hosts: PPgchar); cdecl;
begin
  CastleInternalGio2.g_simple_proxy_resolver_set_ignore_hosts(@self, ignore_hosts);
end;

procedure TGSimpleProxyResolver.set_uri_proxy(uri_scheme: Pgchar; proxy: Pgchar); cdecl;
begin
  CastleInternalGio2.g_simple_proxy_resolver_set_uri_proxy(@self, uri_scheme, proxy);
end;

function TGSocket.new(family: TGSocketFamily; type_: TGSocketType; protocol: TGSocketProtocol; error: PPGError): PGSocket; cdecl;
begin
  Result := CastleInternalGio2.g_socket_new(family, type_, protocol, error);
end;

function TGSocket.new_from_fd(fd: gint; error: PPGError): PGSocket; cdecl;
begin
  Result := CastleInternalGio2.g_socket_new_from_fd(fd, error);
end;

function TGSocket.accept(cancellable: PGCancellable; error: PPGError): PGSocket; cdecl;
begin
  Result := CastleInternalGio2.g_socket_accept(@self, cancellable, error);
end;

function TGSocket.bind(address: PGSocketAddress; allow_reuse: gboolean; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_socket_bind(@self, address, allow_reuse, error);
end;

function TGSocket.check_connect_result(error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_socket_check_connect_result(@self, error);
end;

function TGSocket.close(error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_socket_close(@self, error);
end;

function TGSocket.condition_check(condition: TGIOCondition): TGIOCondition; cdecl;
begin
  Result := CastleInternalGio2.g_socket_condition_check(@self, condition);
end;

function TGSocket.condition_timed_wait(condition: TGIOCondition; timeout_us: gint64; cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_socket_condition_timed_wait(@self, condition, timeout_us, cancellable, error);
end;

function TGSocket.condition_wait(condition: TGIOCondition; cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_socket_condition_wait(@self, condition, cancellable, error);
end;

function TGSocket.connect(address: PGSocketAddress; cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_socket_connect(@self, address, cancellable, error);
end;

function TGSocket.connection_factory_create_connection: PGSocketConnection; cdecl;
begin
  Result := CastleInternalGio2.g_socket_connection_factory_create_connection(@self);
end;

function TGSocket.create_source(condition: TGIOCondition; cancellable: PGCancellable): PGSource; cdecl;
begin
  Result := CastleInternalGio2.g_socket_create_source(@self, condition, cancellable);
end;

function TGSocket.get_available_bytes: gssize; cdecl;
begin
  Result := CastleInternalGio2.g_socket_get_available_bytes(@self);
end;

function TGSocket.get_blocking: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_socket_get_blocking(@self);
end;

function TGSocket.get_broadcast: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_socket_get_broadcast(@self);
end;

function TGSocket.get_credentials(error: PPGError): PGCredentials; cdecl;
begin
  Result := CastleInternalGio2.g_socket_get_credentials(@self, error);
end;

function TGSocket.get_family: TGSocketFamily; cdecl;
begin
  Result := CastleInternalGio2.g_socket_get_family(@self);
end;

function TGSocket.get_fd: gint; cdecl;
begin
  Result := CastleInternalGio2.g_socket_get_fd(@self);
end;

function TGSocket.get_keepalive: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_socket_get_keepalive(@self);
end;

function TGSocket.get_listen_backlog: gint; cdecl;
begin
  Result := CastleInternalGio2.g_socket_get_listen_backlog(@self);
end;

function TGSocket.get_local_address(error: PPGError): PGSocketAddress; cdecl;
begin
  Result := CastleInternalGio2.g_socket_get_local_address(@self, error);
end;

function TGSocket.get_multicast_loopback: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_socket_get_multicast_loopback(@self);
end;

function TGSocket.get_multicast_ttl: guint; cdecl;
begin
  Result := CastleInternalGio2.g_socket_get_multicast_ttl(@self);
end;

function TGSocket.get_option(level: gint; optname: gint; value: Pgint; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_socket_get_option(@self, level, optname, value, error);
end;

function TGSocket.get_protocol: TGSocketProtocol; cdecl;
begin
  Result := CastleInternalGio2.g_socket_get_protocol(@self);
end;

function TGSocket.get_remote_address(error: PPGError): PGSocketAddress; cdecl;
begin
  Result := CastleInternalGio2.g_socket_get_remote_address(@self, error);
end;

function TGSocket.get_socket_type: TGSocketType; cdecl;
begin
  Result := CastleInternalGio2.g_socket_get_socket_type(@self);
end;

function TGSocket.get_timeout: guint; cdecl;
begin
  Result := CastleInternalGio2.g_socket_get_timeout(@self);
end;

function TGSocket.get_ttl: guint; cdecl;
begin
  Result := CastleInternalGio2.g_socket_get_ttl(@self);
end;

function TGSocket.is_closed: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_socket_is_closed(@self);
end;

function TGSocket.is_connected: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_socket_is_connected(@self);
end;

function TGSocket.join_multicast_group(group: PGInetAddress; source_specific: gboolean; iface: Pgchar; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_socket_join_multicast_group(@self, group, source_specific, iface, error);
end;

function TGSocket.join_multicast_group_ssm(group: PGInetAddress; source_specific: PGInetAddress; iface: Pgchar; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_socket_join_multicast_group_ssm(@self, group, source_specific, iface, error);
end;

function TGSocket.leave_multicast_group(group: PGInetAddress; source_specific: gboolean; iface: Pgchar; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_socket_leave_multicast_group(@self, group, source_specific, iface, error);
end;

function TGSocket.leave_multicast_group_ssm(group: PGInetAddress; source_specific: PGInetAddress; iface: Pgchar; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_socket_leave_multicast_group_ssm(@self, group, source_specific, iface, error);
end;

function TGSocket.listen(error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_socket_listen(@self, error);
end;

function TGSocket.receive(buffer: Pgchar; size: Pgsize; cancellable: PGCancellable; error: PPGError): gssize; cdecl;
begin
  Result := CastleInternalGio2.g_socket_receive(@self, buffer, size, cancellable, error);
end;

function TGSocket.receive_from(address: PPGSocketAddress; buffer: Pgchar; size: Pgsize; cancellable: PGCancellable; error: PPGError): gssize; cdecl;
begin
  Result := CastleInternalGio2.g_socket_receive_from(@self, address, buffer, size, cancellable, error);
end;

function TGSocket.receive_message(address: PPGSocketAddress; vectors: PGInputVector; num_vectors: gint; messages: PPPGSocketControlMessage; num_messages: Pgint; flags: Pgint; cancellable: PGCancellable; error: PPGError): gssize; cdecl;
begin
  Result := CastleInternalGio2.g_socket_receive_message(@self, address, vectors, num_vectors, messages, num_messages, flags, cancellable, error);
end;

function TGSocket.receive_messages(messages: PGInputMessage; num_messages: guint; flags: gint; cancellable: PGCancellable; error: PPGError): gint; cdecl;
begin
  Result := CastleInternalGio2.g_socket_receive_messages(@self, messages, num_messages, flags, cancellable, error);
end;

function TGSocket.receive_with_blocking(buffer: Pgchar; size: Pgsize; blocking: gboolean; cancellable: PGCancellable; error: PPGError): gssize; cdecl;
begin
  Result := CastleInternalGio2.g_socket_receive_with_blocking(@self, buffer, size, blocking, cancellable, error);
end;

function TGSocket.send(buffer: Pgchar; size: gsize; cancellable: PGCancellable; error: PPGError): gssize; cdecl;
begin
  Result := CastleInternalGio2.g_socket_send(@self, buffer, size, cancellable, error);
end;

function TGSocket.send_message(address: PGSocketAddress; vectors: PGOutputVector; num_vectors: gint; messages: PPGSocketControlMessage; num_messages: gint; flags: gint; cancellable: PGCancellable; error: PPGError): gssize; cdecl;
begin
  Result := CastleInternalGio2.g_socket_send_message(@self, address, vectors, num_vectors, messages, num_messages, flags, cancellable, error);
end;

function TGSocket.send_message_with_timeout(address: PGSocketAddress; vectors: PGOutputVector; num_vectors: gint; messages: PPGSocketControlMessage; num_messages: gint; flags: gint; timeout_us: gint64; bytes_written: Pgsize; cancellable: PGCancellable; error: PPGError): TGPollableReturn; cdecl;
begin
  Result := CastleInternalGio2.g_socket_send_message_with_timeout(@self, address, vectors, num_vectors, messages, num_messages, flags, timeout_us, bytes_written, cancellable, error);
end;

function TGSocket.send_messages(messages: PGOutputMessage; num_messages: guint; flags: gint; cancellable: PGCancellable; error: PPGError): gint; cdecl;
begin
  Result := CastleInternalGio2.g_socket_send_messages(@self, messages, num_messages, flags, cancellable, error);
end;

function TGSocket.send_to(address: PGSocketAddress; buffer: Pgchar; size: gsize; cancellable: PGCancellable; error: PPGError): gssize; cdecl;
begin
  Result := CastleInternalGio2.g_socket_send_to(@self, address, buffer, size, cancellable, error);
end;

function TGSocket.send_with_blocking(buffer: Pgchar; size: gsize; blocking: gboolean; cancellable: PGCancellable; error: PPGError): gssize; cdecl;
begin
  Result := CastleInternalGio2.g_socket_send_with_blocking(@self, buffer, size, blocking, cancellable, error);
end;

procedure TGSocket.set_blocking(blocking: gboolean); cdecl;
begin
  CastleInternalGio2.g_socket_set_blocking(@self, blocking);
end;

procedure TGSocket.set_broadcast(broadcast: gboolean); cdecl;
begin
  CastleInternalGio2.g_socket_set_broadcast(@self, broadcast);
end;

procedure TGSocket.set_keepalive(keepalive: gboolean); cdecl;
begin
  CastleInternalGio2.g_socket_set_keepalive(@self, keepalive);
end;

procedure TGSocket.set_listen_backlog(backlog: gint); cdecl;
begin
  CastleInternalGio2.g_socket_set_listen_backlog(@self, backlog);
end;

procedure TGSocket.set_multicast_loopback(loopback: gboolean); cdecl;
begin
  CastleInternalGio2.g_socket_set_multicast_loopback(@self, loopback);
end;

procedure TGSocket.set_multicast_ttl(ttl: guint); cdecl;
begin
  CastleInternalGio2.g_socket_set_multicast_ttl(@self, ttl);
end;

function TGSocket.set_option(level: gint; optname: gint; value: gint; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_socket_set_option(@self, level, optname, value, error);
end;

procedure TGSocket.set_timeout(timeout: guint); cdecl;
begin
  CastleInternalGio2.g_socket_set_timeout(@self, timeout);
end;

procedure TGSocket.set_ttl(ttl: guint); cdecl;
begin
  CastleInternalGio2.g_socket_set_ttl(@self, ttl);
end;

function TGSocket.shutdown(shutdown_read: gboolean; shutdown_write: gboolean; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_socket_shutdown(@self, shutdown_read, shutdown_write, error);
end;

function TGSocket.speaks_ipv4: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_socket_speaks_ipv4(@self);
end;

function TGSocketConnection.factory_lookup_type(family: TGSocketFamily; type_: TGSocketType; protocol_id: gint): TGType; cdecl;
begin
  Result := CastleInternalGio2.g_socket_connection_factory_lookup_type(family, type_, protocol_id);
end;

procedure TGSocketConnection.factory_register_type(g_type: TGType; family: TGSocketFamily; type_: TGSocketType; protocol: gint); cdecl;
begin
  CastleInternalGio2.g_socket_connection_factory_register_type(g_type, family, type_, protocol);
end;

function TGSocketConnection.connect(address: PGSocketAddress; cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_socket_connection_connect(@self, address, cancellable, error);
end;

procedure TGSocketConnection.connect_async(address: PGSocketAddress; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_socket_connection_connect_async(@self, address, cancellable, callback, user_data);
end;

function TGSocketConnection.connect_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_socket_connection_connect_finish(@self, result_, error);
end;

function TGSocketConnection.get_local_address(error: PPGError): PGSocketAddress; cdecl;
begin
  Result := CastleInternalGio2.g_socket_connection_get_local_address(@self, error);
end;

function TGSocketConnection.get_remote_address(error: PPGError): PGSocketAddress; cdecl;
begin
  Result := CastleInternalGio2.g_socket_connection_get_remote_address(@self, error);
end;

function TGSocketConnection.get_socket: PGSocket; cdecl;
begin
  Result := CastleInternalGio2.g_socket_connection_get_socket(@self);
end;

function TGSocketConnection.is_connected: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_socket_connection_is_connected(@self);
end;

function TGSocketClient.new: PGSocketClient; cdecl;
begin
  Result := CastleInternalGio2.g_socket_client_new();
end;

procedure TGSocketClient.add_application_proxy(protocol: Pgchar); cdecl;
begin
  CastleInternalGio2.g_socket_client_add_application_proxy(@self, protocol);
end;

function TGSocketClient.connect(connectable: PGSocketConnectable; cancellable: PGCancellable; error: PPGError): PGSocketConnection; cdecl;
begin
  Result := CastleInternalGio2.g_socket_client_connect(@self, connectable, cancellable, error);
end;

procedure TGSocketClient.connect_async(connectable: PGSocketConnectable; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_socket_client_connect_async(@self, connectable, cancellable, callback, user_data);
end;

function TGSocketClient.connect_finish(result_: PGAsyncResult; error: PPGError): PGSocketConnection; cdecl;
begin
  Result := CastleInternalGio2.g_socket_client_connect_finish(@self, result_, error);
end;

function TGSocketClient.connect_to_host(host_and_port: Pgchar; default_port: guint16; cancellable: PGCancellable; error: PPGError): PGSocketConnection; cdecl;
begin
  Result := CastleInternalGio2.g_socket_client_connect_to_host(@self, host_and_port, default_port, cancellable, error);
end;

procedure TGSocketClient.connect_to_host_async(host_and_port: Pgchar; default_port: guint16; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_socket_client_connect_to_host_async(@self, host_and_port, default_port, cancellable, callback, user_data);
end;

function TGSocketClient.connect_to_host_finish(result_: PGAsyncResult; error: PPGError): PGSocketConnection; cdecl;
begin
  Result := CastleInternalGio2.g_socket_client_connect_to_host_finish(@self, result_, error);
end;

function TGSocketClient.connect_to_service(domain: Pgchar; service: Pgchar; cancellable: PGCancellable; error: PPGError): PGSocketConnection; cdecl;
begin
  Result := CastleInternalGio2.g_socket_client_connect_to_service(@self, domain, service, cancellable, error);
end;

procedure TGSocketClient.connect_to_service_async(domain: Pgchar; service: Pgchar; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_socket_client_connect_to_service_async(@self, domain, service, cancellable, callback, user_data);
end;

function TGSocketClient.connect_to_service_finish(result_: PGAsyncResult; error: PPGError): PGSocketConnection; cdecl;
begin
  Result := CastleInternalGio2.g_socket_client_connect_to_service_finish(@self, result_, error);
end;

function TGSocketClient.connect_to_uri(uri: Pgchar; default_port: guint16; cancellable: PGCancellable; error: PPGError): PGSocketConnection; cdecl;
begin
  Result := CastleInternalGio2.g_socket_client_connect_to_uri(@self, uri, default_port, cancellable, error);
end;

procedure TGSocketClient.connect_to_uri_async(uri: Pgchar; default_port: guint16; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_socket_client_connect_to_uri_async(@self, uri, default_port, cancellable, callback, user_data);
end;

function TGSocketClient.connect_to_uri_finish(result_: PGAsyncResult; error: PPGError): PGSocketConnection; cdecl;
begin
  Result := CastleInternalGio2.g_socket_client_connect_to_uri_finish(@self, result_, error);
end;

function TGSocketClient.get_enable_proxy: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_socket_client_get_enable_proxy(@self);
end;

function TGSocketClient.get_family: TGSocketFamily; cdecl;
begin
  Result := CastleInternalGio2.g_socket_client_get_family(@self);
end;

function TGSocketClient.get_local_address: PGSocketAddress; cdecl;
begin
  Result := CastleInternalGio2.g_socket_client_get_local_address(@self);
end;

function TGSocketClient.get_protocol: TGSocketProtocol; cdecl;
begin
  Result := CastleInternalGio2.g_socket_client_get_protocol(@self);
end;

function TGSocketClient.get_proxy_resolver: PGProxyResolver; cdecl;
begin
  Result := CastleInternalGio2.g_socket_client_get_proxy_resolver(@self);
end;

function TGSocketClient.get_socket_type: TGSocketType; cdecl;
begin
  Result := CastleInternalGio2.g_socket_client_get_socket_type(@self);
end;

function TGSocketClient.get_timeout: guint; cdecl;
begin
  Result := CastleInternalGio2.g_socket_client_get_timeout(@self);
end;

function TGSocketClient.get_tls: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_socket_client_get_tls(@self);
end;

function TGSocketClient.get_tls_validation_flags: TGTlsCertificateFlags; cdecl;
begin
  Result := CastleInternalGio2.g_socket_client_get_tls_validation_flags(@self);
end;

procedure TGSocketClient.set_enable_proxy(enable: gboolean); cdecl;
begin
  CastleInternalGio2.g_socket_client_set_enable_proxy(@self, enable);
end;

procedure TGSocketClient.set_family(family: TGSocketFamily); cdecl;
begin
  CastleInternalGio2.g_socket_client_set_family(@self, family);
end;

procedure TGSocketClient.set_local_address(address: PGSocketAddress); cdecl;
begin
  CastleInternalGio2.g_socket_client_set_local_address(@self, address);
end;

procedure TGSocketClient.set_protocol(protocol: TGSocketProtocol); cdecl;
begin
  CastleInternalGio2.g_socket_client_set_protocol(@self, protocol);
end;

procedure TGSocketClient.set_proxy_resolver(proxy_resolver: PGProxyResolver); cdecl;
begin
  CastleInternalGio2.g_socket_client_set_proxy_resolver(@self, proxy_resolver);
end;

procedure TGSocketClient.set_socket_type(type_: TGSocketType); cdecl;
begin
  CastleInternalGio2.g_socket_client_set_socket_type(@self, type_);
end;

procedure TGSocketClient.set_timeout(timeout: guint); cdecl;
begin
  CastleInternalGio2.g_socket_client_set_timeout(@self, timeout);
end;

procedure TGSocketClient.set_tls(tls: gboolean); cdecl;
begin
  CastleInternalGio2.g_socket_client_set_tls(@self, tls);
end;

procedure TGSocketClient.set_tls_validation_flags(flags: TGTlsCertificateFlags); cdecl;
begin
  CastleInternalGio2.g_socket_client_set_tls_validation_flags(@self, flags);
end;

function TGSocketListener.new: PGSocketListener; cdecl;
begin
  Result := CastleInternalGio2.g_socket_listener_new();
end;

function TGSocketListener.accept(source_object: PPGObject; cancellable: PGCancellable; error: PPGError): PGSocketConnection; cdecl;
begin
  Result := CastleInternalGio2.g_socket_listener_accept(@self, source_object, cancellable, error);
end;

procedure TGSocketListener.accept_async(cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_socket_listener_accept_async(@self, cancellable, callback, user_data);
end;

function TGSocketListener.accept_finish(result_: PGAsyncResult; source_object: PPGObject; error: PPGError): PGSocketConnection; cdecl;
begin
  Result := CastleInternalGio2.g_socket_listener_accept_finish(@self, result_, source_object, error);
end;

function TGSocketListener.accept_socket(source_object: PPGObject; cancellable: PGCancellable; error: PPGError): PGSocket; cdecl;
begin
  Result := CastleInternalGio2.g_socket_listener_accept_socket(@self, source_object, cancellable, error);
end;

procedure TGSocketListener.accept_socket_async(cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_socket_listener_accept_socket_async(@self, cancellable, callback, user_data);
end;

function TGSocketListener.accept_socket_finish(result_: PGAsyncResult; source_object: PPGObject; error: PPGError): PGSocket; cdecl;
begin
  Result := CastleInternalGio2.g_socket_listener_accept_socket_finish(@self, result_, source_object, error);
end;

function TGSocketListener.add_address(address: PGSocketAddress; type_: TGSocketType; protocol: TGSocketProtocol; source_object: PGObject; effective_address: PPGSocketAddress; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_socket_listener_add_address(@self, address, type_, protocol, source_object, effective_address, error);
end;

function TGSocketListener.add_any_inet_port(source_object: PGObject; error: PPGError): guint16; cdecl;
begin
  Result := CastleInternalGio2.g_socket_listener_add_any_inet_port(@self, source_object, error);
end;

function TGSocketListener.add_inet_port(port: guint16; source_object: PGObject; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_socket_listener_add_inet_port(@self, port, source_object, error);
end;

function TGSocketListener.add_socket(socket: PGSocket; source_object: PGObject; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_socket_listener_add_socket(@self, socket, source_object, error);
end;

procedure TGSocketListener.close; cdecl;
begin
  CastleInternalGio2.g_socket_listener_close(@self);
end;

procedure TGSocketListener.set_backlog(listen_backlog: gint); cdecl;
begin
  CastleInternalGio2.g_socket_listener_set_backlog(@self, listen_backlog);
end;

function TGSocketService.new: PGSocketService; cdecl;
begin
  Result := CastleInternalGio2.g_socket_service_new();
end;

function TGSocketService.is_active: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_socket_service_is_active(@self);
end;

procedure TGSocketService.start; cdecl;
begin
  CastleInternalGio2.g_socket_service_start(@self);
end;

procedure TGSocketService.stop; cdecl;
begin
  CastleInternalGio2.g_socket_service_stop(@self);
end;

function TGSrvTarget.new(hostname: Pgchar; port: guint16; priority: guint16; weight: guint16): PGSrvTarget; cdecl;
begin
  Result := CastleInternalGio2.g_srv_target_new(hostname, port, priority, weight);
end;

function TGSrvTarget.copy: PGSrvTarget; cdecl;
begin
  Result := CastleInternalGio2.g_srv_target_copy(@self);
end;

procedure TGSrvTarget.free; cdecl;
begin
  CastleInternalGio2.g_srv_target_free(@self);
end;

function TGSrvTarget.get_hostname: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_srv_target_get_hostname(@self);
end;

function TGSrvTarget.get_port: guint16; cdecl;
begin
  Result := CastleInternalGio2.g_srv_target_get_port(@self);
end;

function TGSrvTarget.get_priority: guint16; cdecl;
begin
  Result := CastleInternalGio2.g_srv_target_get_priority(@self);
end;

function TGSrvTarget.get_weight: guint16; cdecl;
begin
  Result := CastleInternalGio2.g_srv_target_get_weight(@self);
end;

function TGSrvTarget.list_sort(targets: PGList): PGList; cdecl;
begin
  Result := CastleInternalGio2.g_srv_target_list_sort(targets);
end;

procedure TGStaticResource.fini; cdecl;
begin
  CastleInternalGio2.g_static_resource_fini(@self);
end;

function TGStaticResource.get_resource: PGResource; cdecl;
begin
  Result := CastleInternalGio2.g_static_resource_get_resource(@self);
end;

procedure TGStaticResource.init; cdecl;
begin
  CastleInternalGio2.g_static_resource_init(@self);
end;

function TGSubprocess.newv(argv: PPgchar; flags: TGSubprocessFlags; error: PPGError): PGSubprocess; cdecl;
begin
  Result := CastleInternalGio2.g_subprocess_newv(argv, flags, error);
end;

function TGSubprocess.communicate(stdin_buf: PGBytes; cancellable: PGCancellable; stdout_buf: PPGBytes; stderr_buf: PPGBytes; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_subprocess_communicate(@self, stdin_buf, cancellable, stdout_buf, stderr_buf, error);
end;

procedure TGSubprocess.communicate_async(stdin_buf: PGBytes; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_subprocess_communicate_async(@self, stdin_buf, cancellable, callback, user_data);
end;

function TGSubprocess.communicate_finish(result_: PGAsyncResult; stdout_buf: PPGBytes; stderr_buf: PPGBytes; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_subprocess_communicate_finish(@self, result_, stdout_buf, stderr_buf, error);
end;

function TGSubprocess.communicate_utf8(stdin_buf: Pgchar; cancellable: PGCancellable; stdout_buf: PPgchar; stderr_buf: PPgchar; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_subprocess_communicate_utf8(@self, stdin_buf, cancellable, stdout_buf, stderr_buf, error);
end;

procedure TGSubprocess.communicate_utf8_async(stdin_buf: Pgchar; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_subprocess_communicate_utf8_async(@self, stdin_buf, cancellable, callback, user_data);
end;

function TGSubprocess.communicate_utf8_finish(result_: PGAsyncResult; stdout_buf: PPgchar; stderr_buf: PPgchar; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_subprocess_communicate_utf8_finish(@self, result_, stdout_buf, stderr_buf, error);
end;

procedure TGSubprocess.force_exit; cdecl;
begin
  CastleInternalGio2.g_subprocess_force_exit(@self);
end;

function TGSubprocess.get_exit_status: gint; cdecl;
begin
  Result := CastleInternalGio2.g_subprocess_get_exit_status(@self);
end;

function TGSubprocess.get_identifier: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_subprocess_get_identifier(@self);
end;

function TGSubprocess.get_if_exited: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_subprocess_get_if_exited(@self);
end;

function TGSubprocess.get_if_signaled: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_subprocess_get_if_signaled(@self);
end;

function TGSubprocess.get_status: gint; cdecl;
begin
  Result := CastleInternalGio2.g_subprocess_get_status(@self);
end;

function TGSubprocess.get_stderr_pipe: PGInputStream; cdecl;
begin
  Result := CastleInternalGio2.g_subprocess_get_stderr_pipe(@self);
end;

function TGSubprocess.get_stdin_pipe: PGOutputStream; cdecl;
begin
  Result := CastleInternalGio2.g_subprocess_get_stdin_pipe(@self);
end;

function TGSubprocess.get_stdout_pipe: PGInputStream; cdecl;
begin
  Result := CastleInternalGio2.g_subprocess_get_stdout_pipe(@self);
end;

function TGSubprocess.get_successful: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_subprocess_get_successful(@self);
end;

function TGSubprocess.get_term_sig: gint; cdecl;
begin
  Result := CastleInternalGio2.g_subprocess_get_term_sig(@self);
end;

procedure TGSubprocess.send_signal(signal_num: gint); cdecl;
begin
  CastleInternalGio2.g_subprocess_send_signal(@self, signal_num);
end;

function TGSubprocess.wait(cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_subprocess_wait(@self, cancellable, error);
end;

procedure TGSubprocess.wait_async(cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_subprocess_wait_async(@self, cancellable, callback, user_data);
end;

function TGSubprocess.wait_check(cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_subprocess_wait_check(@self, cancellable, error);
end;

procedure TGSubprocess.wait_check_async(cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_subprocess_wait_check_async(@self, cancellable, callback, user_data);
end;

function TGSubprocess.wait_check_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_subprocess_wait_check_finish(@self, result_, error);
end;

function TGSubprocess.wait_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_subprocess_wait_finish(@self, result_, error);
end;

function TGSubprocessLauncher.new(flags: TGSubprocessFlags): PGSubprocessLauncher; cdecl;
begin
  Result := CastleInternalGio2.g_subprocess_launcher_new(flags);
end;

function TGSubprocessLauncher.getenv(variable: Pgchar): Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_subprocess_launcher_getenv(@self, variable);
end;

procedure TGSubprocessLauncher.set_child_setup(child_setup: TGSpawnChildSetupFunc; user_data: gpointer; destroy_notify: TGDestroyNotify); cdecl;
begin
  CastleInternalGio2.g_subprocess_launcher_set_child_setup(@self, child_setup, user_data, destroy_notify);
end;

procedure TGSubprocessLauncher.set_cwd(cwd: Pgchar); cdecl;
begin
  CastleInternalGio2.g_subprocess_launcher_set_cwd(@self, cwd);
end;

procedure TGSubprocessLauncher.set_environ(env: PPgchar); cdecl;
begin
  CastleInternalGio2.g_subprocess_launcher_set_environ(@self, env);
end;

procedure TGSubprocessLauncher.set_flags(flags: TGSubprocessFlags); cdecl;
begin
  CastleInternalGio2.g_subprocess_launcher_set_flags(@self, flags);
end;

procedure TGSubprocessLauncher.set_stderr_file_path(path: Pgchar); cdecl;
begin
  CastleInternalGio2.g_subprocess_launcher_set_stderr_file_path(@self, path);
end;

procedure TGSubprocessLauncher.set_stdin_file_path(path: Pgchar); cdecl;
begin
  CastleInternalGio2.g_subprocess_launcher_set_stdin_file_path(@self, path);
end;

procedure TGSubprocessLauncher.set_stdout_file_path(path: Pgchar); cdecl;
begin
  CastleInternalGio2.g_subprocess_launcher_set_stdout_file_path(@self, path);
end;

procedure TGSubprocessLauncher.setenv(variable: Pgchar; value: Pgchar; overwrite: gboolean); cdecl;
begin
  CastleInternalGio2.g_subprocess_launcher_setenv(@self, variable, value, overwrite);
end;

function TGSubprocessLauncher.spawnv(argv: PPgchar; error: PPGError): PGSubprocess; cdecl;
begin
  Result := CastleInternalGio2.g_subprocess_launcher_spawnv(@self, argv, error);
end;

procedure TGSubprocessLauncher.take_fd(source_fd: gint; target_fd: gint); cdecl;
begin
  CastleInternalGio2.g_subprocess_launcher_take_fd(@self, source_fd, target_fd);
end;

procedure TGSubprocessLauncher.take_stderr_fd(fd: gint); cdecl;
begin
  CastleInternalGio2.g_subprocess_launcher_take_stderr_fd(@self, fd);
end;

procedure TGSubprocessLauncher.take_stdin_fd(fd: gint); cdecl;
begin
  CastleInternalGio2.g_subprocess_launcher_take_stdin_fd(@self, fd);
end;

procedure TGSubprocessLauncher.take_stdout_fd(fd: gint); cdecl;
begin
  CastleInternalGio2.g_subprocess_launcher_take_stdout_fd(@self, fd);
end;

procedure TGSubprocessLauncher.unsetenv(variable: Pgchar); cdecl;
begin
  CastleInternalGio2.g_subprocess_launcher_unsetenv(@self, variable);
end;

function TGTask.new(source_object: PGObject; cancellable: PGCancellable; callback: TGAsyncReadyCallback; callback_data: gpointer): PGTask; cdecl;
begin
  Result := CastleInternalGio2.g_task_new(source_object, cancellable, callback, callback_data);
end;

function TGTask.is_valid(result_: PGAsyncResult; source_object: PGObject): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_task_is_valid(result_, source_object);
end;

procedure TGTask.report_error(source_object: PGObject; callback: TGAsyncReadyCallback; callback_data: gpointer; source_tag: gpointer; error: PGError); cdecl;
begin
  CastleInternalGio2.g_task_report_error(source_object, callback, callback_data, source_tag, error);
end;

procedure TGTask.attach_source(source: PGSource; callback: TGSourceFunc); cdecl;
begin
  CastleInternalGio2.g_task_attach_source(@self, source, callback);
end;

function TGTask.get_cancellable: PGCancellable; cdecl;
begin
  Result := CastleInternalGio2.g_task_get_cancellable(@self);
end;

function TGTask.get_check_cancellable: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_task_get_check_cancellable(@self);
end;

function TGTask.get_completed: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_task_get_completed(@self);
end;

function TGTask.get_context: PGMainContext; cdecl;
begin
  Result := CastleInternalGio2.g_task_get_context(@self);
end;

function TGTask.get_name: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_task_get_name(@self);
end;

function TGTask.get_priority: gint; cdecl;
begin
  Result := CastleInternalGio2.g_task_get_priority(@self);
end;

function TGTask.get_return_on_cancel: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_task_get_return_on_cancel(@self);
end;

function TGTask.get_source_object: PGObject; cdecl;
begin
  Result := CastleInternalGio2.g_task_get_source_object(@self);
end;

function TGTask.get_source_tag: gpointer; cdecl;
begin
  Result := CastleInternalGio2.g_task_get_source_tag(@self);
end;

function TGTask.get_task_data: gpointer; cdecl;
begin
  Result := CastleInternalGio2.g_task_get_task_data(@self);
end;

function TGTask.had_error: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_task_had_error(@self);
end;

function TGTask.propagate_boolean(error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_task_propagate_boolean(@self, error);
end;

function TGTask.propagate_int(error: PPGError): gssize; cdecl;
begin
  Result := CastleInternalGio2.g_task_propagate_int(@self, error);
end;

function TGTask.propagate_pointer(error: PPGError): gpointer; cdecl;
begin
  Result := CastleInternalGio2.g_task_propagate_pointer(@self, error);
end;

function TGTask.propagate_value(value: PGValue; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_task_propagate_value(@self, value, error);
end;

procedure TGTask.return_boolean(result_: gboolean); cdecl;
begin
  CastleInternalGio2.g_task_return_boolean(@self, result_);
end;

procedure TGTask.return_error(error: PGError); cdecl;
begin
  CastleInternalGio2.g_task_return_error(@self, error);
end;

function TGTask.return_error_if_cancelled: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_task_return_error_if_cancelled(@self);
end;

procedure TGTask.return_int(result_: gssize); cdecl;
begin
  CastleInternalGio2.g_task_return_int(@self, result_);
end;

procedure TGTask.return_pointer(result_: gpointer; result_destroy: TGDestroyNotify); cdecl;
begin
  CastleInternalGio2.g_task_return_pointer(@self, result_, result_destroy);
end;

procedure TGTask.return_value(result_: PGValue); cdecl;
begin
  CastleInternalGio2.g_task_return_value(@self, result_);
end;

procedure TGTask.run_in_thread(task_func: TGTaskThreadFunc); cdecl;
begin
  CastleInternalGio2.g_task_run_in_thread(@self, task_func);
end;

procedure TGTask.run_in_thread_sync(task_func: TGTaskThreadFunc); cdecl;
begin
  CastleInternalGio2.g_task_run_in_thread_sync(@self, task_func);
end;

procedure TGTask.set_check_cancellable(check_cancellable: gboolean); cdecl;
begin
  CastleInternalGio2.g_task_set_check_cancellable(@self, check_cancellable);
end;

procedure TGTask.set_name(name: Pgchar); cdecl;
begin
  CastleInternalGio2.g_task_set_name(@self, name);
end;

procedure TGTask.set_priority(priority: gint); cdecl;
begin
  CastleInternalGio2.g_task_set_priority(@self, priority);
end;

function TGTask.set_return_on_cancel(return_on_cancel: gboolean): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_task_set_return_on_cancel(@self, return_on_cancel);
end;

procedure TGTask.set_source_tag(source_tag: gpointer); cdecl;
begin
  CastleInternalGio2.g_task_set_source_tag(@self, source_tag);
end;

procedure TGTask.set_task_data(task_data: gpointer; task_data_destroy: TGDestroyNotify); cdecl;
begin
  CastleInternalGio2.g_task_set_task_data(@self, task_data, task_data_destroy);
end;

function TGTcpConnection.get_graceful_disconnect: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_tcp_connection_get_graceful_disconnect(@self);
end;

procedure TGTcpConnection.set_graceful_disconnect(graceful_disconnect: gboolean); cdecl;
begin
  CastleInternalGio2.g_tcp_connection_set_graceful_disconnect(@self, graceful_disconnect);
end;

function TGTcpWrapperConnection.new(base_io_stream: PGIOStream; socket: PGSocket): PGTcpWrapperConnection; cdecl;
begin
  Result := CastleInternalGio2.g_tcp_wrapper_connection_new(base_io_stream, socket);
end;

function TGTcpWrapperConnection.get_base_io_stream: PGIOStream; cdecl;
begin
  Result := CastleInternalGio2.g_tcp_wrapper_connection_get_base_io_stream(@self);
end;

function TGTestDBus.new(flags: TGTestDBusFlags): PGTestDBus; cdecl;
begin
  Result := CastleInternalGio2.g_test_dbus_new(flags);
end;

procedure TGTestDBus.unset; cdecl;
begin
  CastleInternalGio2.g_test_dbus_unset();
end;

procedure TGTestDBus.add_service_dir(path: Pgchar); cdecl;
begin
  CastleInternalGio2.g_test_dbus_add_service_dir(@self, path);
end;

procedure TGTestDBus.down; cdecl;
begin
  CastleInternalGio2.g_test_dbus_down(@self);
end;

function TGTestDBus.get_bus_address: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_test_dbus_get_bus_address(@self);
end;

function TGTestDBus.get_flags: TGTestDBusFlags; cdecl;
begin
  Result := CastleInternalGio2.g_test_dbus_get_flags(@self);
end;

procedure TGTestDBus.stop; cdecl;
begin
  CastleInternalGio2.g_test_dbus_stop(@self);
end;

procedure TGTestDBus.up; cdecl;
begin
  CastleInternalGio2.g_test_dbus_up(@self);
end;

function TGThemedIcon.new(iconname: Pgchar): PGThemedIcon; cdecl;
begin
  Result := CastleInternalGio2.g_themed_icon_new(iconname);
end;

function TGThemedIcon.new_from_names(iconnames: PPgchar; len: gint): PGThemedIcon; cdecl;
begin
  Result := CastleInternalGio2.g_themed_icon_new_from_names(iconnames, len);
end;

function TGThemedIcon.new_with_default_fallbacks(iconname: Pgchar): PGThemedIcon; cdecl;
begin
  Result := CastleInternalGio2.g_themed_icon_new_with_default_fallbacks(iconname);
end;

procedure TGThemedIcon.append_name(iconname: Pgchar); cdecl;
begin
  CastleInternalGio2.g_themed_icon_append_name(@self, iconname);
end;

function TGThemedIcon.get_names: PPgchar; cdecl;
begin
  Result := CastleInternalGio2.g_themed_icon_get_names(@self);
end;

procedure TGThemedIcon.prepend_name(iconname: Pgchar); cdecl;
begin
  CastleInternalGio2.g_themed_icon_prepend_name(@self, iconname);
end;

function TGThreadedSocketService.new(max_threads: gint): PGThreadedSocketService; cdecl;
begin
  Result := CastleInternalGio2.g_threaded_socket_service_new(max_threads);
end;

function TGTlsBackend.get_default: PGTlsBackend; cdecl;
begin
  Result := CastleInternalGio2.g_tls_backend_get_default();
end;

function TGTlsBackend.get_certificate_type: TGType; cdecl;
begin
  Result := CastleInternalGio2.g_tls_backend_get_certificate_type(@self);
end;

function TGTlsBackend.get_client_connection_type: TGType; cdecl;
begin
  Result := CastleInternalGio2.g_tls_backend_get_client_connection_type(@self);
end;

function TGTlsBackend.get_default_database: PGTlsDatabase; cdecl;
begin
  Result := CastleInternalGio2.g_tls_backend_get_default_database(@self);
end;

function TGTlsBackend.get_dtls_client_connection_type: TGType; cdecl;
begin
  Result := CastleInternalGio2.g_tls_backend_get_dtls_client_connection_type(@self);
end;

function TGTlsBackend.get_dtls_server_connection_type: TGType; cdecl;
begin
  Result := CastleInternalGio2.g_tls_backend_get_dtls_server_connection_type(@self);
end;

function TGTlsBackend.get_file_database_type: TGType; cdecl;
begin
  Result := CastleInternalGio2.g_tls_backend_get_file_database_type(@self);
end;

function TGTlsBackend.get_server_connection_type: TGType; cdecl;
begin
  Result := CastleInternalGio2.g_tls_backend_get_server_connection_type(@self);
end;

procedure TGTlsBackend.set_default_database(database: PGTlsDatabase); cdecl;
begin
  CastleInternalGio2.g_tls_backend_set_default_database(@self, database);
end;

function TGTlsBackend.supports_dtls: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_tls_backend_supports_dtls(@self);
end;

function TGTlsBackend.supports_tls: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_tls_backend_supports_tls(@self);
end;

function TGTlsClientConnection.new(base_io_stream: PGIOStream; server_identity: PGSocketConnectable; error: PPGError): PGTlsClientConnection; cdecl;
begin
  Result := CastleInternalGio2.g_tls_client_connection_new(base_io_stream, server_identity, error);
end;

procedure TGTlsClientConnection.copy_session_state(source: PGTlsClientConnection); cdecl;
begin
  CastleInternalGio2.g_tls_client_connection_copy_session_state(@self, source);
end;

function TGTlsClientConnection.get_accepted_cas: PGList; cdecl;
begin
  Result := CastleInternalGio2.g_tls_client_connection_get_accepted_cas(@self);
end;

function TGTlsClientConnection.get_server_identity: PGSocketConnectable; cdecl;
begin
  Result := CastleInternalGio2.g_tls_client_connection_get_server_identity(@self);
end;

function TGTlsClientConnection.get_validation_flags: TGTlsCertificateFlags; cdecl;
begin
  Result := CastleInternalGio2.g_tls_client_connection_get_validation_flags(@self);
end;

procedure TGTlsClientConnection.set_server_identity(identity: PGSocketConnectable); cdecl;
begin
  CastleInternalGio2.g_tls_client_connection_set_server_identity(@self, identity);
end;

procedure TGTlsClientConnection.set_validation_flags(flags: TGTlsCertificateFlags); cdecl;
begin
  CastleInternalGio2.g_tls_client_connection_set_validation_flags(@self, flags);
end;

function TGTlsConnection.emit_accept_certificate(peer_cert: PGTlsCertificate; errors: TGTlsCertificateFlags): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_tls_connection_emit_accept_certificate(@self, peer_cert, errors);
end;

function TGTlsConnection.get_certificate: PGTlsCertificate; cdecl;
begin
  Result := CastleInternalGio2.g_tls_connection_get_certificate(@self);
end;

{$IFDEF USEGTK3LATESTBINDINGS}
function TGTlsConnection.get_channel_binding_data(type_: TGTlsChannelBindingType; data: Pguint8; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_tls_connection_get_channel_binding_data(@self, type_, data, error);
end;
{$ENDIF}

function TGTlsConnection.get_database: PGTlsDatabase; cdecl;
begin
  Result := CastleInternalGio2.g_tls_connection_get_database(@self);
end;

function TGTlsConnection.get_interaction: PGTlsInteraction; cdecl;
begin
  Result := CastleInternalGio2.g_tls_connection_get_interaction(@self);
end;

function TGTlsConnection.get_negotiated_protocol: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_tls_connection_get_negotiated_protocol(@self);
end;

function TGTlsConnection.get_peer_certificate: PGTlsCertificate; cdecl;
begin
  Result := CastleInternalGio2.g_tls_connection_get_peer_certificate(@self);
end;

function TGTlsConnection.get_peer_certificate_errors: TGTlsCertificateFlags; cdecl;
begin
  Result := CastleInternalGio2.g_tls_connection_get_peer_certificate_errors(@self);
end;

function TGTlsConnection.get_require_close_notify: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_tls_connection_get_require_close_notify(@self);
end;

function TGTlsConnection.handshake(cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_tls_connection_handshake(@self, cancellable, error);
end;

procedure TGTlsConnection.handshake_async(io_priority: gint; cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_tls_connection_handshake_async(@self, io_priority, cancellable, callback, user_data);
end;

function TGTlsConnection.handshake_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_tls_connection_handshake_finish(@self, result_, error);
end;

procedure TGTlsConnection.set_advertised_protocols(protocols: PPgchar); cdecl;
begin
  CastleInternalGio2.g_tls_connection_set_advertised_protocols(@self, protocols);
end;

procedure TGTlsConnection.set_certificate(certificate: PGTlsCertificate); cdecl;
begin
  CastleInternalGio2.g_tls_connection_set_certificate(@self, certificate);
end;

procedure TGTlsConnection.set_database(database: PGTlsDatabase); cdecl;
begin
  CastleInternalGio2.g_tls_connection_set_database(@self, database);
end;

procedure TGTlsConnection.set_interaction(interaction: PGTlsInteraction); cdecl;
begin
  CastleInternalGio2.g_tls_connection_set_interaction(@self, interaction);
end;

procedure TGTlsConnection.set_require_close_notify(require_close_notify: gboolean); cdecl;
begin
  CastleInternalGio2.g_tls_connection_set_require_close_notify(@self, require_close_notify);
end;

function TGTlsFileDatabase.new(anchors: Pgchar; error: PPGError): PGTlsFileDatabase; cdecl;
begin
  Result := CastleInternalGio2.g_tls_file_database_new(anchors, error);
end;

function TGTlsPassword.new(flags: TGTlsPasswordFlags; description: Pgchar): PGTlsPassword; cdecl;
begin
  Result := CastleInternalGio2.g_tls_password_new(flags, description);
end;

function TGTlsPassword.get_description: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_tls_password_get_description(@self);
end;

function TGTlsPassword.get_flags: TGTlsPasswordFlags; cdecl;
begin
  Result := CastleInternalGio2.g_tls_password_get_flags(@self);
end;

function TGTlsPassword.get_value(length: Pgsize): Pguint8; cdecl;
begin
  Result := CastleInternalGio2.g_tls_password_get_value(@self, length);
end;

function TGTlsPassword.get_warning: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_tls_password_get_warning(@self);
end;

procedure TGTlsPassword.set_description(description: Pgchar); cdecl;
begin
  CastleInternalGio2.g_tls_password_set_description(@self, description);
end;

procedure TGTlsPassword.set_flags(flags: TGTlsPasswordFlags); cdecl;
begin
  CastleInternalGio2.g_tls_password_set_flags(@self, flags);
end;

procedure TGTlsPassword.set_value(value: Pguint8; length: gssize); cdecl;
begin
  CastleInternalGio2.g_tls_password_set_value(@self, value, length);
end;

procedure TGTlsPassword.set_value_full(value: Pguint8; length: gssize; destroy_: TGDestroyNotify); cdecl;
begin
  CastleInternalGio2.g_tls_password_set_value_full(@self, value, length, destroy_);
end;

procedure TGTlsPassword.set_warning(warning: Pgchar); cdecl;
begin
  CastleInternalGio2.g_tls_password_set_warning(@self, warning);
end;

function TGTlsServerConnection.new(base_io_stream: PGIOStream; certificate: PGTlsCertificate; error: PPGError): PGTlsServerConnection; cdecl;
begin
  Result := CastleInternalGio2.g_tls_server_connection_new(base_io_stream, certificate, error);
end;

function TGUnixConnection.receive_credentials(cancellable: PGCancellable; error: PPGError): PGCredentials; cdecl;
begin
  Result := CastleInternalGio2.g_unix_connection_receive_credentials(@self, cancellable, error);
end;

procedure TGUnixConnection.receive_credentials_async(cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_unix_connection_receive_credentials_async(@self, cancellable, callback, user_data);
end;

function TGUnixConnection.receive_credentials_finish(result_: PGAsyncResult; error: PPGError): PGCredentials; cdecl;
begin
  Result := CastleInternalGio2.g_unix_connection_receive_credentials_finish(@self, result_, error);
end;

function TGUnixConnection.receive_fd(cancellable: PGCancellable; error: PPGError): gint; cdecl;
begin
  Result := CastleInternalGio2.g_unix_connection_receive_fd(@self, cancellable, error);
end;

function TGUnixConnection.send_credentials(cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_unix_connection_send_credentials(@self, cancellable, error);
end;

procedure TGUnixConnection.send_credentials_async(cancellable: PGCancellable; callback: TGAsyncReadyCallback; user_data: gpointer); cdecl;
begin
  CastleInternalGio2.g_unix_connection_send_credentials_async(@self, cancellable, callback, user_data);
end;

function TGUnixConnection.send_credentials_finish(result_: PGAsyncResult; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_unix_connection_send_credentials_finish(@self, result_, error);
end;

function TGUnixConnection.send_fd(fd: gint; cancellable: PGCancellable; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_unix_connection_send_fd(@self, fd, cancellable, error);
end;

function TGUnixCredentialsMessage.new: PGUnixCredentialsMessage; cdecl;
begin
  Result := CastleInternalGio2.g_unix_credentials_message_new();
end;

function TGUnixCredentialsMessage.new_with_credentials(credentials: PGCredentials): PGUnixCredentialsMessage; cdecl;
begin
  Result := CastleInternalGio2.g_unix_credentials_message_new_with_credentials(credentials);
end;

function TGUnixCredentialsMessage.is_supported: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_unix_credentials_message_is_supported();
end;

function TGUnixCredentialsMessage.get_credentials: PGCredentials; cdecl;
begin
  Result := CastleInternalGio2.g_unix_credentials_message_get_credentials(@self);
end;

function TGUnixFDMessage.new: PGUnixFDMessage; cdecl;
begin
  Result := CastleInternalGio2.g_unix_fd_message_new();
end;

function TGUnixFDMessage.new_with_fd_list(fd_list: PGUnixFDList): PGUnixFDMessage; cdecl;
begin
  Result := CastleInternalGio2.g_unix_fd_message_new_with_fd_list(fd_list);
end;

function TGUnixFDMessage.append_fd(fd: gint; error: PPGError): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_unix_fd_message_append_fd(@self, fd, error);
end;

function TGUnixFDMessage.get_fd_list: PGUnixFDList; cdecl;
begin
  Result := CastleInternalGio2.g_unix_fd_message_get_fd_list(@self);
end;

function TGUnixFDMessage.steal_fds(length: Pgint): Pgint; cdecl;
begin
  Result := CastleInternalGio2.g_unix_fd_message_steal_fds(@self, length);
end;

function TGUnixInputStream.new(fd: gint; close_fd: gboolean): PGUnixInputStream; cdecl;
begin
  Result := CastleInternalGio2.g_unix_input_stream_new(fd, close_fd);
end;

function TGUnixInputStream.get_close_fd: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_unix_input_stream_get_close_fd(@self);
end;

function TGUnixInputStream.get_fd: gint; cdecl;
begin
  Result := CastleInternalGio2.g_unix_input_stream_get_fd(@self);
end;

procedure TGUnixInputStream.set_close_fd(close_fd: gboolean); cdecl;
begin
  CastleInternalGio2.g_unix_input_stream_set_close_fd(@self, close_fd);
end;

function TGUnixMountMonitor.get: PGUnixMountMonitor; cdecl;
begin
  Result := CastleInternalGio2.g_unix_mount_monitor_get();
end;

function TGUnixMountPoint.compare(mount2: PGUnixMountPoint): gint; cdecl;
begin
  Result := CastleInternalGio2.g_unix_mount_point_compare(@self, mount2);
end;

function TGUnixMountPoint.copy: PGUnixMountPoint; cdecl;
begin
  Result := CastleInternalGio2.g_unix_mount_point_copy(@self);
end;

procedure TGUnixMountPoint.free; cdecl;
begin
  CastleInternalGio2.g_unix_mount_point_free(@self);
end;

function TGUnixMountPoint.get_device_path: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_unix_mount_point_get_device_path(@self);
end;

function TGUnixMountPoint.get_fs_type: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_unix_mount_point_get_fs_type(@self);
end;

function TGUnixMountPoint.get_mount_path: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_unix_mount_point_get_mount_path(@self);
end;

function TGUnixMountPoint.get_options: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_unix_mount_point_get_options(@self);
end;

function TGUnixMountPoint.guess_can_eject: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_unix_mount_point_guess_can_eject(@self);
end;

function TGUnixMountPoint.guess_icon: PGIcon; cdecl;
begin
  Result := CastleInternalGio2.g_unix_mount_point_guess_icon(@self);
end;

function TGUnixMountPoint.guess_name: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_unix_mount_point_guess_name(@self);
end;

function TGUnixMountPoint.guess_symbolic_icon: PGIcon; cdecl;
begin
  Result := CastleInternalGio2.g_unix_mount_point_guess_symbolic_icon(@self);
end;

function TGUnixMountPoint.is_loopback: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_unix_mount_point_is_loopback(@self);
end;

function TGUnixMountPoint.is_readonly: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_unix_mount_point_is_readonly(@self);
end;

function TGUnixMountPoint.is_user_mountable: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_unix_mount_point_is_user_mountable(@self);
end;

{$IFDEF USEGTK3LATESTBINDINGS}
function TGUnixMountPoint.at(mount_path: Pgchar; time_read: Pguint64): PGUnixMountPoint; cdecl;
begin
  Result := CastleInternalGio2.g_unix_mount_point_at(mount_path, time_read);
end;
{$ENDIF}

function TGUnixOutputStream.new(fd: gint; close_fd: gboolean): PGUnixOutputStream; cdecl;
begin
  Result := CastleInternalGio2.g_unix_output_stream_new(fd, close_fd);
end;

function TGUnixOutputStream.get_close_fd: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_unix_output_stream_get_close_fd(@self);
end;

function TGUnixOutputStream.get_fd: gint; cdecl;
begin
  Result := CastleInternalGio2.g_unix_output_stream_get_fd(@self);
end;

procedure TGUnixOutputStream.set_close_fd(close_fd: gboolean); cdecl;
begin
  CastleInternalGio2.g_unix_output_stream_set_close_fd(@self, close_fd);
end;

function TGUnixSocketAddress.new(path: Pgchar): PGUnixSocketAddress; cdecl;
begin
  Result := CastleInternalGio2.g_unix_socket_address_new(path);
end;

function TGUnixSocketAddress.new_with_type(path: Pgchar; path_len: gint; type_: TGUnixSocketAddressType): PGUnixSocketAddress; cdecl;
begin
  Result := CastleInternalGio2.g_unix_socket_address_new_with_type(path, path_len, type_);
end;

function TGUnixSocketAddress.abstract_names_supported: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_unix_socket_address_abstract_names_supported();
end;

function TGUnixSocketAddress.get_address_type: TGUnixSocketAddressType; cdecl;
begin
  Result := CastleInternalGio2.g_unix_socket_address_get_address_type(@self);
end;

function TGUnixSocketAddress.get_path: Pgchar; cdecl;
begin
  Result := CastleInternalGio2.g_unix_socket_address_get_path(@self);
end;

function TGUnixSocketAddress.get_path_len: gsize; cdecl;
begin
  Result := CastleInternalGio2.g_unix_socket_address_get_path_len(@self);
end;

function TGVfs.get_default: PGVfs; cdecl;
begin
  Result := CastleInternalGio2.g_vfs_get_default();
end;

function TGVfs.get_local: PGVfs; cdecl;
begin
  Result := CastleInternalGio2.g_vfs_get_local();
end;

function TGVfs.get_file_for_path(path: Pgchar): PGFile; cdecl;
begin
  Result := CastleInternalGio2.g_vfs_get_file_for_path(@self, path);
end;

function TGVfs.get_file_for_uri(uri: Pgchar): PGFile; cdecl;
begin
  Result := CastleInternalGio2.g_vfs_get_file_for_uri(@self, uri);
end;

function TGVfs.get_supported_uri_schemes: PPgchar; cdecl;
begin
  Result := CastleInternalGio2.g_vfs_get_supported_uri_schemes(@self);
end;

function TGVfs.is_active: gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_vfs_is_active(@self);
end;

function TGVfs.parse_name(parse_name: Pgchar): PGFile; cdecl;
begin
  Result := CastleInternalGio2.g_vfs_parse_name(@self, parse_name);
end;

function TGVfs.register_uri_scheme(scheme: Pgchar; uri_func: TGVfsFileLookupFunc; uri_data: gpointer; uri_destroy: TGDestroyNotify; parse_name_func: TGVfsFileLookupFunc; parse_name_data: gpointer; parse_name_destroy: TGDestroyNotify): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_vfs_register_uri_scheme(@self, scheme, uri_func, uri_data, uri_destroy, parse_name_func, parse_name_data, parse_name_destroy);
end;

function TGVfs.unregister_uri_scheme(scheme: Pgchar): gboolean; cdecl;
begin
  Result := CastleInternalGio2.g_vfs_unregister_uri_scheme(@self, scheme);
end;

function TGZlibCompressor.new(format: TGZlibCompressorFormat; level: gint): PGZlibCompressor; cdecl;
begin
  Result := CastleInternalGio2.g_zlib_compressor_new(format, level);
end;

function TGZlibCompressor.get_file_info: PGFileInfo; cdecl;
begin
  Result := CastleInternalGio2.g_zlib_compressor_get_file_info(@self);
end;

procedure TGZlibCompressor.set_file_info(file_info: PGFileInfo); cdecl;
begin
  CastleInternalGio2.g_zlib_compressor_set_file_info(@self, file_info);
end;

function TGZlibDecompressor.new(format: TGZlibCompressorFormat): PGZlibDecompressor; cdecl;
begin
  Result := CastleInternalGio2.g_zlib_decompressor_new(format);
end;

function TGZlibDecompressor.get_file_info: PGFileInfo; cdecl;
begin
  Result := CastleInternalGio2.g_zlib_decompressor_get_file_info(@self);
end;

end.
