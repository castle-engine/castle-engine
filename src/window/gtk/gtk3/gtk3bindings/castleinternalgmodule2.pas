{ This is an autogenerated unit using gobject introspection (gir2pascal). Do not Edit. }
unit CastleInternalGModule2;

{$MODE OBJFPC}{$H+}

{$PACKRECORDS C}
{$MODESWITCH DUPLICATELOCALS+}

{$ifdef Unix}
{$LINKLIB libgmodule-2.0.so.0}
{$endif}
{$WARN 3031 off : Values in enumeration types have to be ascending}
interface
uses
  CTypes, CastleInternalGlib2;

const
  {$ifdef MsWindows}
  LazGModule2_library = 'libgmodule-2.0.so.dll';
  {$else}
  LazGModule2_library = 'libgmodule-2.0.so.0';
  {$endif}

type
  TGModuleFlagsIdx = (
    TGModuleFlagsIdxMinValue = 0,
    G_MODULE_BIND_LAZY = 0,
    G_MODULE_BIND_LOCAL = 1,
    TGModuleFlagsIdxMaxValue = 31
  );
  TGModuleFlags = Set of TGModuleFlagsIdx;
const
  G_MODULE_BIND_MASK = [
    G_MODULE_BIND_LAZY,
    G_MODULE_BIND_LOCAL
  ]; {3 = $00000003}

type


  { TGModule }
  PPGModule = ^PGModule;
  PGModule = ^TGModule;


  { TGModuleFlags }
  PPGModuleFlags = ^PGModuleFlags;
  PGModuleFlags = ^TGModuleFlags;
  TGModule = object
    function close: gboolean; cdecl; inline;
    procedure make_resident; cdecl; inline;
    function name: Pgchar; cdecl; inline;
    function symbol(symbol_name: Pgchar; symbol: Pgpointer): gboolean; cdecl; inline;
    function build_path(directory: Pgchar; module_name: Pgchar): Pgchar; cdecl; inline; static;
    function error: Pgchar; cdecl; inline; static;
    {$IFDEF USEGTK3LATESTBINDINGS}
    function error_quark: TGQuark; cdecl; inline; static;
    {$ENDIF}
    function open(file_name: Pgchar; flags: TGModuleFlags): PGModule; cdecl; inline; static;
    function supported: gboolean; cdecl; inline; static;
  end;
  TGModuleCheckInit = function(module: PGModule): Pgchar; cdecl;
  TGModuleUnload = procedure(module: PGModule); cdecl;

function g_module_build_path(directory: Pgchar; module_name: Pgchar): Pgchar; cdecl; external LazGModule2_library name 'g_module_build_path';
function g_module_close(module: PGModule): gboolean; cdecl; external LazGModule2_library name 'g_module_close';
function g_module_error: Pgchar; cdecl; external LazGModule2_library name 'g_module_error';
{$IFDEF USEGTK3LATESTBINDINGS}
function g_module_error_quark: TGQuark; cdecl; external LazGModule2_library name 'g_module_error_quark';
{$ENDIF}
function g_module_name(module: PGModule): Pgchar; cdecl; external LazGModule2_library name 'g_module_name';
function g_module_open(file_name: Pgchar; flags: TGModuleFlags): PGModule; cdecl; external LazGModule2_library name 'g_module_open';
function g_module_supported: gboolean; cdecl; external LazGModule2_library name 'g_module_supported';
function g_module_symbol(module: PGModule; symbol_name: Pgchar; symbol: Pgpointer): gboolean; cdecl; external LazGModule2_library name 'g_module_symbol';
procedure g_module_make_resident(module: PGModule); cdecl; external LazGModule2_library name 'g_module_make_resident';
implementation
function TGModule.close: gboolean; cdecl;
begin
  Result := CastleInternalGModule2.g_module_close(@self);
end;

procedure TGModule.make_resident; cdecl;
begin
  CastleInternalGModule2.g_module_make_resident(@self);
end;

function TGModule.name: Pgchar; cdecl;
begin
  Result := CastleInternalGModule2.g_module_name(@self);
end;

function TGModule.symbol(symbol_name: Pgchar; symbol: Pgpointer): gboolean; cdecl;
begin
  Result := CastleInternalGModule2.g_module_symbol(@self, symbol_name, symbol);
end;

function TGModule.build_path(directory: Pgchar; module_name: Pgchar): Pgchar; cdecl;
begin
  Result := CastleInternalGModule2.g_module_build_path(directory, module_name);
end;

function TGModule.error: Pgchar; cdecl;
begin
  Result := CastleInternalGModule2.g_module_error();
end;

{$IFDEF USEGTK3LATESTBINDINGS}
function TGModule.error_quark: TGQuark; cdecl;
begin
  Result := CastleInternalGModule2.g_module_error_quark();
end;
{$ENDIF}

function TGModule.open(file_name: Pgchar; flags: TGModuleFlags): PGModule; cdecl;
begin
  Result := CastleInternalGModule2.g_module_open(file_name, flags);
end;

function TGModule.supported: gboolean; cdecl;
begin
  Result := CastleInternalGModule2.g_module_supported();
end;

end.
