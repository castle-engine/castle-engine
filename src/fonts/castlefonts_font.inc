{%MainUnit castlefonts.pas}
{
  Copyright 2001-2024 Michalis Kamburelis.

  This file is part of "Castle Game Engine".

  "Castle Game Engine" is free software; see the file COPYING.txt,
  included in this distribution, for details about the copyright.

  "Castle Game Engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

  ----------------------------------------------------------------------------
}

{$ifdef read_interface}

type
  { Font loaded from a font file, like ttf or otf.
    This class is typically used for outline (scalable, vector) fonts in ttf or otf formats.
    But it can really deal with any font supported by
    the @url(https://www.freetype.org/ FreeType library), even bitmap fonts,
    see @url(https://www.freetype.org/freetype2/docs/ft2faq.html#general-what the summary of font formats supported by FreeType).

    This can load a font file, or it can use ready data in TTextureFontData.
    The latter allows to use this for fonts embedded in a Pascal source code,
    since our texture-font-to-pascal can convert a font file to a unit that defines
    ready TTextureFontData instance. }
  TCastleFont = class(TCastleAbstractFont)
  strict private
    FDistanceField: Boolean;
    FFont: TTextureFontData; //< nil when no font loaded successfully
    FOwnsFont: Boolean;
    DrawableImage: TDrawableImage;
    DistanceFieldShader: TGLSLProgram;
    GlyphsScreenRects, GlyphsImageRects: TFloatRectangleList;
    FUrl: String;
    FOptimalSize: Cardinal;
    FAntiAliased: Boolean;
    FLoadBasicCharacters: Boolean;
    FLoadCharacters: String;
    function GetScale: Single;
    procedure SetDistanceField(const AValue: Boolean);
    procedure SetScale(const AValue: Single);
    procedure SetUrl(const Value: String);
    procedure SetOptimalSize(const Value: Cardinal);
    procedure SetAntiAliased(const Value: Boolean);
    procedure SetLoadBasicCharacters(const Value: Boolean);
    procedure SetLoadCharacters(const Value: String);
    { Free stuff loaded by @link(Load). }
    procedure Unload;
    procedure Reload;
  strict protected
    procedure SetSize(const Value: Single); override;
    procedure GLContextClose; override;
  public
    const
      DefaultOptimalSize = 20;

    constructor Create(AOwner: TComponent); overload; override;
    destructor Destroy; override;
    function PropertySections(const PropertyName: String): TPropertySections; override;
    function FontLoaded: Boolean; overload; override;

    constructor Create(const Url: String;
      const ASize: Cardinal; const AnAntiAliased: Boolean;
      const ACharacters: TUnicodeCharList = nil); reintroduce; overload; deprecated 'use Create(Owner: TComponent), then assign properties to load font: OptimalSize, LoadCharacters, AntiAliased, Url';
    constructor Create(const Url: String;
      const ASize: Cardinal; const AnAntiAliased: Boolean;
      const ACharacters: TSetOfChars); reintroduce; overload; deprecated 'use Create(Owner: TComponent), then assign properties to load font: OptimalSize, LoadCharacters, AntiAliased, Url';

    { Load by reading a FreeType font file, like ttf.

      Providing charaters list as @nil means that we only create glyphs
      for SimpleAsciiCharacters, which includes only the basic ASCII characters.
      The ACharacters instance @italic(does not) become owned by this object,
      so remember to free it after calling this constructor.

      Loading a font data also changes @link(Size) to the underlying
      (optimal to render) font data size. }
    procedure Load(const Url: String;
      const ASize: Cardinal; const AnAntiAliased: Boolean;
      const ACharacters: TUnicodeCharList = nil;
      const AdjustProperties: Boolean = true); overload; deprecated 'assign properties to load font: OptimalSize, LoadCharacters, AntiAliased, Url';

    { Load from a ready TTextureFontData instance.
      @param(Data TTextureFontData instance containing loaded image
        and glyphs parameters.)
      @param(OwnsData If @true, the Data instance becomes owned
        by this class (will be freed in our constructor).
        Usually you @italic(do not) want this, since usually you pass Data
        from a unit generated by texture-font-to-pascal. In this case,
        the finalization of CastleTextureFont_Xxx unit will already free
        the TTextureFontData instance.)
      @param(AdjustProperties Adjust Url, OptimalSize, Size, AntiAliased
        to reflect loaded Data. Or reset them to reflect empty Url
        (and the rest at defaults) when Data = nil.) }
    procedure Load(const Data: TTextureFontData;
      const OwnsData: Boolean = false;
      const AdjustProperties: Boolean = true); overload;

    procedure PrepareResources; override;
    procedure Print(const X, Y: Single; const Color: TCastleColor;
      const S: String); override;
    function TextWidth(const S: String): Single; override;
    function TextHeight(const S: String): Single; override;
    function TextHeightBase(const S: String): Single; override;
    function TextMove(const S: String): TVector2; override;

    { Underlying font data. }
    property FontData: TTextureFontData read FFont; {$ifdef FPC}deprecated 'you should not need to use this directly';{$endif} // can't be removed from delphi because x3dnodes_standard_text.inc uses that

    { Scale applied to the rendered font, compared to @link(FontData).Size.
      Changing this is equivalent to changing the Size property. }
    property Scale: Single read GetScale write SetScale;
  published
    { Loaded font file.
      Typically this is used for outline (scalable, vector) fonts in ttf or otf formats.
      But it can really deal with any font format supported by
      the @url(https://www.freetype.org/ FreeType library), even bitmap fonts,
      see @url(https://www.freetype.org/freetype2/docs/ft2faq.html#general-what the summary of font formats supported by FreeType). }
    property Url: String read FUrl write SetUrl;

    { Use "distance field" font rendering.
      This is a font rendering technique that @italic(may)
      result in a better quality when the text is large.

      Underneath, the font is processed to a different texture than usual
      (that expresses distances to glyphs) and rendered usign a special shader.

      The positive outcome is that the font looks better (not blurred)
      even when scaled up.
      "Scaling up" occurs when the actual font size
      (derived from @link(TCastleUserInterfaceFont.FontSize) and UI scaling)
      is significantly larger than the optimal size for which the font
      image was prepared (@link(OptimalSize)). In this case, rendering
      without distance field (when this is @false, by default)
      results in blurred font look.
      When this is @true, the look remains "crisp".

      Disadvantages:

      One, preparing a distance field font texture is more time-consuming.
      So loading time may be slightly larger. This increased loading time
      is generally negligible if you just have a few fonts.
      But be sure to profile your loading time (see
      https://castle-engine.io/manual_optimization.php )
      if you use a lot of fonts with DistanceField = @true.

      A more serious disadvantage is that the result is not always a better quality:
      At really large sizes, the artifacts of distance field rendering
      may be visible -- the letters are "crisp" but their shape may be slightly
      distorted.
      If you don't mind extra memory usage, you can likely get better
      quality by just loading a larger font texture (with larger OptimalSize)
      and leaving this property at @false.

      Morover, when the final font size is *smaller* than the size for which
      the font was prepared, it will definitely look worse.

      TODO: We could defeat some of the issues mentioned above.
      You're welcome to ping us ( https://castle-engine.io/talk.php )
      and support ( https://www.patreon.com/castleengine ) to make it happen.

      @unorderedList(
        @item(The loading time of fonts (with and without distance fields)
          could be improved by generating the necessary texture at
          preprocessing, introducing "castle-engine auto-generate" command
          that would generalize current "castle-engine auto-generate-textures".
        )

        @item(TCastleText (text in a viewport) cannot handle fonts with DistanceField
          yet. Result would not be sensible. For now, TCastleText.FontStyleFontChanged
          warns about it and forces DistanceField to @false.)

        @item(It is possible that the quality could be improved:

          Implement normalization.
          Can this make downscaling better? Does this make upscaling better?
          See https://libgdx.com/wiki/graphics/2d/fonts/distance-field-fonts
          what it means.)

        @item(Introduce a fallback on non-distance-field texture,
          used when downscaling happens?

          This means larger memory usage,
          and potential jump in look if someone animates FontSize.
        )
      )
    }
    property DistanceField: Boolean read FDistanceField write SetDistanceField
      default false;

    { Optimal font size (in real device pixels),
      the font will be scaled when other size is actually needed.
      This also sets default @link(Size) used for rendering this font. }
    property OptimalSize: Cardinal read FOptimalSize write SetOptimalSize default DefaultOptimalSize;

    { Anti-aliased font has smooth edges and is rendered using blending.
      Usually this is much better for quality.
      Non-anti-aliased means that font uses simple yes/no transparency
      and is rendered using alpha testing. }
    property AntiAliased: Boolean read FAntiAliased write SetAntiAliased default true;

    { Load from font all "basic" characters, which include digits,
      English letters and standard ASCII symbols.
      See @link(SimpleAsciiCharacters) for exact definition.
      These are loaded in addition to characters listed on LoadCharacters. }
    property LoadBasicCharacters: Boolean read FLoadBasicCharacters write SetLoadBasicCharacters default true;

    { Load from font all characters listed here. As everywhere in CGE
      (same as in Lazarus LCL), this is an String composed from UTF-8 characters. }
    property LoadCharacters: String read FLoadCharacters write SetLoadCharacters;
  end;

  TGLBitmapFont = TCastleFont deprecated 'use TCastleFont';
  TTextureFont = TCastleFont deprecated 'use TCastleFont';

{$endif read_interface}

{$ifdef read_implementation}

{ TCastleFont --------------------------------------------------------------- }

constructor TCastleFont.Create(AOwner: TComponent);
begin
  inherited;
  GlyphsScreenRects := TFloatRectangleList.Create;
  GlyphsImageRects  := TFloatRectangleList.Create;
  FLoadBasicCharacters := true;
  FOptimalSize := DefaultOptimalSize;
  FAntiAliased := true;
end;

destructor TCastleFont.Destroy;
begin
  Unload;
  FreeAndNil(GlyphsScreenRects);
  FreeAndNil(GlyphsImageRects);
  inherited;
end;

procedure TCastleFont.Unload;
begin
  // free previous FFont data
  Load(nil, { OwnsData doesn't matter } false, { AdjustParameters } false);
end;

constructor TCastleFont.Create(const Url: String;
  const ASize: Cardinal; const AnAntiAliased: Boolean;
  const ACharacters: TUnicodeCharList);
begin
  Create(nil);
  {$warnings off} // calling deprecated from deprecated
  Load(Url, ASize, AnAntiAliased, ACharacters, true);
  {$warnings on}
end;

procedure TCastleFont.Load(const Url: String;
  const ASize: Cardinal; const AnAntiAliased: Boolean;
  const ACharacters: TUnicodeCharList = nil;
  const AdjustProperties: Boolean = true);
var
  NewFontData: TTextureFontData;
begin
  { Although FontSizesChanged is also called by Load,
    make sure it gets called even when TTextureFontData.Create fails
    (e.g. loading file fails). }
  FontSizesChanged;
  if Url = '' then
    Unload
  else
  begin
    NewFontData := GetEmbeddedFont(Url);
    if NewFontData <> nil then
    begin
      { Pass OwnsData = false in this case. }
      Load(NewFontData, false, AdjustProperties);
    end else
    begin
      NewFontData := TTextureFontData.Create(Url, ASize, AnAntiAliased,
        ACharacters, FDistanceField);
      Load(NewFontData, true, AdjustProperties);
    end;
  end;
end;

constructor TCastleFont.Create(const Url: String;
  const ASize: Cardinal; const AnAntiAliased: Boolean;
  const ACharacters: TSetOfChars);
var
  Chars: TUnicodeCharList;
  C: Char;
begin
  Chars := TUnicodeCharList.Create;
  try
    for C in ACharacters do
      Chars.Add(Ord(C));
    {$warnings off} // calling deprecated from deprecated
    Create(Url, ASize, AnAntiAliased, Chars);
    {$warnings on}
  finally FreeAndNil(Chars) end;
end;

procedure TCastleFont.Load(const Data: TTextureFontData; const OwnsData: Boolean = false;
  const AdjustProperties: Boolean = true);
begin
  GLContextClose;

  if FOwnsFont then
    FreeAndNil(FFont)
  else
    FFont := nil;

  FOwnsFont := OwnsData;
  FFont := Data;

  if AdjustProperties then
  begin
    if FFont <> nil then
    begin
      FUrl := FFont.Url;
      FOptimalSize := FFont.Size;
      FAntiAliased := FFont.AntiAliased;
    end else
    begin
      FUrl := '';
      { for consistency, adjust all properties always, even when FFont = nil }
      FOptimalSize := DefaultOptimalSize;
      FAntiAliased := true;
    end;
    // synchronize Size with OptimalSize
    Size := OptimalSize;
  end;

  // call this at the end, when our state is consistent
  FontSizesChanged;
end;

function TCastleFont.PropertySections(const PropertyName: String): TPropertySections;
begin
  if (PropertyName = 'Url') or
     (PropertyName = 'OptimalSize') or
     (PropertyName = 'AntiAliased') or
     (PropertyName = 'LoadCharacters') or
     (PropertyName = 'DistanceField') or
     (PropertyName = 'LoadBasicCharacters') then
    Result := [psBasic]
  else
    Result := inherited PropertySections(PropertyName);
end;

function TCastleFont.GetScale: Single;
begin
  if FFont <> nil then
    Result := Size / FFont.Size
  else
    Result := Size;
end;

procedure TCastleFont.SetDistanceField(const AValue: Boolean);
begin
  if FDistanceField <> AValue then
  begin
    FDistanceField := AValue;
    Reload;
  end;
end;

procedure TCastleFont.SetScale(const AValue: Single);
begin
  if FFont <> nil then
    Size := FFont.Size * AValue
  else
    Size := AValue;
end;

procedure TCastleFont.SetSize(const Value: Single);
begin
  inherited SetSize(Value);

  Assert((FFont = nil) or (FFont.Size <> 0));
  Assert(not IsInfinite(Value));

  { In the past, we had "smart" code here adjusting
      DrawableImage.SmoothScaling := Size <> FFont.Size
    in each SetSize (if DrawableImage <> nil),
    based on the idea that when desired size equals optimal
    size then there's no need for smooth scaling.

    But this causes often toggling of DrawableImage.SmoothScaling.
    It is particularly visible when using multiple TCastleLabel,
    and/or with multiple lines. In this case we switch between original/customized
    font size quickly, since TCastleUserInterfaceFont.Font
    adjusts Size, TCastleFontFamily.SubFontCustomizeBegin does SF.PushProperties.
    But actually all rendering is done with equal Size...

    So constant switching between smooth scaling and non-smooth scaling
    does not serve anything, and it:

    - makes unnnecessary OpenGL calls to toggle texture filtering back and forth,
      slowing down rendering
    - prevents labels batching when using TDrawableImage.BatchingBegin/End,
      Container.UserInterfaceBatching
  }
end;

procedure TCastleFont.PrepareResources;

  procedure AttachDistanceFieldShader;
  var
    VS, FS: String;
  begin
    VS := {$I image.vs.inc};
    FS := {$I distance_field_font.fs.inc};

    FreeAndNil(DistanceFieldShader);
    DistanceFieldShader := TGLSLProgram.Create;
    DistanceFieldShader.Name := 'DistanceFieldShader';
    DistanceFieldShader.AttachVertexShader(VS);
    DistanceFieldShader.AttachFragmentShader(FS);
    DistanceFieldShader.Link;
    DrawableImage.CustomShader := DistanceFieldShader;
    DrawableImage.SmoothScaling := true;
  end;

begin
  inherited;
  if (FFont <> nil) and (DrawableImage = nil) then
  begin
    DrawableImage := TDrawableImage.Create(FFont.Image,
      { Smooth scaling always true, ready for any Size,
        see TCastleFont.SetSize comments.  }
      true, false);
    if FFont.DistanceField then
      AttachDistanceFieldShader;
  end;
end;

procedure TCastleFont.GLContextClose;
begin
  FreeAndNil(DrawableImage);
  FreeAndNil(DistanceFieldShader);
  inherited;
end;

procedure TCastleFont.Print(const X, Y: Single; const Color: TCastleColor;
  const S: String);
var
  ScreenX, ScreenY: Single;
  G: TTextureFontData.TGlyph;
  GlyphsToRender: Integer;

  procedure GlyphDraw(const OutlineMoveX, OutlineMoveY: Integer);
  var
    ScreenRect, ImageRect: PFloatRectangle;
  begin
    if TargetImage <> nil then
    begin
      TargetImage.DrawFrom(FFont.Image,
        Round(ScreenX - G.X * Scale + OutlineMoveX * Outline),
        Round(ScreenY - G.Y * Scale + OutlineMoveY * Outline),
        FFont.GlyphDrawImageRect(G));
    end else
    begin
      Assert(GlyphsToRender < GlyphsScreenRects.Count);

      { Use a small margin around every glyph to allow bilinear
        filtering to smoothly go from opaque to fully transparent
        at glyph border. This prevents glyph border from ending suddenly,
        it looks much better in the case of blending.

        This cooperates with TTextureFontData.Create (used by
        texture-font-to-pascal) that makes sure that each letter is
        surrounded with a padding that allows such border,
        see GlyphPadding in castletexturefontdata.pas. }
      { TODO; Not used now. While there's a visible improvement in some cases
        (when optimal font size mismatches final font size),
        there's also regression in castle-model-viewer
        (when optimal font size matches final font size closely):
        the "A" in "Animations" button in castle-model-viewer gets weird artifact. }
      {.$define EXTRA_GLYPH_SPACE}

      ImageRect := PFloatRectangle(GlyphsImageRects.Ptr(GlyphsToRender));
      ImageRect^ := FloatRectangle(FFont.GlyphDrawImageRect(G));
      {$ifdef EXTRA_GLYPH_SPACE}
      ImageRect^.Left   := ImageRect^.Left   - 0.5;
      ImageRect^.Bottom := ImageRect^.Bottom - 0.5;
      ImageRect^.Width  := ImageRect^.Width  + 1;
      ImageRect^.Height := ImageRect^.Height + 1;
      {$endif}

      ScreenRect := PFloatRectangle(GlyphsScreenRects.Ptr(GlyphsToRender));
      ScreenRect^.Left   := ScreenX - (G.X {$ifdef EXTRA_GLYPH_SPACE} + 0.5 {$endif}) * Scale + OutlineMoveX * Outline;
      ScreenRect^.Bottom := ScreenY - (G.Y {$ifdef EXTRA_GLYPH_SPACE} + 0.5 {$endif}) * Scale + OutlineMoveY * Outline;
      ScreenRect^.Width  := ImageRect^.Width  * Scale;
      ScreenRect^.Height := ImageRect^.Height * Scale;

      Inc(GlyphsToRender);
    end;
  end;

var
  Iter: TCastleStringIterator;
  GlyphsPerChar: Integer;
begin
  if FFont = nil then
    Exit; // font not loaded

  if TargetImage = nil then
  begin
    PrepareResources;

    { allocate the necessary glyphs at start.
      This allows to quickly fill them later.
      Note that we possibly allocate too much, because Length(S) may be > StringLength(S)
      (because of multi-byte characters), and also because some characters do not have glyphs.
      That's OK, we'll calculate real GlyphsToRender when iterating. }
    if Outline = 0 then
      GlyphsPerChar := 1 else
    if OutlineHighQuality then
      GlyphsPerChar := 8 else
      GlyphsPerChar := 4;
    GlyphsScreenRects.Count := Max(MinimumGlyphsAllocated, GlyphsPerChar * Length(S));
    GlyphsImageRects .Count := Max(MinimumGlyphsAllocated, GlyphsPerChar * Length(S));
  end;

  { first pass, to render Outline.

    This could be done better by being done together with non-outline pass,
    by filling the alternative place in Glyph arrays, such that outline and non-outline data
    don't collide.
    It would be 1. faster (don't iterate over S two times), 2. less code duplication. }
  if Outline <> 0 then
  begin
    GlyphsToRender := 0;
    { While Round() below is not needed, it improves the quality of rendered
      text. Compare e.g. castle-model-viewer button captions. }
    ScreenX := Round(X);
    ScreenY := Round(Y);
    if TargetImage <> nil then
      FFont.Image.ColorWhenTreatedAsAlpha := Vector3Byte(OutlineColor.XYZ); // ignore OutlineColor[3] for now

    Iter.Start(S);
    while Iter.GetNext do
    begin
      G := FFont.Glyph(Iter.Current);
      if G <> nil then
      begin
        if (G.Width <> 0) and (G.Height <> 0) then
        begin
          GlyphDraw(0, 0);
          GlyphDraw(0, 2);
          GlyphDraw(2, 2);
          GlyphDraw(2, 0);

          if OutlineHighQuality then
          begin
            GlyphDraw(1, 0);
            GlyphDraw(1, 2);
            GlyphDraw(0, 1);
            GlyphDraw(2, 1);
          end;
        end;
        ScreenX := ScreenX + G.AdvanceX * Scale + Outline * 2;
        ScreenY := ScreenY + G.AdvanceY * Scale;
      end;
    end;

    if TargetImage = nil then
    begin
      DrawableImage.Color := OutlineColor;
      DrawableImage.Draw(
        PFloatRectangleArray(GlyphsScreenRects.L),
        PFloatRectangleArray(GlyphsImageRects.L), GlyphsToRender);
    end;
  end;

  GlyphsToRender := 0;
  { While Round() below is not needed, it improves the quality of rendered
    text. }
  ScreenX := Round(X);
  ScreenY := Round(Y);
  if TargetImage <> nil then
    FFont.Image.ColorWhenTreatedAsAlpha := Vector3Byte(Color.XYZ); // ignore Color[3] for now

  Iter.Start(S);
  while Iter.GetNext do
  begin
    G := FFont.Glyph(Iter.Current);
    if G <> nil then
    begin
      if (G.Width <> 0) and (G.Height <> 0) then
        if Outline <> 0 then
          GlyphDraw(1, 1)
        else
          GlyphDraw(0, 0);
      ScreenX := ScreenX + G.AdvanceX * Scale + Outline * 2;
      ScreenY := ScreenY + G.AdvanceY * Scale;
    end;
  end;

  if TargetImage = nil then
  begin
    DrawableImage.Color := Color;
    DrawableImage.Draw(
      PFloatRectangleArray(GlyphsScreenRects.L),
      PFloatRectangleArray(GlyphsImageRects.L), GlyphsToRender);
  end;
end;

function TCastleFont.TextWidth(const S: String): Single;
begin
  if FFont = nil then
    Exit(0); // font not loaded
  Result := FFont.TextWidth(S) * Scale;
  if Outline <> 0 then
    Result := Result + Outline * 2 * StringLength(S);
end;

function TCastleFont.TextHeight(const S: String): Single;
begin
  if FFont = nil then
    Exit(0); // font not loaded
  Result := FFont.TextHeight(S) * Scale + Outline * 2;
end;

function TCastleFont.TextHeightBase(const S: String): Single;
begin
  if FFont = nil then
    Exit(0); // font not loaded
  Result := FFont.TextHeightBase(S) * Scale + Outline * 2;
end;

function TCastleFont.TextMove(const S: String): TVector2;
var
  M: TVector2Integer;
begin
  if FFont = nil then
    Exit(TVector2.Zero); // font not loaded
  M := FFont.TextMove(S);
  Result := Vector2(M.X, M.Y);
  Result.X := Result.X * Scale;
  if Outline <> 0 then
    Result.X := Result.X + Outline * 2 * StringLength(S);
  Result.Y := Result.Y * Scale;
end;

procedure TCastleFont.SetUrl(const Value: String);
begin
  if FUrl <> Value then
  begin
    { We deliberately change URL even when loading of font file could fail.
      This way URL property is always correctly deserialized in CGE editor,
      even when loading the image failed. }
    FUrl := Value;
    Reload;
  end;
end;

procedure TCastleFont.SetOptimalSize(const Value: Cardinal);
begin
  if FOptimalSize <> Value then
  begin
    { As with SetUrl: we deliberately change current property, even when Reload fails. }
    FOptimalSize := Value;
    Reload;
  end;
end;

procedure TCastleFont.SetAntiAliased(const Value: Boolean);
begin
  if FAntiAliased <> Value then
  begin
    { As with SetUrl: we deliberately change current property, even when Reload fails. }
    FAntiAliased := Value;
    Reload;
  end;
end;

procedure TCastleFont.SetLoadBasicCharacters(const Value: Boolean);
begin
  if FLoadBasicCharacters <> Value then
  begin
    { As with SetUrl: we deliberately change current property, even when Reload fails. }
    FLoadBasicCharacters := Value;
    Reload;
  end;
end;

procedure TCastleFont.SetLoadCharacters(const Value: String);
begin
  if FLoadCharacters <> Value then
  begin
    { As with SetUrl: we deliberately change current property, even when Reload fails. }
    FLoadCharacters := Value;
    Reload;
  end;
end;

procedure TCastleFont.Reload;

  function GetCharactersList: TUnicodeCharList;
  begin
    if (LoadCharacters = '') and LoadBasicCharacters then
    begin
      { Default, and fast case. TTextureFontData.Create interprets characters list = nil
        just like that: load only SimpleAsciiCharacters.
        No need to create TUnicodeCharList instance to express it explicitly. }
      Result := nil;
    end else
    begin
      Result := TUnicodeCharList.Create;
      if LoadBasicCharacters then
        Result.Add(SimpleAsciiCharacters);
      Result.Add(LoadCharacters);
    end;
  end;

  // Load, without catching any exceptions
  procedure LoadCore;
  var
    CharactersList: TUnicodeCharList;
  begin
    CharactersList := GetCharactersList;
    try
      {$warnings off} // this Load is deprecated; actually it should be internal, nested here
      Load(Url, OptimalSize, AntiAliased, CharactersList);
      {$warnings on}
    finally FreeAndNil(CharactersList) end;
  end;

begin
  if CastleDesignMode then
  begin
    { If loading file failed, and we're inside CGE editor,
      merely report a warning. This allows deserializing in CGE editor
      designs with broken URLs. }
    try
      LoadCore;
    except
      on E: Exception do
      begin
        { We unload, otherwise we would keep the font loaded, not correctly reflecting
          some new properties.
          Testcase: in editor load TTF to some TCastleFont,
          use it with some TCastleLabel.CustomFont,
          then set TCastlFont.LoadBasicCharacters to false -> font should revert
          to default UIFont (with warning "cannot load font with no glyphs"). }
        Unload;
        WritelnWarning('TCastleFont', 'Failed to load font "%s": %s',
          [UriDisplay(Url), ExceptMessage(E)]);
      end;
    end;
  end else
  begin
    { When not in editor, most exceptions are just passed upward.
      But we handle EFreeTypeLibraryNotFound. }
    try
      LoadCore;
    except
      on E: EFreeTypeLibraryNotFound do
      begin
        Unload;
        WritelnWarning('TCastleFont', 'Failed to load font "%s": %s',
          [UriDisplay(Url), E.Message]);
      end;
    end;
  end;
end;

function TCastleFont.FontLoaded: Boolean;
begin
  Result := FFont <> nil;
end;

{$endif read_implementation}
