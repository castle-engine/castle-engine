{ -*- buffer-read-only: t -*-

  Copyright 2018-2022 Michalis Kamburelis.

  This file is part of "Castle Game Engine".

  "Castle Game Engine" is free software; see the file COPYING.txt,
  included in this distribution, for details about the copyright.

  "Castle Game Engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

  ----------------------------------------------------------------------------
}

{ Automatically generated wrapper to make vectors/colors persistent.

  Do not edit this file manually!
  Instead
  - edit tools/internal/generate-persistent-vectors/persistent_vectors_input.txt
  - and run generate-persistent-vectors in that directory.
}

{$ifdef read_interface_class}
strict private
  FTintPressedPersistent: TCastleColorPersistent;
  function GetTintPressedForPersistent: TCastleColor;
  procedure SetTintPressedForPersistent(const AValue: TCastleColor);
published
  { @link(TintPressed) that can be visually edited in
    Castle Game Engine Editor, Lazarus and Delphi.
    Normal user code does not need to deal with this,
    instead read or write @link(TintPressed) directly.

    @seealso TintPressed }
  property TintPressedPersistent: TCastleColorPersistent read FTintPressedPersistent ;
{$endif read_interface_class}

{$ifdef read_implementation_methods}
function TCastleButton.GetTintPressedForPersistent: TCastleColor;
begin
  Result := TintPressed;
end;

procedure TCastleButton.SetTintPressedForPersistent(const AValue: TCastleColor);
begin
  TintPressed := AValue;
end;
{$endif read_implementation_methods}

{$ifdef read_implementation_constructor}
  FTintPressedPersistent := TCastleColorPersistent.Create(nil);
  { Note that some classes (like TCastleVector3Persistent) call SetSubComponent(true)
    on themselves, for backward compatibility. But we should not depend on it,
    some classes (like TFloatRectanglePersisten) may not call it.
    The responsibility of calling "SetSubComponent(true)" should be on the owner
    in general (this is more functional, and more standard too). }
  FTintPressedPersistent.SetSubComponent(true);
  FTintPressedPersistent.InternalGetValue := {$ifdef FPC}@{$endif}GetTintPressedForPersistent;
  FTintPressedPersistent.InternalSetValue := {$ifdef FPC}@{$endif}SetTintPressedForPersistent;
  FTintPressedPersistent.InternalDefaultValue := TintPressed; // current value is default
{$endif read_implementation_constructor}

{$ifdef read_implementation_destructor}
  FreeAndNil(FTintPressedPersistent);
{$endif read_implementation_destructor}

{ -*- buffer-read-only: t -*-

  Copyright 2018-2022 Michalis Kamburelis.

  This file is part of "Castle Game Engine".

  "Castle Game Engine" is free software; see the file COPYING.txt,
  included in this distribution, for details about the copyright.

  "Castle Game Engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

  ----------------------------------------------------------------------------
}

{ Automatically generated wrapper to make vectors/colors persistent.

  Do not edit this file manually!
  Instead
  - edit tools/internal/generate-persistent-vectors/persistent_vectors_input.txt
  - and run generate-persistent-vectors in that directory.
}

{$ifdef read_interface_class}
strict private
  FTintDisabledPersistent: TCastleColorPersistent;
  function GetTintDisabledForPersistent: TCastleColor;
  procedure SetTintDisabledForPersistent(const AValue: TCastleColor);
published
  { @link(TintDisabled) that can be visually edited in
    Castle Game Engine Editor, Lazarus and Delphi.
    Normal user code does not need to deal with this,
    instead read or write @link(TintDisabled) directly.

    @seealso TintDisabled }
  property TintDisabledPersistent: TCastleColorPersistent read FTintDisabledPersistent ;
{$endif read_interface_class}

{$ifdef read_implementation_methods}
function TCastleButton.GetTintDisabledForPersistent: TCastleColor;
begin
  Result := TintDisabled;
end;

procedure TCastleButton.SetTintDisabledForPersistent(const AValue: TCastleColor);
begin
  TintDisabled := AValue;
end;
{$endif read_implementation_methods}

{$ifdef read_implementation_constructor}
  FTintDisabledPersistent := TCastleColorPersistent.Create(nil);
  { Note that some classes (like TCastleVector3Persistent) call SetSubComponent(true)
    on themselves, for backward compatibility. But we should not depend on it,
    some classes (like TFloatRectanglePersisten) may not call it.
    The responsibility of calling "SetSubComponent(true)" should be on the owner
    in general (this is more functional, and more standard too). }
  FTintDisabledPersistent.SetSubComponent(true);
  FTintDisabledPersistent.InternalGetValue := {$ifdef FPC}@{$endif}GetTintDisabledForPersistent;
  FTintDisabledPersistent.InternalSetValue := {$ifdef FPC}@{$endif}SetTintDisabledForPersistent;
  FTintDisabledPersistent.InternalDefaultValue := TintDisabled; // current value is default
{$endif read_implementation_constructor}

{$ifdef read_implementation_destructor}
  FreeAndNil(FTintDisabledPersistent);
{$endif read_implementation_destructor}

{ -*- buffer-read-only: t -*-

  Copyright 2018-2022 Michalis Kamburelis.

  This file is part of "Castle Game Engine".

  "Castle Game Engine" is free software; see the file COPYING.txt,
  included in this distribution, for details about the copyright.

  "Castle Game Engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

  ----------------------------------------------------------------------------
}

{ Automatically generated wrapper to make vectors/colors persistent.

  Do not edit this file manually!
  Instead
  - edit tools/internal/generate-persistent-vectors/persistent_vectors_input.txt
  - and run generate-persistent-vectors in that directory.
}

{$ifdef read_interface_class}
strict private
  FTintFocusedPersistent: TCastleColorPersistent;
  function GetTintFocusedForPersistent: TCastleColor;
  procedure SetTintFocusedForPersistent(const AValue: TCastleColor);
published
  { @link(TintFocused) that can be visually edited in
    Castle Game Engine Editor, Lazarus and Delphi.
    Normal user code does not need to deal with this,
    instead read or write @link(TintFocused) directly.

    @seealso TintFocused }
  property TintFocusedPersistent: TCastleColorPersistent read FTintFocusedPersistent ;
{$endif read_interface_class}

{$ifdef read_implementation_methods}
function TCastleButton.GetTintFocusedForPersistent: TCastleColor;
begin
  Result := TintFocused;
end;

procedure TCastleButton.SetTintFocusedForPersistent(const AValue: TCastleColor);
begin
  TintFocused := AValue;
end;
{$endif read_implementation_methods}

{$ifdef read_implementation_constructor}
  FTintFocusedPersistent := TCastleColorPersistent.Create(nil);
  { Note that some classes (like TCastleVector3Persistent) call SetSubComponent(true)
    on themselves, for backward compatibility. But we should not depend on it,
    some classes (like TFloatRectanglePersisten) may not call it.
    The responsibility of calling "SetSubComponent(true)" should be on the owner
    in general (this is more functional, and more standard too). }
  FTintFocusedPersistent.SetSubComponent(true);
  FTintFocusedPersistent.InternalGetValue := {$ifdef FPC}@{$endif}GetTintFocusedForPersistent;
  FTintFocusedPersistent.InternalSetValue := {$ifdef FPC}@{$endif}SetTintFocusedForPersistent;
  FTintFocusedPersistent.InternalDefaultValue := TintFocused; // current value is default
{$endif read_implementation_constructor}

{$ifdef read_implementation_destructor}
  FreeAndNil(FTintFocusedPersistent);
{$endif read_implementation_destructor}

{ -*- buffer-read-only: t -*-

  Copyright 2018-2022 Michalis Kamburelis.

  This file is part of "Castle Game Engine".

  "Castle Game Engine" is free software; see the file COPYING.txt,
  included in this distribution, for details about the copyright.

  "Castle Game Engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

  ----------------------------------------------------------------------------
}

{ Automatically generated wrapper to make vectors/colors persistent.

  Do not edit this file manually!
  Instead
  - edit tools/internal/generate-persistent-vectors/persistent_vectors_input.txt
  - and run generate-persistent-vectors in that directory.
}

{$ifdef read_interface_class}
strict private
  FTintNormalPersistent: TCastleColorPersistent;
  function GetTintNormalForPersistent: TCastleColor;
  procedure SetTintNormalForPersistent(const AValue: TCastleColor);
published
  { @link(TintNormal) that can be visually edited in
    Castle Game Engine Editor, Lazarus and Delphi.
    Normal user code does not need to deal with this,
    instead read or write @link(TintNormal) directly.

    @seealso TintNormal }
  property TintNormalPersistent: TCastleColorPersistent read FTintNormalPersistent ;
{$endif read_interface_class}

{$ifdef read_implementation_methods}
function TCastleButton.GetTintNormalForPersistent: TCastleColor;
begin
  Result := TintNormal;
end;

procedure TCastleButton.SetTintNormalForPersistent(const AValue: TCastleColor);
begin
  TintNormal := AValue;
end;
{$endif read_implementation_methods}

{$ifdef read_implementation_constructor}
  FTintNormalPersistent := TCastleColorPersistent.Create(nil);
  { Note that some classes (like TCastleVector3Persistent) call SetSubComponent(true)
    on themselves, for backward compatibility. But we should not depend on it,
    some classes (like TFloatRectanglePersisten) may not call it.
    The responsibility of calling "SetSubComponent(true)" should be on the owner
    in general (this is more functional, and more standard too). }
  FTintNormalPersistent.SetSubComponent(true);
  FTintNormalPersistent.InternalGetValue := {$ifdef FPC}@{$endif}GetTintNormalForPersistent;
  FTintNormalPersistent.InternalSetValue := {$ifdef FPC}@{$endif}SetTintNormalForPersistent;
  FTintNormalPersistent.InternalDefaultValue := TintNormal; // current value is default
{$endif read_implementation_constructor}

{$ifdef read_implementation_destructor}
  FreeAndNil(FTintNormalPersistent);
{$endif read_implementation_destructor}

{ -*- buffer-read-only: t -*-

  Copyright 2018-2022 Michalis Kamburelis.

  This file is part of "Castle Game Engine".

  "Castle Game Engine" is free software; see the file COPYING.txt,
  included in this distribution, for details about the copyright.

  "Castle Game Engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

  ----------------------------------------------------------------------------
}

{ Automatically generated wrapper to make vectors/colors persistent.

  Do not edit this file manually!
  Instead
  - edit tools/internal/generate-persistent-vectors/persistent_vectors_input.txt
  - and run generate-persistent-vectors in that directory.
}

{$ifdef read_interface_class}
strict private
  FCustomTextColorPersistent: TCastleColorPersistent;
  function GetCustomTextColorForPersistent: TCastleColor;
  procedure SetCustomTextColorForPersistent(const AValue: TCastleColor);
published
  { @link(CustomTextColor) that can be visually edited in
    Castle Game Engine Editor, Lazarus and Delphi.
    Normal user code does not need to deal with this,
    instead read or write @link(CustomTextColor) directly.

    @seealso CustomTextColor }
  property CustomTextColorPersistent: TCastleColorPersistent read FCustomTextColorPersistent ;
{$endif read_interface_class}

{$ifdef read_implementation_methods}
function TCastleButton.GetCustomTextColorForPersistent: TCastleColor;
begin
  Result := CustomTextColor;
end;

procedure TCastleButton.SetCustomTextColorForPersistent(const AValue: TCastleColor);
begin
  CustomTextColor := AValue;
end;
{$endif read_implementation_methods}

{$ifdef read_implementation_constructor}
  FCustomTextColorPersistent := TCastleColorPersistent.Create(nil);
  { Note that some classes (like TCastleVector3Persistent) call SetSubComponent(true)
    on themselves, for backward compatibility. But we should not depend on it,
    some classes (like TFloatRectanglePersisten) may not call it.
    The responsibility of calling "SetSubComponent(true)" should be on the owner
    in general (this is more functional, and more standard too). }
  FCustomTextColorPersistent.SetSubComponent(true);
  FCustomTextColorPersistent.InternalGetValue := {$ifdef FPC}@{$endif}GetCustomTextColorForPersistent;
  FCustomTextColorPersistent.InternalSetValue := {$ifdef FPC}@{$endif}SetCustomTextColorForPersistent;
  FCustomTextColorPersistent.InternalDefaultValue := CustomTextColor; // current value is default
{$endif read_implementation_constructor}

{$ifdef read_implementation_destructor}
  FreeAndNil(FCustomTextColorPersistent);
{$endif read_implementation_destructor}

{ -*- buffer-read-only: t -*-

  Copyright 2018-2022 Michalis Kamburelis.

  This file is part of "Castle Game Engine".

  "Castle Game Engine" is free software; see the file COPYING.txt,
  included in this distribution, for details about the copyright.

  "Castle Game Engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

  ----------------------------------------------------------------------------
}

{ Automatically generated wrapper to make vectors/colors persistent.

  Do not edit this file manually!
  Instead
  - edit tools/internal/generate-persistent-vectors/persistent_vectors_input.txt
  - and run generate-persistent-vectors in that directory.
}

{$ifdef read_interface_class}
strict private
  FCustomColorPressedPersistent: TCastleColorPersistent;
  function GetCustomColorPressedForPersistent: TCastleColor;
  procedure SetCustomColorPressedForPersistent(const AValue: TCastleColor);
published
  { @link(CustomColorPressed) that can be visually edited in
    Castle Game Engine Editor, Lazarus and Delphi.
    Normal user code does not need to deal with this,
    instead read or write @link(CustomColorPressed) directly.

    @seealso CustomColorPressed }
  property CustomColorPressedPersistent: TCastleColorPersistent read FCustomColorPressedPersistent ;
{$endif read_interface_class}

{$ifdef read_implementation_methods}
function TCastleButton.GetCustomColorPressedForPersistent: TCastleColor;
begin
  Result := CustomColorPressed;
end;

procedure TCastleButton.SetCustomColorPressedForPersistent(const AValue: TCastleColor);
begin
  CustomColorPressed := AValue;
end;
{$endif read_implementation_methods}

{$ifdef read_implementation_constructor}
  FCustomColorPressedPersistent := TCastleColorPersistent.Create(nil);
  { Note that some classes (like TCastleVector3Persistent) call SetSubComponent(true)
    on themselves, for backward compatibility. But we should not depend on it,
    some classes (like TFloatRectanglePersisten) may not call it.
    The responsibility of calling "SetSubComponent(true)" should be on the owner
    in general (this is more functional, and more standard too). }
  FCustomColorPressedPersistent.SetSubComponent(true);
  FCustomColorPressedPersistent.InternalGetValue := {$ifdef FPC}@{$endif}GetCustomColorPressedForPersistent;
  FCustomColorPressedPersistent.InternalSetValue := {$ifdef FPC}@{$endif}SetCustomColorPressedForPersistent;
  FCustomColorPressedPersistent.InternalDefaultValue := CustomColorPressed; // current value is default
{$endif read_implementation_constructor}

{$ifdef read_implementation_destructor}
  FreeAndNil(FCustomColorPressedPersistent);
{$endif read_implementation_destructor}

{ -*- buffer-read-only: t -*-

  Copyright 2018-2022 Michalis Kamburelis.

  This file is part of "Castle Game Engine".

  "Castle Game Engine" is free software; see the file COPYING.txt,
  included in this distribution, for details about the copyright.

  "Castle Game Engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

  ----------------------------------------------------------------------------
}

{ Automatically generated wrapper to make vectors/colors persistent.

  Do not edit this file manually!
  Instead
  - edit tools/internal/generate-persistent-vectors/persistent_vectors_input.txt
  - and run generate-persistent-vectors in that directory.
}

{$ifdef read_interface_class}
strict private
  FCustomColorDisabledPersistent: TCastleColorPersistent;
  function GetCustomColorDisabledForPersistent: TCastleColor;
  procedure SetCustomColorDisabledForPersistent(const AValue: TCastleColor);
published
  { @link(CustomColorDisabled) that can be visually edited in
    Castle Game Engine Editor, Lazarus and Delphi.
    Normal user code does not need to deal with this,
    instead read or write @link(CustomColorDisabled) directly.

    @seealso CustomColorDisabled }
  property CustomColorDisabledPersistent: TCastleColorPersistent read FCustomColorDisabledPersistent ;
{$endif read_interface_class}

{$ifdef read_implementation_methods}
function TCastleButton.GetCustomColorDisabledForPersistent: TCastleColor;
begin
  Result := CustomColorDisabled;
end;

procedure TCastleButton.SetCustomColorDisabledForPersistent(const AValue: TCastleColor);
begin
  CustomColorDisabled := AValue;
end;
{$endif read_implementation_methods}

{$ifdef read_implementation_constructor}
  FCustomColorDisabledPersistent := TCastleColorPersistent.Create(nil);
  { Note that some classes (like TCastleVector3Persistent) call SetSubComponent(true)
    on themselves, for backward compatibility. But we should not depend on it,
    some classes (like TFloatRectanglePersisten) may not call it.
    The responsibility of calling "SetSubComponent(true)" should be on the owner
    in general (this is more functional, and more standard too). }
  FCustomColorDisabledPersistent.SetSubComponent(true);
  FCustomColorDisabledPersistent.InternalGetValue := {$ifdef FPC}@{$endif}GetCustomColorDisabledForPersistent;
  FCustomColorDisabledPersistent.InternalSetValue := {$ifdef FPC}@{$endif}SetCustomColorDisabledForPersistent;
  FCustomColorDisabledPersistent.InternalDefaultValue := CustomColorDisabled; // current value is default
{$endif read_implementation_constructor}

{$ifdef read_implementation_destructor}
  FreeAndNil(FCustomColorDisabledPersistent);
{$endif read_implementation_destructor}

{ -*- buffer-read-only: t -*-

  Copyright 2018-2022 Michalis Kamburelis.

  This file is part of "Castle Game Engine".

  "Castle Game Engine" is free software; see the file COPYING.txt,
  included in this distribution, for details about the copyright.

  "Castle Game Engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

  ----------------------------------------------------------------------------
}

{ Automatically generated wrapper to make vectors/colors persistent.

  Do not edit this file manually!
  Instead
  - edit tools/internal/generate-persistent-vectors/persistent_vectors_input.txt
  - and run generate-persistent-vectors in that directory.
}

{$ifdef read_interface_class}
strict private
  FCustomColorFocusedPersistent: TCastleColorPersistent;
  function GetCustomColorFocusedForPersistent: TCastleColor;
  procedure SetCustomColorFocusedForPersistent(const AValue: TCastleColor);
published
  { @link(CustomColorFocused) that can be visually edited in
    Castle Game Engine Editor, Lazarus and Delphi.
    Normal user code does not need to deal with this,
    instead read or write @link(CustomColorFocused) directly.

    @seealso CustomColorFocused }
  property CustomColorFocusedPersistent: TCastleColorPersistent read FCustomColorFocusedPersistent ;
{$endif read_interface_class}

{$ifdef read_implementation_methods}
function TCastleButton.GetCustomColorFocusedForPersistent: TCastleColor;
begin
  Result := CustomColorFocused;
end;

procedure TCastleButton.SetCustomColorFocusedForPersistent(const AValue: TCastleColor);
begin
  CustomColorFocused := AValue;
end;
{$endif read_implementation_methods}

{$ifdef read_implementation_constructor}
  FCustomColorFocusedPersistent := TCastleColorPersistent.Create(nil);
  { Note that some classes (like TCastleVector3Persistent) call SetSubComponent(true)
    on themselves, for backward compatibility. But we should not depend on it,
    some classes (like TFloatRectanglePersisten) may not call it.
    The responsibility of calling "SetSubComponent(true)" should be on the owner
    in general (this is more functional, and more standard too). }
  FCustomColorFocusedPersistent.SetSubComponent(true);
  FCustomColorFocusedPersistent.InternalGetValue := {$ifdef FPC}@{$endif}GetCustomColorFocusedForPersistent;
  FCustomColorFocusedPersistent.InternalSetValue := {$ifdef FPC}@{$endif}SetCustomColorFocusedForPersistent;
  FCustomColorFocusedPersistent.InternalDefaultValue := CustomColorFocused; // current value is default
{$endif read_implementation_constructor}

{$ifdef read_implementation_destructor}
  FreeAndNil(FCustomColorFocusedPersistent);
{$endif read_implementation_destructor}

{ -*- buffer-read-only: t -*-

  Copyright 2018-2022 Michalis Kamburelis.

  This file is part of "Castle Game Engine".

  "Castle Game Engine" is free software; see the file COPYING.txt,
  included in this distribution, for details about the copyright.

  "Castle Game Engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

  ----------------------------------------------------------------------------
}

{ Automatically generated wrapper to make vectors/colors persistent.

  Do not edit this file manually!
  Instead
  - edit tools/internal/generate-persistent-vectors/persistent_vectors_input.txt
  - and run generate-persistent-vectors in that directory.
}

{$ifdef read_interface_class}
strict private
  FCustomColorNormalPersistent: TCastleColorPersistent;
  function GetCustomColorNormalForPersistent: TCastleColor;
  procedure SetCustomColorNormalForPersistent(const AValue: TCastleColor);
published
  { @link(CustomColorNormal) that can be visually edited in
    Castle Game Engine Editor, Lazarus and Delphi.
    Normal user code does not need to deal with this,
    instead read or write @link(CustomColorNormal) directly.

    @seealso CustomColorNormal }
  property CustomColorNormalPersistent: TCastleColorPersistent read FCustomColorNormalPersistent ;
{$endif read_interface_class}

{$ifdef read_implementation_methods}
function TCastleButton.GetCustomColorNormalForPersistent: TCastleColor;
begin
  Result := CustomColorNormal;
end;

procedure TCastleButton.SetCustomColorNormalForPersistent(const AValue: TCastleColor);
begin
  CustomColorNormal := AValue;
end;
{$endif read_implementation_methods}

{$ifdef read_implementation_constructor}
  FCustomColorNormalPersistent := TCastleColorPersistent.Create(nil);
  { Note that some classes (like TCastleVector3Persistent) call SetSubComponent(true)
    on themselves, for backward compatibility. But we should not depend on it,
    some classes (like TFloatRectanglePersisten) may not call it.
    The responsibility of calling "SetSubComponent(true)" should be on the owner
    in general (this is more functional, and more standard too). }
  FCustomColorNormalPersistent.SetSubComponent(true);
  FCustomColorNormalPersistent.InternalGetValue := {$ifdef FPC}@{$endif}GetCustomColorNormalForPersistent;
  FCustomColorNormalPersistent.InternalSetValue := {$ifdef FPC}@{$endif}SetCustomColorNormalForPersistent;
  FCustomColorNormalPersistent.InternalDefaultValue := CustomColorNormal; // current value is default
{$endif read_implementation_constructor}

{$ifdef read_implementation_destructor}
  FreeAndNil(FCustomColorNormalPersistent);
{$endif read_implementation_destructor}

